<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java数据结构之树 | Qing's Blog</title><meta name="description" content="Java数据结构之树 树 - 基础和Overview  预备知识 数据结构中的树存储结构 树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。   相关概念  树的结点   结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，图 1（A）中，数据元素 A 就是一个结点。   父结点（双亲结点）、子结点和兄弟结点：对于图 1（A）中的结点 A、B、C、D 来说，A 是"><meta name="keywords" content="Java数据结构之树"><meta name="author" content="qingbo,qingbo1011@163.com"><meta name="copyright" content="qingbo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java数据结构之树"><meta name="twitter:description" content="Java数据结构之树 树 - 基础和Overview  预备知识 数据结构中的树存储结构 树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。   相关概念  树的结点   结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，图 1（A）中，数据元素 A 就是一个结点。   父结点（双亲结点）、子结点和兄弟结点：对于图 1（A）中的结点 A、B、C、D 来说，A 是"><meta name="twitter:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><meta property="og:type" content="article"><meta property="og:title" content="Java数据结构之树"><meta property="og:url" content="http://www.qingbo1011.top/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/"><meta property="og:site_name" content="Qing's Blog"><meta property="og:description" content="Java数据结构之树 树 - 基础和Overview  预备知识 数据结构中的树存储结构 树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。   相关概念  树的结点   结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，图 1（A）中，数据元素 A 就是一个结点。   父结点（双亲结点）、子结点和兄弟结点：对于图 1（A）中的结点 A、B、C、D 来说，A 是"><meta property="og:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><meta property="article:published_time" content="2021-08-03T09:42:03.000Z"><meta property="article:modified_time" content="2023-10-03T08:16:11.781Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://www.qingbo1011.top/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/"><link rel="prev" title="Java数据结构之图" href="http://www.qingbo1011.top/2021/08/04/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE/"><link rel="next" title="Java数据结构之线性表、栈和队列" href="http://www.qingbo1011.top/2021/08/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230440.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">87</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">81</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java数据结构之树"><span class="toc-number">1.</span> <span class="toc-text"> Java数据结构之树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#预备知识"><span class="toc-number">2.</span> <span class="toc-text"> 预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#相关概念"><span class="toc-number">2.1.</span> <span class="toc-text"> 相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#树的结点"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 树的结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子树和空树"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 子树和空树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结点的度和层次"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 结点的度和层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序树和无序树"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 有序树和无序树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#森林"><span class="toc-number">2.1.5.</span> <span class="toc-text"> 森林</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的表示方法"><span class="toc-number">2.1.6.</span> <span class="toc-text"> 树的表示方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#存储普通树的方法"><span class="toc-number">3.</span> <span class="toc-text"> 存储普通树的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树"><span class="toc-number">4.</span> <span class="toc-text"> 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树性质"><span class="toc-number">4.1.</span> <span class="toc-text"> 二叉树性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树分类"><span class="toc-number">4.2.</span> <span class="toc-text"> 二叉树分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#满二叉树"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全二叉树"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 二叉查找树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的遍历"><span class="toc-number">4.3.</span> <span class="toc-text"> 二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#先序遍历"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中序遍历"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后序遍历"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#层次遍历"><span class="toc-number">4.3.4.</span> <span class="toc-text"> 层次遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的实现"><span class="toc-number">4.4.</span> <span class="toc-text"> 二叉树的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树结点"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 二叉树结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树-2"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的四种遍历"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 二叉树的四种遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉搜索树bst"><span class="toc-number">5.</span> <span class="toc-text"> 二叉搜索树(BST)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#平衡二叉树avl"><span class="toc-number">6.</span> <span class="toc-text"> 平衡二叉树(AVL)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#红黑树r-b-tree"><span class="toc-number">7.</span> <span class="toc-text"> 红黑树(R-B Tree)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#哈夫曼树huffman-tree"><span class="toc-number">8.</span> <span class="toc-text"> 哈夫曼树(Huffman Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#相关概念-2"><span class="toc-number">8.1.</span> <span class="toc-text"> 相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是哈夫曼树"><span class="toc-number">8.1.1.</span> <span class="toc-text"> 什么是哈夫曼树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建哈夫曼树"><span class="toc-number">8.2.</span> <span class="toc-text"> 构建哈夫曼树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈夫曼编码"><span class="toc-number">8.3.</span> <span class="toc-text"> 哈夫曼编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈夫曼树的实现"><span class="toc-number">8.4.</span> <span class="toc-text"> 哈夫曼树的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#哈夫曼树结点"><span class="toc-number">8.4.1.</span> <span class="toc-text"> 哈夫曼树结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈夫曼树"><span class="toc-number">8.4.2.</span> <span class="toc-text"> 哈夫曼树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小堆升序优先队列"><span class="toc-number">8.4.3.</span> <span class="toc-text"> 最小堆（升序优先队列）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前缀树tire-tree"><span class="toc-number">9.</span> <span class="toc-text"> 前缀树(Tire Tree)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#伸展树"><span class="toc-number">10.</span> <span class="toc-text"> 伸展树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#b树"><span class="toc-number">11.</span> <span class="toc-text"> B树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#标准库中的集合与映射"><span class="toc-number">12.</span> <span class="toc-text"> 标准库中的集合与映射</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Qing's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java数据结构之树</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-08-03 17:42:03"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-08-03</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-10-03 16:16:11"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2023-10-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">9.9k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 34 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="java数据结构之树"><a class="markdownIt-Anchor" href="#java数据结构之树"></a> Java数据结构之树</h1>
<p><strong><a href="https://pdai.tech/md/algorithm/alg-basic-tree.html" target="_blank" rel="noopener">树 - 基础和Overview</a></strong></p>
<h1 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h1>
<p><a href="http://data.biancheng.net/view/23.html" target="_blank" rel="noopener">数据结构中的树存储结构</a></p>
<p>树结构是一种<strong>非线性存储结构</strong>，存储的是具有“<strong>一对多</strong>”关系的数据元素的集合。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143243.png" alt="" /></p>
<h2 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h2>
<h3 id="树的结点"><a class="markdownIt-Anchor" href="#树的结点"></a> 树的结点</h3>
<ul>
<li>
<p><strong>结点</strong>：使用树结构存储的每一个数据元素都被称为“结点”。例如，图 1（A）中，数据元素 A 就是一个结点。</p>
</li>
<li>
<p><strong>父结点</strong>（双亲结点）、<strong>子结点</strong>和<strong>兄弟结点</strong>：对于图 1（A）中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称“孩子结点”）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。</p>
</li>
<li>
<p>树根结点（简称“<strong>根结点</strong>”）：<strong>每一个非空树都有且只有一个被称为根的结点</strong>。图 1（A）中，结点A就是整棵树的根结点。</p>
<blockquote>
<p>树根的判断依据为：<strong>如果一个结点没有父结点，那么这个结点就是整棵树的根结点。</strong></p>
</blockquote>
</li>
<li>
<p><strong>叶子结点</strong>：如果结点没有任何子结点，那么此结点称为叶子结点（<strong>叶结点</strong>）。例如图 1（A）中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。</p>
</li>
</ul>
<h3 id="子树和空树"><a class="markdownIt-Anchor" href="#子树和空树"></a> 子树和空树</h3>
<ul>
<li>
<p><strong>子树</strong>：如图 1（A）中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且节点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。</p>
<blockquote>
<p>注意：<strong>单个结点也是一棵树</strong>，只不过根结点就是它本身。图 1（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。</p>
<p>知道了子树的概念后，树也可以这样定义：<strong>树是由根结点和若干棵子树构成的。</strong></p>
<p>补充：**在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。**例如，图 1（A）中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。</p>
</blockquote>
</li>
<li>
<p><strong>空树</strong>：如果集合本身为空，那么构成的树就被称为空树。<strong>空树中没有结点</strong>。</p>
</li>
</ul>
<h3 id="结点的度和层次"><a class="markdownIt-Anchor" href="#结点的度和层次"></a> 结点的度和层次</h3>
<ul>
<li>
<p><strong>结点的度</strong>：<strong>对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）</strong>。例如，图 1（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。</p>
<blockquote>
<p><strong>一棵树的度是树内各结点的度的最大值</strong>。图 1（A）表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。</p>
</blockquote>
</li>
<li>
<p><strong>结点的层次</strong>：**从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。**对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。</p>
<blockquote>
<p>**一棵树的深度（高度）是树中结点所在的最大的层次。**图 1（A）树的深度为 4。</p>
</blockquote>
</li>
</ul>
<p>如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，图 1（A）中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。</p>
<h3 id="有序树和无序树"><a class="markdownIt-Anchor" href="#有序树和无序树"></a> 有序树和无序树</h3>
<p><strong>如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。</strong></p>
<blockquote>
<p>在有序树中，一个结点<strong>最左边的子树</strong>称为&quot;第一个孩子&quot;，<strong>最右边的子树</strong>称为&quot;最后一个孩子&quot;。拿图 1（A）来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。</p>
</blockquote>
<h3 id="森林"><a class="markdownIt-Anchor" href="#森林"></a> 森林</h3>
<p><strong>由 m（m &gt;= 0）个互不相交的树组成的集合被称为森林</strong>。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。</p>
<p>前面讲到，树可以理解为是由根结点和若干子树构成的，而这<strong>若干子树本身是一个森林</strong>，所以，<strong>树还可以理解为是由根结点和森林组成的</strong>。用一个式子表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tree &#x3D;（root,F）</span><br></pre></td></tr></table></figure>
<p>其中，root 表示树的根结点，F 表示由 m（m &gt;= 0）棵树组成的森林。</p>
<h3 id="树的表示方法"><a class="markdownIt-Anchor" href="#树的表示方法"></a> 树的表示方法</h3>
<p>除了图 1（A）表示树的方法外，还有其他表示方法：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143257.png" alt="" /></p>
<ul>
<li>
<p>图 2（A）是以<strong>嵌套的集合</strong>的形式表示的（<strong>集合之间绝不能相交</strong>，即图中任意两个圈不能相交）</p>
</li>
<li>
<p>图 2（B）使用的是凹入表示法（了解即可），表示方式是：最长条为根结点，相同长度的表示在同一层次。例如 B、C、D 长度相同，都为 A 的子结点，E 和 F 长度相同，为 B 的子结点，K 和 L 长度相同，为 E 的子结点，依此类推</p>
</li>
<li>
<p>最常用的表示方法是使用**<a href="http://data.biancheng.net/view/189.html" target="_blank" rel="noopener">广义表</a>**的方式。图 1（A）用广义表表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后说一下树结构（一对多）和之前的线性结构的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">树结构</th>
<th style="text-align:center">线性结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">根结点：无双亲，唯一</td>
<td style="text-align:center">第一个数据元素：无前驱元素</td>
</tr>
<tr>
<td style="text-align:center">叶结点：无孩子，可以多个</td>
<td style="text-align:center">最后一个元素：无后继元素</td>
</tr>
<tr>
<td style="text-align:center">中间结点：一个双亲多个孩子</td>
<td style="text-align:center">中间元素：一个前驱元素一个后继元素</td>
</tr>
</tbody>
</table>
<h1 id="存储普通树的方法"><a class="markdownIt-Anchor" href="#存储普通树的方法"></a> 存储普通树的方法</h1>
<p>大概分为三种：</p>
<ul>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法（孩子兄弟表示法可以作为将普通树转化为二叉树的最有效方法，通常又被称为&quot;二叉树表示法&quot;或&quot;二叉链表表示法&quot;）</li>
</ul>
<p>这里就先不给代码了，参考资料：<a href="http://data.biancheng.net/view/196.html" target="_blank" rel="noopener">树的双亲表示法（C语言实现详解版）</a></p>
<h1 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h1>
<p><a href="http://data.biancheng.net/view/192.html" target="_blank" rel="noopener">什么是二叉树，二叉树及其性质详解</a></p>
<p>接下来我们来学习一下一类具体的树结构：<strong>二叉树</strong>。</p>
<p>满足以下两个条件的树就是二叉树：</p>
<ol>
<li>本身是<strong>有序树</strong></li>
<li><strong>树中包含的各个节点的度不能超过 2</strong>，即<strong>只能是 0、1 或者 2</strong></li>
</ol>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143311.png" alt="" /></p>
<h2 id="二叉树性质"><a class="markdownIt-Anchor" href="#二叉树性质"></a> 二叉树性质</h2>
<p>二叉树性质如下：</p>
<ol>
<li>
<p>二叉树中，第 i 层最多有 2^(i-1) 个结点（很好理解，2的i-1次方嘛）</p>
</li>
<li>
<p>如果二叉树的深度为 K，那么此二叉树最多有 2^K-1 个结点（等比数列之和即可求出）</p>
</li>
<li>
<p>二叉树中，终端结点数（<strong>叶子结点数</strong>）为 n0，度为 2 的结点数为 n2，则 n0=n2+1</p>
<blockquote>
<p>性质 3 的计算方法为：<strong>对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点</strong>（设为 n1），那么总结点 n=n0+n1+n2。<br />
同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2<em>n2。所以，n 用另外一种方式表示为 n=n1+2</em>n2+1。<br />
两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。</p>
</blockquote>
</li>
</ol>
<h2 id="二叉树分类"><a class="markdownIt-Anchor" href="#二叉树分类"></a> 二叉树分类</h2>
<p>二叉树又可以分为<strong>满二叉树</strong>和<strong>完全二叉树</strong>。也有一种特殊的二叉树叫做<strong>二叉查找树</strong>。</p>
<h3 id="满二叉树"><a class="markdownIt-Anchor" href="#满二叉树"></a> 满二叉树</h3>
<p>如果二叉树中<strong>除了叶子结点，每个结点的度都为 2</strong>，则此二叉树称为<strong>满二叉树</strong>。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143322.png" alt="" /></p>
<p>满二叉树除了满足普通二叉树的性质，还具有以下性质：</p>
<ol>
<li>满二叉树中第 i 层的节点数为 2^(n-1)个（2的i-1次方）</li>
<li>深度为 k 的满二叉树必有 2^k-1 个节点 ，叶子数为 2^k-1（等比数列前n项和）</li>
<li>满二叉树中不存在度为 1 的节点，<strong>每一个分支点中都两棵深度相同的子树</strong>，且<strong>叶子节点都在最底层</strong></li>
<li>具有 n 个节点的满二叉树的深度为㏒₂n+1</li>
</ol>
<h3 id="完全二叉树"><a class="markdownIt-Anchor" href="#完全二叉树"></a> 完全二叉树</h3>
<p>如果二叉树中<strong>除去最后一层节点为满二叉树</strong>，<strong>且最后一层的结点依次从左到右分布</strong>，则此二叉树被称为<strong>完全二叉树</strong>。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143341.png" alt="" /></p>
<p>（如图所示，a是一棵完全二叉树，而b由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树）</p>
<p>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，<strong>n 个结点的完全二叉树的深度为 ⌊㏒₂n⌋+1。</strong></p>
<blockquote>
<p>⌊㏒₂n⌋ 表示取小于㏒₂n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。</p>
</blockquote>
<p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：</p>
<ol>
<li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li>
<li>如果 2<em>i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2</em>i</li>
<li>如果 2i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2i+1</li>
</ol>
<h3 id="二叉查找树"><a class="markdownIt-Anchor" href="#二叉查找树"></a> 二叉查找树</h3>
<p><a href="https://www.cnblogs.com/gaochundong/p/binary_search_tree.html" target="_blank" rel="noopener">二叉查找树</a></p>
<p>二叉查找树（BST：Binary Search Tree）是一种特殊的二叉树，它<strong>改善了二叉树节点查找的效率</strong>。二叉查找树有以下性质，对于任意一个节点 node：</p>
<ul>
<li>其左子树（left subtree）下的每个后代节点（descendant node）的值都小于节点 n 的值</li>
<li>其右子树（right subtree）下的每个后代节点的值都大于节点 n 的值</li>
</ul>
<p>简言之，就是<strong>左&lt;中&lt;右</strong>。</p>
<p>下图中，a为普通二叉树，b是二叉查找树。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143355.png" alt="" /></p>
<h2 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历"></a> 二叉树的遍历</h2>
<p><a href="http://data.biancheng.net/view/143.html" target="_blank" rel="noopener">二叉树先序遍历（递归与非递归）及C语言实现</a></p>
<p><a href="https://www.jianshu.com/p/bd0857967605" target="_blank" rel="noopener">二叉树的层次遍历</a></p>
<p>二叉树的遍历主要分三种：</p>
<ul>
<li><strong>先序遍历</strong></li>
<li><strong>中序遍历</strong></li>
<li><strong>后序遍历</strong></li>
</ul>
<p>第四种也有二叉树的<strong>层次遍历</strong>。</p>
<p>二叉树遍历的代码实现我们会在下面的二叉树实现中给出，这里先介绍一下这四种遍历。</p>
<h3 id="先序遍历"><a class="markdownIt-Anchor" href="#先序遍历"></a> 先序遍历</h3>
<p>二叉树<strong>先序遍历</strong>的实现思想是：</p>
<ol>
<li><strong>访问根节点</strong></li>
<li><strong>访问当前节点的左子树</strong></li>
<li><strong>若当前节点无左子树，则访问当前节点的右子树</strong></li>
</ol>
<blockquote>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143411.png" alt="" /></p>
<p>以图 1 为例，采用先序遍历的思想遍历该二叉树的过程为：</p>
<ol>
<li>访问该二叉树的根节点，找到 1</li>
<li>访问节点 1 的左子树，找到节点 2</li>
<li>访问节点 2 的左子树，找到节点 4</li>
<li>由于访问节点 4 左子树失败，且也没有右子树，因此以节点 4 为根节点的子树遍历完成。但节点 2 还没有遍历其右子树，因此现在开始遍历，即访问节点 5</li>
<li>由于节点 5 无左右子树，因此节点 5 遍历完成，并且由此以节点 2 为根节点的子树也遍历完成。现在回到节点 1 ，并开始遍历该节点的右子树，即访问节点 3</li>
<li>访问节点 3 左子树，找到节点 6</li>
<li>由于节点 6 无左右子树，因此节点 6 遍历完成，回到节点 3 并遍历其右子树，找到节点 7；</li>
<li>节点 7 无左右子树，因此以节点 3 为根节点的子树遍历完成，同时回归节点 1。由于节点 1 的左右子树全部遍历完成，因此整个二叉树遍历完成</li>
</ol>
<p>因此，该二叉树的先序遍历结果为：1,2,4,5,3,6,7</p>
</blockquote>
<h3 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3>
<p>二叉树<strong>中序遍历</strong>的实现思想是，从根节点出发：</p>
<ol>
<li><strong>访问当前节点的左子树</strong></li>
<li><strong>访问根节点</strong></li>
<li><strong>访问当前节点的右子树</strong></li>
</ol>
<blockquote>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143424.png" alt="" /></p>
<p>以图 1 为例，采用中序遍历的思想遍历该二叉树的过程为：</p>
<ol>
<li>访问该二叉树的根节点，找到 1</li>
<li>遍历节点 1 的左子树，找到节点 2</li>
<li>遍历节点 2 的左子树，找到节点 4</li>
<li>由于节点 4 无左孩子，因此找到节点 4，并遍历节点 4 的右子树</li>
<li>由于节点 4 无右子树，因此<code>节点 2 的左子树遍历完成</code>，<strong>输出节点4</strong>，访问节点 2，<strong>输出节点2</strong></li>
<li>遍历节点 2 的右子树，找到节点5，<strong>输出节点5</strong></li>
<li>由于节点 5 无左子树，因此访问节点 5 ，又因为节点 5 没有右子树，因此<code>节点 1 的左子树遍历完成</code>，访问节点 1 ，<strong>输出节点1</strong>，并遍历节点 1 的右子树，找到节点 3；</li>
<li>遍历节点 3 的左子树，找到节点 6</li>
<li>由于节点 6 无左子树，因此访问节点 6，<strong>输出节点6</strong>，又因为该节点无右子树，因此<code>节点 3 的左子树遍历完成</code>，开始访问节点 3 ，<strong>输出节点3</strong>，并遍历节点 3 的右子树，找到节点 7</li>
<li>由于节点 7 无左子树，因此访问节点 7，输出节点7，又因为该节点无右子树，因此<code>节点 1 的右子树遍历完成</code>，即整棵树遍历完成</li>
</ol>
<p>因此，该二叉树的<strong>中序遍历结果为：4,2,5,1,6,3,7</strong></p>
</blockquote>
<h3 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h3>
<p>二叉树后序遍历的实现思想是：从根节点出发：</p>
<ol>
<li><strong>访问当前节点的左子树</strong></li>
<li><strong>访问当前节点的右子树</strong></li>
<li><strong>访问根节点</strong></li>
</ol>
<p>（从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素）</p>
<blockquote>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143436.png" alt="" /></p>
<p>如图 1 中，对此二叉树进行后序遍历的操作过程为：</p>
<ul>
<li>从根节点 1 开始，遍历该节点的左子树（以节点 2 为根节点）</li>
<li>遍历节点 2 的左子树（以节点 4 为根节点）</li>
<li>由于节点 4 既没有左子树，也没有右子树，此时访问该节点中的元素 4，并回退到节点 2 ，遍历节点 2 的右子树（以 5 为根节点）</li>
<li>由于节点 5 无左右子树，因此可以访问节点 5 ，并且此时节点 2 的左右子树也遍历完成，因此也可以访问节点 2</li>
<li>此时回退到节点 1 ，开始遍历节点 1 的右子树（以节点 3 为根节点）</li>
<li>遍历节点 3 的左子树（以节点 6 为根节点）</li>
<li>由于节点 6 无左右树，因此访问节点 6，并回退到节点 3，开始遍历节点 3 的右子树（以节点 7 为根节点）</li>
<li>由于节点 7 无左右子树，因此访问节点 7，并且节点 3 的左右子树也遍历完成，可以访问节点 3；节点 1 的左右子树也遍历完成，可以访问节点 1</li>
<li>到此，整棵树的遍历结束</li>
</ul>
<p>因此，该二叉树的<strong>后序遍历结果为：4,5,2,6,7,3,1</strong></p>
</blockquote>
<h3 id="层次遍历"><a class="markdownIt-Anchor" href="#层次遍历"></a> 层次遍历</h3>
<p>如下图所示为二叉树的<strong>层次遍历</strong>，即按照箭头所指方向，按照1、2、3、4的层次顺序，对二叉树中各个结点进行访问(此图反映的是自左至右的层次遍历，自右至左的方式类似)。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143449.png" alt="" /></p>
<p>二叉树层次遍历的实现逻辑：要建立一个<strong>队列</strong>。先将二叉树头结点入队列，然后出队列，访问该结点，如果它有左子树，则将左子树的根结点入队：如果它有右子树，则将右子树的根结点入队。然后出队列，对出队结点访问，如此反复，直到队列为空为止。（其实也可以用栈来实现，画一下图逻辑就能理解了）</p>
<p>代码我们写在下面的二叉树实现中。</p>
<h2 id="二叉树的实现"><a class="markdownIt-Anchor" href="#二叉树的实现"></a> 二叉树的实现</h2>
<p><a href="https://segmentfault.com/a/1190000014743964" target="_blank" rel="noopener">Java数据结构与算法——二叉树及操作(包括二叉树遍历)</a></p>
<p><a href="https://www.jianshu.com/p/bd0857967605" target="_blank" rel="noopener">二叉树的层次遍历</a></p>
<p>二叉树的存储结构有两种：<strong><a href="http://data.biancheng.net/view/193.html" target="_blank" rel="noopener">顺序存储</a><strong>和</strong><a href="http://data.biancheng.net/view/194.html" target="_blank" rel="noopener">链式存储</a></strong>：</p>
<ul>
<li>二叉树的顺序存储，指的是<strong>使用顺序表（数组）存储二叉树</strong>。需要注意的是，<strong>顺序存储只适用于完全二叉树</strong>。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树（<strong>注意满二叉树也是完全二叉树</strong>）</li>
<li><strong>二叉树的链式存储结构更适合用来存储二叉树</strong>。二叉树并不适合用数组存储，因为并不是每个二叉树都是完全二叉树，普通二叉树使用顺序表存储或多或多会存在空间浪费的现象</li>
</ul>
<p>我们使用链式存储结构来实现二叉树。在之前的学习中我们已经谁了<strong>节点类Node</strong>的使用。在这里我们也要创建一个节点类BinaryTreeNode，它的属性有：</p>
<ul>
<li><strong>节点存储的数据（data）</strong></li>
<li><strong>指向左孩子节点的指针（leftChild）</strong></li>
<li><strong>指向右孩子节点的指针（rightChild）</strong></li>
</ul>
<blockquote>
<p>像我们这种，在一个节点中存储了两个个指针域的链表结构，通常称为<strong>二叉链表</strong>。有的二叉树实现使用<strong>三叉链表</strong>实现：即除了存储指向左孩子节点的指针（leftChild）和指向右孩子节点的指针（rightChild），还有<strong>存储指向父节点的指针（parentChild）</strong>。<strong>在解决实际问题时，用合适的链表结构存储二叉树，可以起到事半功倍的效果。</strong></p>
</blockquote>
<h3 id="二叉树结点"><a class="markdownIt-Anchor" href="#二叉树结点"></a> 二叉树结点</h3>
<p>首先我们要先创建一个二叉树结点类BinaryTreeNode，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树结点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;   <span class="comment">/* 结点数据 */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode leftChild;   <span class="comment">/* 指向左孩子的指针 */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode rightChild;  <span class="comment">/* 指向右孩子的指针 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftChild</span><span class="params">(BinaryTreeNode leftChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightChild</span><span class="params">(BinaryTreeNode rightChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BinaryTreeNode&#123;"</span> +</span><br><span class="line">                <span class="string">"data="</span> + data +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树-2"><a class="markdownIt-Anchor" href="#二叉树-2"></a> 二叉树</h3>
<p>然后创建二叉树类BinaryTree，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode root;    <span class="comment">// 二叉树的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空整个二叉树</span></span><br><span class="line"><span class="comment">     * 直接通过上一种方法删除到根节点即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        clear(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空二叉树中以node为节点下的子树</span></span><br><span class="line"><span class="comment">     * 清空以某个节点为根节点的子树的方法，即递归地删除每个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 给定node节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            clear(node.getLeftChild());</span><br><span class="line">            clear(node.getRightChild());</span><br><span class="line">            node = <span class="keyword">null</span>;    <span class="comment">// 删除该节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断二叉树是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树为空返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求整个二叉树的高度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取以node节点为子树的高度，通过递归实现：</span></span><br><span class="line"><span class="comment">     * 如果一个节点为空，那么这个节点肯定是一颗空树，高度为0；</span></span><br><span class="line"><span class="comment">     * 如果不为空，则遍历地比较它的左右子树高度，高的一个为这颗子树的最大高度，然后加上自身的高度即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;    <span class="comment">// 递归出口，空子树高度为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 这里的递归逻辑打一下草稿就能搞懂</span></span><br><span class="line">            <span class="keyword">int</span> leftHeight = height(node.getLeftChild());   <span class="comment">// 递归获取左子树高度</span></span><br><span class="line">            <span class="keyword">int</span> rightHeight = height(node.getRightChild());   <span class="comment">// 递归获取右子树高度</span></span><br><span class="line">            <span class="comment">// 注意这里要取左右子树的最大值，最后别忘了加1（加上node节点本身）</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求整个二叉树的结点数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取以node节点为根的子树的节点数，通过递归实现：</span></span><br><span class="line"><span class="comment">     * 如果节点为空，则个数肯定为0；</span></span><br><span class="line"><span class="comment">     * 如果不为空，则算上这个节点之后，继续递归计算所有子树的节点数，全部相加即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;    <span class="comment">// 递归出口，如果如果节点为空，则返回节点数为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 这里的递归逻辑打一下草稿就能搞懂</span></span><br><span class="line">            <span class="comment">/* 递归获取左子树节点数和右子树节点数，最终相加</span></span><br><span class="line"><span class="comment">            *  最后别忘了+1，因为要加上node节点本身 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+size(node.getLeftChild())+size(node.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取node节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getParent</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getParent(root,node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取node节点在subTree子树中的父节点 ，通过递归实现：</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subTree subTree子树即为以subTree节点为根节点的子树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getParent</span><span class="params">(BinaryTreeNode subTree,BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 以下两个递归出口 */</span></span><br><span class="line">        <span class="keyword">if</span> (subTree==<span class="keyword">null</span>)&#123; <span class="comment">// 如果是空子树，则没有父节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果子树的根节点的左右孩子之一是待查节点node，则返回子树的根节点subTree</span></span><br><span class="line">        <span class="keyword">if</span> (subTree.getLeftChild()==node||subTree.getRightChild()==node)&#123;</span><br><span class="line">            <span class="keyword">return</span> subTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始递归左右子树（这里的递归有点复杂，但是稿纸上写个例子还是能搞懂的）</span></span><br><span class="line">        <span class="comment">// 这里我们的二叉链表实现起来比较难，但是三叉链表就非常简单了</span></span><br><span class="line">        <span class="keyword">if</span> (getParent(subTree.getLeftChild(),node)!=<span class="keyword">null</span>) &#123; <span class="comment">// 注意这里判断条件中的写法</span></span><br><span class="line">            <span class="keyword">return</span> getParent(subTree.getLeftChild(), node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getParent(subTree.getRightChild(),node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回node节点的左孩子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeft</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.getLeftChild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回node节点的右孩子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRight</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.getRightChild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给parent节点插入左节点newNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertLeft</span><span class="params">(BinaryTreeNode parent,BinaryTreeNode newNode)</span></span>&#123;</span><br><span class="line">        parent.setLeftChild(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给parent节点插入右节点newNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertRight</span><span class="params">(BinaryTreeNode parent,BinaryTreeNode newNode)</span></span>&#123;</span><br><span class="line">        parent.setRightChild(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的四种遍历"><a class="markdownIt-Anchor" href="#二叉树的四种遍历"></a> 二叉树的四种遍历</h3>
<p>关于二叉树遍历的四种实现，我们专门在下面列出。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序遍历</span></span><br><span class="line"><span class="comment"> * 从根节点开始面对整个二叉树进行先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序遍历</span></span><br><span class="line"><span class="comment"> * 从node节点开始，对二叉树进行先序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node (以node节点为根节点进行先序遍历)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;   <span class="comment">// 递归出口</span></span><br><span class="line">        System.out.print(node);        <span class="comment">// 遍历根节点</span></span><br><span class="line">        preOrder(node.getLeftChild());   <span class="comment">// 先序遍历左子树</span></span><br><span class="line">        preOrder(node.getRightChild());  <span class="comment">// 先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历</span></span><br><span class="line"><span class="comment"> * 从根节点开始面对整个二叉树进行中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历</span></span><br><span class="line"><span class="comment"> * 从node节点开始，对二叉树进行中序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node (以node节点为根节点进行中序遍历)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;   <span class="comment">// 递归出口</span></span><br><span class="line">        inOrder(node.getLeftChild());   <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        System.out.print(node);        <span class="comment">// 遍历根节点</span></span><br><span class="line">        inOrder(node.getRightChild());  <span class="comment">// 中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历</span></span><br><span class="line"><span class="comment"> * 从根节点开始面对整个二叉树进行后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历</span></span><br><span class="line"><span class="comment"> * 从node节点开始，对二叉树进行后序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node (以node节点为根节点进行后序遍历)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;   <span class="comment">// 递归出口</span></span><br><span class="line">        postOrder(node.getLeftChild());   <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        postOrder(node.getRightChild());  <span class="comment">// 后序遍历右子树</span></span><br><span class="line">        System.out.print(node);        <span class="comment">// 遍历根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历</span></span><br><span class="line"><span class="comment"> * 从根节点开始面对整个二叉树进行层次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    levelOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历</span></span><br><span class="line"><span class="comment"> * 从node节点开始，对二叉树进行层次遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node (以node节点为根节点进行层次遍历)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用LinkedList来实现队列</span></span><br><span class="line">    LinkedList&lt;BinaryTreeNode&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    linkedList.add(node);   <span class="comment">// 先将node节点入队列</span></span><br><span class="line">    <span class="keyword">while</span> (!linkedList.isEmpty())&#123;  <span class="comment">// 只要队列不为空就要一直遍历下去</span></span><br><span class="line">        BinaryTreeNode poll = linkedList.poll();    <span class="comment">// 出队列</span></span><br><span class="line">        System.out.print(poll);   <span class="comment">// 遍历到该结点了</span></span><br><span class="line">        <span class="keyword">if</span> (poll.getLeftChild()!=<span class="keyword">null</span>)&#123; <span class="comment">// 有左子树，则将左子树的根结点入队</span></span><br><span class="line">            linkedList.add(poll.getLeftChild());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (poll.getRightChild()!=<span class="keyword">null</span>)&#123; <span class="comment">// 有右子树，则将右子树的根结点入队</span></span><br><span class="line">            linkedList.add(poll.getRightChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="二叉搜索树bst"><a class="markdownIt-Anchor" href="#二叉搜索树bst"></a> 二叉搜索树(BST)</h1>
<h1 id="平衡二叉树avl"><a class="markdownIt-Anchor" href="#平衡二叉树avl"></a> 平衡二叉树(AVL)</h1>
<p><a href="https://zhuanlan.zhihu.com/p/34899732" target="_blank" rel="noopener">详解 AVL 树（基础篇）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/56066942" target="_blank" rel="noopener">什么是平衡二叉树（AVL）</a></p>
<h1 id="红黑树r-b-tree"><a class="markdownIt-Anchor" href="#红黑树r-b-tree"></a> 红黑树(R-B Tree)</h1>
<h1 id="哈夫曼树huffman-tree"><a class="markdownIt-Anchor" href="#哈夫曼树huffman-tree"></a> 哈夫曼树(Huffman Tree)</h1>
<p><strong>哈夫曼树</strong>，也叫<strong>最优二叉树</strong>。</p>
<p><a href="http://data.biancheng.net/view/33.html" target="_blank" rel="noopener">哈夫曼树（赫夫曼树、最优树）及C语言实现</a></p>
<p><a href="https://pdai.tech/md/algorithm/alg-basic-tree-hafman.html" target="_blank" rel="noopener"><strong>树 - 哈夫曼树(Huffman Tree)</strong></a></p>
<h2 id="相关概念-2"><a class="markdownIt-Anchor" href="#相关概念-2"></a> 相关概念</h2>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143501.png" alt="" /></p>
<ul>
<li><strong>路径</strong>：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。</li>
<li><strong>路径长度</strong>：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。</li>
<li><strong>结点的权</strong>：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。</li>
<li><strong>结点的带权路径长度</strong>：指的是<strong>从根结点到该结点之间的路径长度</strong>与<strong>该结点的权</strong>的<strong>乘积</strong>。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。</li>
<li><strong>树的带权路径长度</strong>：<strong>树中所有叶子结点的带权路径长度之和</strong>。通常记作 “<strong>WPL</strong>” 。例如图 1 中所示的这颗树的带权路径长度为：WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3</li>
</ul>
<h3 id="什么是哈夫曼树"><a class="markdownIt-Anchor" href="#什么是哈夫曼树"></a> 什么是哈夫曼树</h3>
<p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的<strong>带权路径长度最小</strong>，称这棵树为“<strong>最优二叉树</strong>”，有时也叫“赫夫曼树”或者“<strong>哈夫曼树</strong>”。</p>
<p>在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：<strong>权重越大的结点离树根越近</strong>。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。</p>
<h2 id="构建哈夫曼树"><a class="markdownIt-Anchor" href="#构建哈夫曼树"></a> 构建哈夫曼树</h2>
<p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：</p>
<ol>
<li><strong>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</strong></li>
<li><strong>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</strong></li>
<li><strong>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</strong></li>
</ol>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143514.png" alt="" /></p>
<p>图 2 中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。</p>
<h2 id="哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼编码"></a> 哈夫曼编码</h2>
<p><strong>哈夫曼编码</strong>就是在哈夫曼树的基础上构建的，这种编码方式最大的优点就是<strong>用最少的字符包含最多的信息内容</strong>。</p>
<p>根据发送信息的内容，<strong>通过统计文本中相同字符的个数作为每个字符的权值，建立哈夫曼树</strong>。对于树中的每一个子树，<strong>统一规定其左孩子标记为 0 ，右孩子标记为 1</strong> 。这样，用到哪个字符时，从哈夫曼树的根结点开始，依次写出经过结点的标记，最终得到的就是该结点的哈夫曼编码。</p>
<blockquote>
<p>文本中字符出现的次数越多，权值越大，在哈夫曼树中的体现就是越接近树根。编码的长度越短。</p>
</blockquote>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143530.png" alt="" /></p>
<p>如图 3 所示，字符 a 用到的次数最多，其次是字符 b 。字符 a 在哈夫曼编码是 <code>0</code> ，字符 b 编码为 <code>10</code> ，字符 c 的编码为 <code>110</code> ，字符 d 的编码为 <code>111</code> 。</p>
<h2 id="哈夫曼树的实现"><a class="markdownIt-Anchor" href="#哈夫曼树的实现"></a> 哈夫曼树的实现</h2>
<blockquote>
<p>构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含<strong>指向父结点的指针</strong>。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有<strong>指向其左孩子和右孩子的指针</strong>。（即使用三叉链表）</p>
</blockquote>
<p>这里在实现二叉树时，用到了<strong>最小堆（又叫小根堆）</strong>。（其实可以使用Java中的优先队列 <strong>PriorityQueue</strong>来实现，不需要自己再写一个最小堆，但是这里我们顺带学习一下最小堆就手写了一个）</p>
<p>和实现二叉树一样，在实现哈夫曼树之前我们先来看看<strong>哈夫曼树结点类</strong>：</p>
<ul>
<li><strong>key：结点的权值</strong></li>
<li><strong>left：结点的左孩子</strong></li>
<li><strong>right：结点的右孩子</strong></li>
<li><strong>parent：结点的父结点</strong></li>
</ul>
<h3 id="哈夫曼树结点"><a class="markdownIt-Anchor" href="#哈夫曼树结点"></a> 哈夫曼树结点</h3>
<p>首先创建哈夫曼树结点类HuffmanNode，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈夫曼树结点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>,<span class="title">Cloneable</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 避免大量的使用Get和Set方法(看起来比较麻烦)，这里就用protected修饰</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> key;              <span class="comment">// 权值</span></span><br><span class="line">    <span class="keyword">protected</span> HuffmanNode left;     <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="keyword">protected</span> HuffmanNode right;    <span class="comment">// 右孩子</span></span><br><span class="line">    <span class="keyword">protected</span> HuffmanNode parent;   <span class="comment">// 父结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanNode</span><span class="params">(<span class="keyword">int</span> key, HuffmanNode left, HuffmanNode right, HuffmanNode parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写clone方法，返回一个克隆的哈夫曼树结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = (HuffmanNode)<span class="keyword">super</span>.clone();    <span class="comment">// Object中的clone(),识别出你要复制的是哪一个对象。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写compareTo方法，根据key值升序排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.key - ((HuffmanNode)o).key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈夫曼树"><a class="markdownIt-Anchor" href="#哈夫曼树"></a> 哈夫曼树</h3>
<p>然后创建HuffmanTree类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈夫曼树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HuffmanNode root;   <span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法（根据结点key值数组来创建哈夫曼树）</span></span><br><span class="line"><span class="comment">     * 根据哈夫曼树的特性，构造中需要用到优先队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 存储各个结点key值的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanTree</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        HuffmanNode parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 根据数组arr建立最小堆</span></span><br><span class="line">        MinHeap minHeap = <span class="keyword">new</span> MinHeap(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// dumpFromMinimum操作其实就是类似从升序优先队列中poll出一个值</span></span><br><span class="line">            HuffmanNode left = minHeap.dumpFromMinimum();   <span class="comment">// 左节点比右节点要小</span></span><br><span class="line">            HuffmanNode right = minHeap.dumpFromMinimum();   <span class="comment">// 左节点比右节点要小</span></span><br><span class="line">            <span class="comment">// 最小的两个节点确定后，将它们的父结点插入到小根堆中</span></span><br><span class="line">            parent = <span class="keyword">new</span> HuffmanNode(left.key + right.key, left, right, <span class="keyword">null</span>);</span><br><span class="line">            minHeap.insert(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后，最后的parent节点即为哈夫曼树的根节点</span></span><br><span class="line">        root = parent;</span><br><span class="line">        <span class="comment">// 哈夫曼树构造完毕理内存，销毁最小堆</span></span><br><span class="line">        minHeap.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历、中序遍历、后序遍历以及层次遍历跟二叉树的实现一样，这里不再多说</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(HuffmanNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;    <span class="comment">// 递归出口node为null</span></span><br><span class="line">            System.out.print(node.key+<span class="string">" "</span>);</span><br><span class="line">            preOrder(node.left);</span><br><span class="line">            preOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(HuffmanNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;    <span class="comment">// 递归出口node为null</span></span><br><span class="line">            inOrder(node.left);</span><br><span class="line">            System.out.print(node.key+<span class="string">" "</span>);</span><br><span class="line">            inOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        postOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(HuffmanNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;    <span class="comment">// 递归出口node为null</span></span><br><span class="line">            postOrder(node.left);</span><br><span class="line">            postOrder(node.right);</span><br><span class="line">            System.out.print(node.key+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层次遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        levelOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(HuffmanNode node)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;HuffmanNode&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();     <span class="comment">// 用队列来实现层次遍历</span></span><br><span class="line">        deque.add(node);    <span class="comment">// 先将add节点入队列</span></span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty())&#123;   <span class="comment">// 主要队列不为空就要一直遍历下去</span></span><br><span class="line">            HuffmanNode remove = deque.remove();</span><br><span class="line">            System.out.print(remove.key+<span class="string">" "</span>);   <span class="comment">// 遍历到该结点了</span></span><br><span class="line">            <span class="keyword">if</span> (remove.left!=<span class="keyword">null</span>)&#123; <span class="comment">// 该节点有左孩子，入队</span></span><br><span class="line">                deque.add(remove.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (remove.right!=<span class="keyword">null</span>)&#123; <span class="comment">// 该节点有右孩子，入队</span></span><br><span class="line">                deque.add(remove.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印哈夫曼树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            print(root,root.key,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印哈夫曼树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 结点的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> direction 对node结点的描述：</span></span><br><span class="line"><span class="comment">     *                  0，表示该节点是根节点;</span></span><br><span class="line"><span class="comment">     *                  -1，表示该节点是它的父结点的左孩子;</span></span><br><span class="line"><span class="comment">     *                  1，表示该节点是它的父结点的右孩子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(HuffmanNode node, <span class="keyword">int</span> key, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (direction==<span class="number">0</span>)&#123;  <span class="comment">// node是根结点</span></span><br><span class="line">                System.out.printf(<span class="string">"%2d is root\n"</span>, node.key);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 根据node是左孩子还是右孩子来输出</span></span><br><span class="line">                System.out.printf(<span class="string">"%2d is %2d's %6s child\n"</span>, node.key, key, direction==<span class="number">1</span>?<span class="string">"right"</span> : <span class="string">"left"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            print(node.left,node.key,-<span class="number">1</span>);</span><br><span class="line">            print(node.right,node.key,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里关键的其实就是哈夫曼树的创建过程。根据哈夫曼树的特性很容易想到用<strong>升序优先队列</strong>（<strong>最小堆</strong>或者叫<strong>小根堆</strong>）来实现。</p>
<p>以数组{5,6,8,7,15}为例，哈夫曼树的构造过程如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143543.png" alt="" /></p>
<h3 id="最小堆升序优先队列"><a class="markdownIt-Anchor" href="#最小堆升序优先队列"></a> 最小堆（升序优先队列）</h3>
<p>其中最小堆其实可以用Java自带的优先队列来实现，这里我们敲一下代码体会下如何实现优先队列。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HuffmanNode&gt; heap; <span class="comment">// 存放堆的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，根据给定数组创建最小堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数据所在数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        heap = <span class="keyword">new</span> ArrayList&lt;HuffmanNode&gt;();</span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            HuffmanNode huffmanNode = <span class="keyword">new</span> HuffmanNode(arr[i], <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            heap.add(huffmanNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从(size/2-1)到0逐次遍历。遍历之后，得到的数组实际上是一个最小堆。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            filterdown(i, arr.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小堆的向下调整算法</span></span><br><span class="line"><span class="comment">     * 注：数组实现的堆中，第N个结点的左孩子索引是(2N+1)，右孩子的索引是(2N+2)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 被下调节点的起始位置(一般为0，表示从第1个开始)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 截至范围(一般为数组中最后一个元素的索引)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">filterdown</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current = start;  <span class="comment">// 当前结点的位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span>*current+<span class="number">1</span>; <span class="comment">// 当前结点的左孩子的位置</span></span><br><span class="line">        HuffmanNode temp = heap.get(current);   <span class="comment">// 当前结点</span></span><br><span class="line">        <span class="comment">// 上面已经说过，left为左孩子位置，那么右孩子位置即为left+1</span></span><br><span class="line">        <span class="keyword">while</span> (left&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">if</span> (left&lt;end &amp;&amp; (heap.get(left).compareTo(heap.get(left+<span class="number">1</span>))&gt;<span class="number">0</span>))&#123;</span><br><span class="line">                left++; <span class="comment">// 左右两孩子中选择较小者，即heap[left+1]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cmp = temp.compareTo(heap.get(left));</span><br><span class="line">            <span class="keyword">if</span> (cmp&lt;=<span class="number">0</span>)&#123;    <span class="comment">// 调整结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                heap.set(current, heap.get(left));</span><br><span class="line">                current = left;</span><br><span class="line">                left = <span class="number">2</span>*left+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        heap.set(current,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小堆的向上调整法（从start开始向上到0，调整堆）</span></span><br><span class="line"><span class="comment">     * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 从start开始向上到0，调整堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">filterup</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current = start;    <span class="comment">// 当前结点位置</span></span><br><span class="line">        <span class="keyword">int</span> parent = (current - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 当前结点的父结点位置</span></span><br><span class="line">        HuffmanNode temp = heap.get(current);   <span class="comment">// 当前结点</span></span><br><span class="line">        <span class="keyword">while</span> (current&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = heap.get(parent).compareTo(temp);</span><br><span class="line">            <span class="keyword">if</span> (cmp&lt;=<span class="number">0</span>)&#123;    <span class="comment">// parent结点不大于temp结点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                heap.set(current, heap.get(parent));</span><br><span class="line">                current = parent;</span><br><span class="line">                parent = (parent-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            heap.set(current,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将结点插入到二叉堆中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要插入的哈夫曼树结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(HuffmanNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = heap.size();</span><br><span class="line">        heap.add(node);     <span class="comment">// 将"数组"插在表尾</span></span><br><span class="line">        filterup(size);     <span class="comment">// 向上调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换i位置和j位置这两个结点的全部数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapNode</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        HuffmanNode temp = heap.get(i);</span><br><span class="line">        heap.set(i, heap.get(j));</span><br><span class="line">        heap.set(j,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * poll出最小堆中的最小元素（类似于优先队列的出队操作）</span></span><br><span class="line"><span class="comment">     * 新建一个节点，并将最小堆中最小节点的数据复制给该节点,然后除最小节点之外的数据重新构造成最小堆。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回原最小堆中最小的结点。若失败则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HuffmanNode <span class="title">dumpFromMinimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = heap.size();</span><br><span class="line">        <span class="comment">// 如果"堆"已空，则返回</span></span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将"最小结点"克隆一份，将克隆得到的对象赋值给node</span></span><br><span class="line">        HuffmanNode node = (HuffmanNode)heap.get(<span class="number">0</span>).clone();</span><br><span class="line">        <span class="comment">// 交换"最小结点"和"最后一个结点"</span></span><br><span class="line">        heap.set(<span class="number">0</span>, heap.get(size-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 删除最后的元素（交换后，即删除了最小结点）</span></span><br><span class="line">        heap.remove(size-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 向下调整堆，使第0个元素为最小元素，保证新的堆依然是最小堆</span></span><br><span class="line">            filterdown(<span class="number">0</span>, heap.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁最小堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        heap.clear();</span><br><span class="line">        heap = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="前缀树tire-tree"><a class="markdownIt-Anchor" href="#前缀树tire-tree"></a> 前缀树(Tire Tree)</h1>
<h1 id="伸展树"><a class="markdownIt-Anchor" href="#伸展树"></a> 伸展树</h1>
<h1 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B树</h1>
<h1 id="标准库中的集合与映射"><a class="markdownIt-Anchor" href="#标准库中的集合与映射"></a> 标准库中的集合与映射</h1>
<p>在之前的<a href="https://www.qingbo1011.top/2021/08/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#list%E6%8E%A5%E5%8F%A3-arraylist%E7%B1%BB%E5%92%8Clinkedlist%E7%B1%BB">笔记</a>中我们讨论过的List容器，即<code>ArrayList</code>和<code>LinkedList</code>用于<strong>查找效率很低</strong>。因此，Collections API提供了两个附加容器<code>Set</code>和<code>Map</code>，它们对诸如插人、删除和查找等基本操作提供有效的实现。</p>
<p><a href="http://c.biancheng.net/view/6847.html" target="_blank" rel="noopener">Java Set集合：HashSet和TreeSet类</a></p>
<p><a href="http://c.biancheng.net/view/6868.html" target="_blank" rel="noopener">Java Map集合详解</a></p>
<p><a href="http://www.justdojava.com/2019/11/05/java-collection-11/" target="_blank" rel="noopener">【集合系列】- 深入浅出的分析 Set集合</a></p>
<p><a href="http://www.justdojava.com/2020/01/17/java-collection-17/" target="_blank" rel="noopener"><strong>集合知识全系列回顾</strong></a></p>
<p>可以参考之前写的有道云笔记：<a href="http://note.youdao.com/noteshare?id=52c62dc6d1bbc5920249e1297c367afe&amp;sub=0CFDE56ED15141039BB798B0531C33F5" target="_blank" rel="noopener">Map</a>，<a href="http://note.youdao.com/noteshare?id=ec8edb8df0d230ac15f9686cb40ceb69&amp;sub=04C6C961CDA146C6B6065799EEB11F96" target="_blank" rel="noopener">Set集合</a></p>
<blockquote>
<p>在 Java 中，集合大致可以分为两大体系，一个是 <strong>Collection</strong>，另一个是 <strong>Map</strong>，都位于<code>java.util</code>包下。</p>
<ul>
<li><strong>Collection ：主要由 List、Set、Queue 接口组成，List 代表有序、重复的集合；其中 Set 代表无序、不可重复的集合；Java 5 又增加了 Queue 体系集合，代表队列集合。</strong></li>
<li><strong>Map：则代表具有映射关系的键值对集合。</strong></li>
</ul>
<p><strong>java.util.Collection下的接口和继承类关系简易结构图：</strong></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143626.png" alt="" /></p>
<p><strong>java.util.Map下的接口和继承类关系简易结构图：</strong></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503143651.png" alt="" /></p>
<p>在 Java 集合框架中，<strong>数据结构和算法</strong>可以说在里面体现的淋淋尽致，这一点可以从我们之前对各个集合类的分析就可以看的出来，如动态数组、链表、红黑树、Set、Map、队列、栈、堆等，基本上只要出去面试，集合框架的话题一定不会少！</p>
<p>更具体的，可参考我搬运的笔记：<a href="https://www.qingbo1011.top/2021/08/31/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E5%85%A8%E7%B3%BB%E5%88%97%E5%9B%9E%E9%A1%BE/"><strong>Java数据结构之集合知识全系列</strong></a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:qingbo1011@163.com">qingbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.qingbo1011.top/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/">http://www.qingbo1011.top/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.qingbo1011.top" target="_blank">Qing's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20231003161115.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/08/04/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE/"><img class="prev_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java数据结构之图</div></div></a></div><div class="next-post pull_right"><a href="/2021/08/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"><img class="next_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java数据结构之线性表、栈和队列</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/08/04/Java数据结构之图/" title="Java数据结构之图"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-04</div><div class="relatedPosts_title">Java数据结构之图</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/01/Java数据结构之基础知识/" title="Java数据结构之基础知识"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-01</div><div class="relatedPosts_title">Java数据结构之基础知识</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/05/Java数据结构之堆、散列、并查集/" title="Java数据结构之堆（优先队列）、散列（哈希表）和并查集"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-05</div><div class="relatedPosts_title">Java数据结构之堆（优先队列）、散列（哈希表）和并查集</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/02/Java数据结构之线性表、栈和队列/" title="Java数据结构之线性表、栈和队列"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-02</div><div class="relatedPosts_title">Java数据结构之线性表、栈和队列</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/31/Java数据结构之集合知识全系列回顾/" title="Java数据结构之集合知识全系列"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-31</div><div class="relatedPosts_title">Java数据结构之集合知识全系列</div></div></a></div><div class="relatedPosts_item"><a href="/2021/03/25/JDBC（一）/" title="JDBC（一）"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220508214453.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-25</div><div class="relatedPosts_title">JDBC（一）</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'oNS5Emx1qUL3wN5yvPLKol0W-gzGzoHsz',
  appKey: 'ytbw0ho3DMX0FeoAOWa37lf9',
  notify: false,
  verify: false,
  placeholder: 'Stay hungry,stay foolish~',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: 'https://',
  emojiMaps: {"欢呼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100836.gif","笑眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100849.gif","花心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100907.gif","吐舌":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100937.gif","疑问":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100951.gif","滑稽":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101004.gif","太开心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101017.gif","酷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101029.gif","怒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101044.gif","阴险":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101100.gif","委屈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101116.gif","乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101129.gif","你懂的":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101204.gif","小乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101215.gif","突然兴奋":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101228.gif","喷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101241.gif","哈哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101255.gif","喝酒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101305.gif","汗":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101323.gif","笑尿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102004.gif","嘿嘿嘿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102018.gif","真棒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102047.gif","托腮":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102108.gif","微笑":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","礼貌":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","笑哭":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","无奈":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","爱你":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","吃瓜":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_thumb.png","doge":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","dog":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","cat":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_thumb.png","星星眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102225.png","酸了":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102240.png","大哭":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102254.png","傲娇":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102314.png","给心心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102328.png","嘿哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102345.png","custom0":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101410.gif","custom1":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101424.webp","狗头":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101710.png","搬砖中":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101744.png","忙到飞起":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102411.png","裂开":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102426.png","叹气":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102439.png","让我看看":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102456.png","panda0":"https://bbs.res.meizu.com/static/image/smiley/panda/_000.png","panda1":"https://bbs.res.meizu.com/static/image/smiley/panda/_001.png","panda2":"https://bbs.res.meizu.com/static/image/smiley/panda/_002.png","panda3":"https://bbs.res.meizu.com/static/image/smiley/panda/_003.png","panda4":"https://bbs.res.meizu.com/static/image/smiley/panda/_004.png","panda5":"https://bbs.res.meizu.com/static/image/smiley/panda/_005.png","panda6":"https://bbs.res.meizu.com/static/image/smiley/panda/_006.png","panda7":"https://bbs.res.meizu.com/static/image/smiley/panda/_007.png","panda8":"https://bbs.res.meizu.com/static/image/smiley/panda/_008.png","panda9":"https://bbs.res.meizu.com/static/image/smiley/panda/_009.png","panda10":"https://bbs.res.meizu.com/static/image/smiley/panda/_010.png","panda11":"https://bbs.res.meizu.com/static/image/smiley/panda/_011.png","panda12":"https://bbs.res.meizu.com/static/image/smiley/panda/_012.png","panda13":"https://bbs.res.meizu.com/static/image/smiley/panda/_013.png","panda14":"https://bbs.res.meizu.com/static/image/smiley/panda/_014.png","panda15":"https://bbs.res.meizu.com/static/image/smiley/panda/_015.png","panda16":"https://bbs.res.meizu.com/static/image/smiley/panda/_016.png","panda17":"https://bbs.res.meizu.com/static/image/smiley/panda/_017.png","panda18":"https://bbs.res.meizu.com/static/image/smiley/panda/_018.png","panda19":"https://bbs.res.meizu.com/static/image/smiley/panda/_019.png","panda20":"https://bbs.res.meizu.com/static/image/smiley/panda/_020.png","panda21":"https://bbs.res.meizu.com/static/image/smiley/panda/_021.png","panda22":"https://bbs.res.meizu.com/static/image/smiley/panda/_022.png","panda23":"https://bbs.res.meizu.com/static/image/smiley/panda/_023.png","panda24":"https://bbs.res.meizu.com/static/image/smiley/panda/_024.png","panda25":"https://bbs.res.meizu.com/static/image/smiley/panda/_025.png","panda26":"https://bbs.res.meizu.com/static/image/smiley/panda/_026.png","panda27":"https://bbs.res.meizu.com/static/image/smiley/panda/_027.png","panda28":"https://bbs.res.meizu.com/static/image/smiley/panda/_028.png","panda29":"https://bbs.res.meizu.com/static/image/smiley/panda/_029.png"},
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By qingbo</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">宇宙很大，生活更大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script></body></html>
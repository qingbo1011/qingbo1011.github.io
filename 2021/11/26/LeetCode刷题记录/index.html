<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>LeetCode刷题记录（Java） | Qing's Blog</title><meta name="description" content="LeetCode刷题记录（Java）  1.两数之和 LeetCode 1.两数之和  暴力算法 没啥好说明的。 代码如下： 12345678910111213141516class Solution &amp;#123;    public int[] twoSum(int[] nums, int target) &amp;#123;        int[] result &#x3D; new int[2];"><meta name="keywords" content="LeetCode刷题记录（Java）"><meta name="author" content="qingbo,qingbo1011@163.com"><meta name="copyright" content="qingbo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="LeetCode刷题记录（Java）"><meta name="twitter:description" content="LeetCode刷题记录（Java）  1.两数之和 LeetCode 1.两数之和  暴力算法 没啥好说明的。 代码如下： 12345678910111213141516class Solution &amp;#123;    public int[] twoSum(int[] nums, int target) &amp;#123;        int[] result &#x3D; new int[2];"><meta name="twitter:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220806220141.png"><meta property="og:type" content="article"><meta property="og:title" content="LeetCode刷题记录（Java）"><meta property="og:url" content="http://www.qingbo1011.top/2021/11/26/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"><meta property="og:site_name" content="Qing's Blog"><meta property="og:description" content="LeetCode刷题记录（Java）  1.两数之和 LeetCode 1.两数之和  暴力算法 没啥好说明的。 代码如下： 12345678910111213141516class Solution &amp;#123;    public int[] twoSum(int[] nums, int target) &amp;#123;        int[] result &#x3D; new int[2];"><meta property="og:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220806220141.png"><meta property="article:published_time" content="2021-11-26T00:47:03.000Z"><meta property="article:modified_time" content="2023-10-03T08:16:11.781Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://www.qingbo1011.top/2021/11/26/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"><link rel="prev" title="Golang基础（一）" href="http://www.qingbo1011.top/2022/04/23/Golang%E5%9F%BA%E7%A1%8001/"><link rel="next" title="如何续七牛云免费证书" href="http://www.qingbo1011.top/2021/10/27/%E4%B8%83%E7%89%9B%E4%BA%91%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230440.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">87</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">81</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode刷题记录java"><span class="toc-number">1.</span> <span class="toc-text"> LeetCode刷题记录（Java）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1两数之和"><span class="toc-number">2.</span> <span class="toc-text"> 1.两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力算法"><span class="toc-number">2.1.</span> <span class="toc-text"> 暴力算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表"><span class="toc-number">2.2.</span> <span class="toc-text"> 哈希表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-两数相加"><span class="toc-number">3.</span> <span class="toc-text"> 2. 两数相加</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单链表"><span class="toc-number">3.1.</span> <span class="toc-text"> 单链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-无重复字符的最长子串"><span class="toc-number">4.</span> <span class="toc-text"> 3. 无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap"><span class="toc-number">4.1.</span> <span class="toc-text"> HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对哈希表方法的优化滑动窗口"><span class="toc-number">4.2.</span> <span class="toc-text"> 对哈希表方法的优化：滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-最长回文子串"><span class="toc-number">5.</span> <span class="toc-text"> 5. 最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-number">5.1.</span> <span class="toc-text"> 动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-z-字形变换"><span class="toc-number">6.</span> <span class="toc-text"> 6. Z 字形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二维矩阵模拟"><span class="toc-number">6.1.</span> <span class="toc-text"> 二维矩阵模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-整数反转"><span class="toc-number">7.</span> <span class="toc-text"> 7. 整数反转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数学"><span class="toc-number">7.1.</span> <span class="toc-text"> 数学</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-回文数"><span class="toc-number">8.</span> <span class="toc-text"> 9. 回文数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针"><span class="toc-number">8.1.</span> <span class="toc-text"> 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11盛最多的水的容器"><span class="toc-number">9.</span> <span class="toc-text"> 11.盛最多的水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法"><span class="toc-number">9.1.</span> <span class="toc-text"> 贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-最长公共前缀"><span class="toc-number">10.</span> <span class="toc-text"> 14. 最长公共前缀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-删除链表的倒数第-n-个结点"><span class="toc-number">11.</span> <span class="toc-text"> 19. 删除链表的倒数第 N 个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单链表-2"><span class="toc-number">11.1.</span> <span class="toc-text"> 单链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-有效的括号"><span class="toc-number">12.</span> <span class="toc-text"> 20. 有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#栈"><span class="toc-number">12.1.</span> <span class="toc-text"> 栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-合并两个有序链表"><span class="toc-number">13.</span> <span class="toc-text"> 21. 合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针-2"><span class="toc-number">13.1.</span> <span class="toc-text"> 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-括号生成"><span class="toc-number">14.</span> <span class="toc-text"> 22. 括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯剪枝"><span class="toc-number">14.1.</span> <span class="toc-text"> 回溯+剪枝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-串联所有单词的子串"><span class="toc-number">15.</span> <span class="toc-text"> 30. 串联所有单词的子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表子数组匹配"><span class="toc-number">15.1.</span> <span class="toc-text"> 哈希表+子数组匹配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-有效的数独"><span class="toc-number">16.</span> <span class="toc-text"> 36. 有效的数独</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表-2"><span class="toc-number">16.1.</span> <span class="toc-text"> 哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">16.2.</span> <span class="toc-text"> 数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-接雨水"><span class="toc-number">17.</span> <span class="toc-text"> 42. 接雨水</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈"><span class="toc-number">17.1.</span> <span class="toc-text"> 单调栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-字符串相乘"><span class="toc-number">18.</span> <span class="toc-text"> 43. 字符串相乘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟"><span class="toc-number">18.1.</span> <span class="toc-text"> 模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-跳跃游戏-ii"><span class="toc-number">19.</span> <span class="toc-text"> 45. 跳跃游戏 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法-2"><span class="toc-number">19.1.</span> <span class="toc-text"> 贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46-全排列"><span class="toc-number">20.</span> <span class="toc-text"> 46. 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯算法"><span class="toc-number">20.1.</span> <span class="toc-text"> 回溯算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47-全排列-ii"><span class="toc-number">21.</span> <span class="toc-text"> 47. 全排列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯算法-2"><span class="toc-number">21.1.</span> <span class="toc-text"> 回溯算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#50-powx-n"><span class="toc-number">22.</span> <span class="toc-text"> 50. Pow(x, n)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分治算法"><span class="toc-number">22.1.</span> <span class="toc-text"> 分治算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-最大子数组和"><span class="toc-number">23.</span> <span class="toc-text"> 53. 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法-3"><span class="toc-number">23.1.</span> <span class="toc-text"> 贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55跳跃游戏"><span class="toc-number">24.</span> <span class="toc-text"> 55.跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法-4"><span class="toc-number">24.1.</span> <span class="toc-text"> 贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56合并区间"><span class="toc-number">25.</span> <span class="toc-text"> 56.合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力算法-2"><span class="toc-number">25.1.</span> <span class="toc-text"> 暴力算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法stack"><span class="toc-number">25.2.</span> <span class="toc-text"> 贪心算法+Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列接近双百"><span class="toc-number">25.3.</span> <span class="toc-text"> 队列（接近双百）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bitset无排序2ms"><span class="toc-number">25.4.</span> <span class="toc-text"> BitSet（无排序，2ms）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#67-二进制求和"><span class="toc-number">26.</span> <span class="toc-text"> 67. 二进制求和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟栈"><span class="toc-number">26.1.</span> <span class="toc-text"> 模拟+栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#69-x-的平方根"><span class="toc-number">27.</span> <span class="toc-text"> 69. x 的平方根</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找"><span class="toc-number">27.1.</span> <span class="toc-text"> 二分查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#71-简化路径"><span class="toc-number">28.</span> <span class="toc-text"> 71. 简化路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟栈-2"><span class="toc-number">28.1.</span> <span class="toc-text"> 模拟+栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#73-矩阵置零"><span class="toc-number">29.</span> <span class="toc-text"> 73. 矩阵置零</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二维数组的一维表示"><span class="toc-number">29.1.</span> <span class="toc-text"> 二维数组的一维表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组-2"><span class="toc-number">29.2.</span> <span class="toc-text"> 数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#78-子集"><span class="toc-number">30.</span> <span class="toc-text"> 78. 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯算法-3"><span class="toc-number">30.1.</span> <span class="toc-text"> 回溯算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#82-删除排序链表中的重复元素ii"><span class="toc-number">31.</span> <span class="toc-text"> 82. 删除排序链表中的重复元素II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针-3"><span class="toc-number">31.1.</span> <span class="toc-text"> 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#83-删除排序链表中的重复元素"><span class="toc-number">32.</span> <span class="toc-text"> 83. 删除排序链表中的重复元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针-4"><span class="toc-number">32.1.</span> <span class="toc-text"> 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#84-柱状图中最大的矩形"><span class="toc-number">33.</span> <span class="toc-text"> 84. 柱状图中最大的矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力算法tle"><span class="toc-number">33.1.</span> <span class="toc-text"> 暴力算法（TLE）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈-2"><span class="toc-number">33.2.</span> <span class="toc-text"> 单调栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈哨兵优化"><span class="toc-number">33.3.</span> <span class="toc-text"> 单调栈（哨兵优化）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#88-合并两个有序数组"><span class="toc-number">34.</span> <span class="toc-text"> 88. 合并两个有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-number">34.1.</span> <span class="toc-text"> 排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针-5"><span class="toc-number">34.2.</span> <span class="toc-text"> 双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逆向双指针"><span class="toc-number">34.3.</span> <span class="toc-text"> 逆向双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#90-子集-ii"><span class="toc-number">35.</span> <span class="toc-text"> 90. 子集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯算法-4"><span class="toc-number">35.1.</span> <span class="toc-text"> 回溯算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#92-反转链表-ii"><span class="toc-number">36.</span> <span class="toc-text"> 92. 反转链表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单链表先切割再合并"><span class="toc-number">36.1.</span> <span class="toc-text"> 单链表（先切割再合并）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#头插法"><span class="toc-number">36.2.</span> <span class="toc-text"> 头插法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈-2"><span class="toc-number">36.3.</span> <span class="toc-text"> 栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#94-二叉树的中序遍历"><span class="toc-number">37.</span> <span class="toc-text"> 94. 二叉树的中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#深度优先搜索dfs"><span class="toc-number">37.1.</span> <span class="toc-text"> 深度优先搜索（DFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#101-对称二叉树"><span class="toc-number">38.</span> <span class="toc-text"> 101. 对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-number">38.1.</span> <span class="toc-text"> 递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#102-二叉树的层序遍历"><span class="toc-number">39.</span> <span class="toc-text"> 102. 二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#广度优先搜索bfs"><span class="toc-number">39.1.</span> <span class="toc-text"> 广度优先搜索（BFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#104-二叉树的最大深度"><span class="toc-number">40.</span> <span class="toc-text"> 104. 二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#深度优先搜索dfs-2"><span class="toc-number">40.1.</span> <span class="toc-text"> 深度优先搜索（DFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="toc-number">41.</span> <span class="toc-text"> 105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#118-杨辉三角"><span class="toc-number">42.</span> <span class="toc-text"> 118. 杨辉三角</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数学-2"><span class="toc-number">42.1.</span> <span class="toc-text"> 数学</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#119-杨辉三角-ii"><span class="toc-number">43.</span> <span class="toc-text"> 119. 杨辉三角 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数学-3"><span class="toc-number">43.1.</span> <span class="toc-text"> 数学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学优化"><span class="toc-number">43.2.</span> <span class="toc-text"> 数学优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#121-买卖股票的最佳时机"><span class="toc-number">44.</span> <span class="toc-text"> 121. 买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈-3"><span class="toc-number">44.1.</span> <span class="toc-text"> 单调栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#134-加油站"><span class="toc-number">45.</span> <span class="toc-text"> 134. 加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法-5"><span class="toc-number">45.1.</span> <span class="toc-text"> 贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#136-只出现一次的数字"><span class="toc-number">46.</span> <span class="toc-text"> 136. 只出现一次的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算"><span class="toc-number">46.1.</span> <span class="toc-text"> 位运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#141-环形链表"><span class="toc-number">47.</span> <span class="toc-text"> 141. 环形链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表-3"><span class="toc-number">47.1.</span> <span class="toc-text"> 哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快慢指针"><span class="toc-number">47.2.</span> <span class="toc-text"> 快慢指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#142-环形链表-ii"><span class="toc-number">48.</span> <span class="toc-text"> 142. 环形链表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表-4"><span class="toc-number">48.1.</span> <span class="toc-text"> 哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快慢指针-2"><span class="toc-number">48.2.</span> <span class="toc-text"> 快慢指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#144-二叉树的前序遍历"><span class="toc-number">49.</span> <span class="toc-text"> 144. 二叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#深度优先搜索dfs-3"><span class="toc-number">49.1.</span> <span class="toc-text"> 深度优先搜索（DFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#145-二叉树的后序遍历"><span class="toc-number">50.</span> <span class="toc-text"> 145. 二叉树的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#深度优先搜索dfs-4"><span class="toc-number">50.1.</span> <span class="toc-text"> 深度优先搜索（DFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#146-lru-缓存"><span class="toc-number">51.</span> <span class="toc-text"> 146. LRU 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表-双向链表"><span class="toc-number">51.1.</span> <span class="toc-text"> 哈希表 + 双向链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#155-最小栈"><span class="toc-number">52.</span> <span class="toc-text"> 155. 最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#栈辅助栈"><span class="toc-number">52.1.</span> <span class="toc-text"> 栈+辅助栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单链表-3"><span class="toc-number">52.2.</span> <span class="toc-text"> 单链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#160-相交链表"><span class="toc-number">53.</span> <span class="toc-text"> 160. 相交链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表-5"><span class="toc-number">53.1.</span> <span class="toc-text"> 哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针空间复杂度o1"><span class="toc-number">53.2.</span> <span class="toc-text"> 双指针（空间复杂度O(1)）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#169-多数元素"><span class="toc-number">54.</span> <span class="toc-text"> 169. 多数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap-2"><span class="toc-number">54.1.</span> <span class="toc-text"> HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治算法-2"><span class="toc-number">54.2.</span> <span class="toc-text"> 分治算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#179-最大数"><span class="toc-number">55.</span> <span class="toc-text"> 179. 最大数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心优先队列"><span class="toc-number">55.1.</span> <span class="toc-text"> 贪心+优先队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#191-位1的个数"><span class="toc-number">56.</span> <span class="toc-text"> 191. 位1的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算-2"><span class="toc-number">56.1.</span> <span class="toc-text"> 位运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#200-岛屿数量"><span class="toc-number">57.</span> <span class="toc-text"> 200. 岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#深度优先搜索dfs-5"><span class="toc-number">57.1.</span> <span class="toc-text"> 深度优先搜索（DFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#203-移除链表元素"><span class="toc-number">58.</span> <span class="toc-text"> 203. 移除链表元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针-6"><span class="toc-number">58.1.</span> <span class="toc-text"> 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#206-反转链表"><span class="toc-number">59.</span> <span class="toc-text"> 206. 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单链表-4"><span class="toc-number">59.1.</span> <span class="toc-text"> 单链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#215-数组中的第k个最大元素"><span class="toc-number">60.</span> <span class="toc-text"> 215. 数组中的第K个最大元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#217-存在重复元素"><span class="toc-number">61.</span> <span class="toc-text"> 217. 存在重复元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表-6"><span class="toc-number">61.1.</span> <span class="toc-text"> 哈希表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#225-用队列实现栈"><span class="toc-number">62.</span> <span class="toc-text"> 225. 用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#队列"><span class="toc-number">62.1.</span> <span class="toc-text"> 队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#226-翻转二叉树"><span class="toc-number">63.</span> <span class="toc-text"> 226. 翻转二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#232-用栈实现队列"><span class="toc-number">64.</span> <span class="toc-text"> 232. 用栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#栈入队on-出队o1"><span class="toc-number">64.1.</span> <span class="toc-text"> 栈(入队：O(n)， 出队：O(1))</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈进阶入队o1出队摊还复杂度-o1"><span class="toc-number">64.2.</span> <span class="toc-text"> 栈（进阶：入队：O(1)，出队：摊还复杂度 O(1)）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#239-滑动窗口最大值"><span class="toc-number">65.</span> <span class="toc-text"> 239. 滑动窗口最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单调队列"><span class="toc-number">65.1.</span> <span class="toc-text"> 单调队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#242-有效的字母异位词"><span class="toc-number">66.</span> <span class="toc-text"> 242. 有效的字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组-3"><span class="toc-number">66.1.</span> <span class="toc-text"> 数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#258-各位相加"><span class="toc-number">67.</span> <span class="toc-text"> 258. 各位相加</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟-2"><span class="toc-number">67.1.</span> <span class="toc-text"> 模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数学双o1"><span class="toc-number">67.2.</span> <span class="toc-text"> 数学（双O(1)）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#316-去除重复字母"><span class="toc-number">68.</span> <span class="toc-text"> 316. 去除重复字母</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈-4"><span class="toc-number">68.1.</span> <span class="toc-text"> 单调栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#341-扁平化嵌套列表迭代器"><span class="toc-number">69.</span> <span class="toc-text"> 341. 扁平化嵌套列表迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#深度优先搜索dfs-6"><span class="toc-number">69.1.</span> <span class="toc-text"> 深度优先搜索（DFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#349-两个数组的交集"><span class="toc-number">70.</span> <span class="toc-text"> 349. 两个数组的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hashset"><span class="toc-number">70.1.</span> <span class="toc-text"> HashSet</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#350-两个数组的交集-ii"><span class="toc-number">71.</span> <span class="toc-text"> 350. 两个数组的交集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap-3"><span class="toc-number">71.1.</span> <span class="toc-text"> HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序双指针"><span class="toc-number">71.2.</span> <span class="toc-text"> 排序+双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#383-赎金信"><span class="toc-number">72.</span> <span class="toc-text"> 383. 赎金信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组-4"><span class="toc-number">72.1.</span> <span class="toc-text"> 数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#387-字符串中的第一个唯一字符"><span class="toc-number">73.</span> <span class="toc-text"> 387. 字符串中的第一个唯一字符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedhashmap"><span class="toc-number">73.1.</span> <span class="toc-text"> LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组计数高效率"><span class="toc-number">73.2.</span> <span class="toc-text"> 数组计数（高效率）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#392-判断子序列"><span class="toc-number">74.</span> <span class="toc-text"> 392. 判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针-7"><span class="toc-number">74.1.</span> <span class="toc-text"> 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#393-utf-8-编码验证"><span class="toc-number">75.</span> <span class="toc-text"> 393. UTF-8 编码验证</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟遍历位运算"><span class="toc-number">75.1.</span> <span class="toc-text"> 模拟（遍历+位运算）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#415-字符串相加"><span class="toc-number">76.</span> <span class="toc-text"> 415. 字符串相加</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟双指针"><span class="toc-number">76.1.</span> <span class="toc-text"> 模拟+双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#455-分发饼干"><span class="toc-number">77.</span> <span class="toc-text"> 455. 分发饼干</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法-6"><span class="toc-number">77.1.</span> <span class="toc-text"> 贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#495-提莫攻击"><span class="toc-number">78.</span> <span class="toc-text"> 495. 提莫攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟-3"><span class="toc-number">78.1.</span> <span class="toc-text"> 模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#504-七进制数"><span class="toc-number">79.</span> <span class="toc-text"> 504. 七进制数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数学-4"><span class="toc-number">79.1.</span> <span class="toc-text"> 数学</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#521-最长特殊序列-i"><span class="toc-number">80.</span> <span class="toc-text"> 521. 最长特殊序列 Ⅰ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#脑筋急转弯"><span class="toc-number">80.1.</span> <span class="toc-text"> 脑筋急转弯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#522-最长特殊序列-ii"><span class="toc-number">81.</span> <span class="toc-text"> 522. 最长特殊序列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力算法-3"><span class="toc-number">81.1.</span> <span class="toc-text"> 暴力算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#537-复数乘法"><span class="toc-number">82.</span> <span class="toc-text"> 537. 复数乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟-4"><span class="toc-number">82.1.</span> <span class="toc-text"> 模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#553-最优除法"><span class="toc-number">83.</span> <span class="toc-text"> 553. 最优除法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟-5"><span class="toc-number">83.1.</span> <span class="toc-text"> 模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#564-寻找最近的回文数"><span class="toc-number">84.</span> <span class="toc-text"> 564. 寻找最近的回文数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟-6"><span class="toc-number">84.1.</span> <span class="toc-text"> 模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#566-重塑矩阵"><span class="toc-number">85.</span> <span class="toc-text"> 566. 重塑矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组-5"><span class="toc-number">85.1.</span> <span class="toc-text"> 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二维数组的一维表示-2"><span class="toc-number">85.2.</span> <span class="toc-text"> 二维数组的一维表示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#589-n-叉树的前序遍历"><span class="toc-number">86.</span> <span class="toc-text"> 589. N 叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#深度优先搜索bfs"><span class="toc-number">86.1.</span> <span class="toc-text"> 深度优先搜索（BFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#590-n-叉树的后序遍历"><span class="toc-number">87.</span> <span class="toc-text"> 590. N 叉树的后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#深度优先搜索bfs-2"><span class="toc-number">87.1.</span> <span class="toc-text"> 深度优先搜索（BFS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#599-两个列表的最小索引总和"><span class="toc-number">88.</span> <span class="toc-text"> 599. 两个列表的最小索引总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟哈希表"><span class="toc-number">88.1.</span> <span class="toc-text"> 模拟+哈希表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#605-种花问题"><span class="toc-number">89.</span> <span class="toc-text"> 605. 种花问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针-8"><span class="toc-number">89.1.</span> <span class="toc-text"> 双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法-7"><span class="toc-number">89.2.</span> <span class="toc-text"> 贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#653-两数之和-iv-输入-bst"><span class="toc-number">90.</span> <span class="toc-text"> 653. 两数之和 IV - 输入 BST</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#树的搜索哈希表"><span class="toc-number">90.1.</span> <span class="toc-text"> 树的搜索+哈希表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#670-最大交换"><span class="toc-number">91.</span> <span class="toc-text"> 670. 最大交换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针-9"><span class="toc-number">91.1.</span> <span class="toc-text"> 双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#704-二分查找"><span class="toc-number">92.</span> <span class="toc-text"> 704. 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找-2"><span class="toc-number">92.1.</span> <span class="toc-text"> 二分查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#707-设计链表"><span class="toc-number">93.</span> <span class="toc-text"> 707. 设计链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单链表-5"><span class="toc-number">93.1.</span> <span class="toc-text"> 单链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#709-转换成小写字母"><span class="toc-number">94.</span> <span class="toc-text"> 709. 转换成小写字母</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ascii码应用"><span class="toc-number">94.1.</span> <span class="toc-text"> ASCII码应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#739-每日温度"><span class="toc-number">95.</span> <span class="toc-text"> 739. 每日温度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈-5"><span class="toc-number">95.1.</span> <span class="toc-text"> 单调栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#781-森林中的兔子"><span class="toc-number">96.</span> <span class="toc-text"> 781. 森林中的兔子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟贪心"><span class="toc-number">96.1.</span> <span class="toc-text"> 模拟+贪心</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#876-链表的中间结点"><span class="toc-number">97.</span> <span class="toc-text"> 876. 链表的中间结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单链表-6"><span class="toc-number">97.1.</span> <span class="toc-text"> 单链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#917-仅仅反转字母"><span class="toc-number">98.</span> <span class="toc-text"> 917. 仅仅反转字母</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#栈顺序表"><span class="toc-number">98.1.</span> <span class="toc-text"> 栈+顺序表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针模拟"><span class="toc-number">98.2.</span> <span class="toc-text"> 双指针+模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#932-漂亮数组"><span class="toc-number">99.</span> <span class="toc-text"> 932. 漂亮数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1081-不同字符的最小子序列"><span class="toc-number">100.</span> <span class="toc-text"> 1081. 不同字符的最小子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈-6"><span class="toc-number">100.1.</span> <span class="toc-text"> 单调栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1189-气球-的最大数量"><span class="toc-number">101.</span> <span class="toc-text"> 1189. “气球” 的最大数量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟-7"><span class="toc-number">101.1.</span> <span class="toc-text"> 模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1601-最多可达成的换楼请求数目"><span class="toc-number">102.</span> <span class="toc-text"> 1601. 最多可达成的换楼请求数目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二进制枚举"><span class="toc-number">102.1.</span> <span class="toc-text"> 二进制枚举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1705-吃苹果的最大数目"><span class="toc-number">103.</span> <span class="toc-text"> 1705. 吃苹果的最大数目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#小根堆贪心"><span class="toc-number">103.1.</span> <span class="toc-text"> 小根堆+贪心</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1706-球会落何处"><span class="toc-number">104.</span> <span class="toc-text"> 1706. 球会落何处</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟-8"><span class="toc-number">104.1.</span> <span class="toc-text"> 模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1725-可以形成最大正方形的矩形数目"><span class="toc-number">105.</span> <span class="toc-text"> 1725. 可以形成最大正方形的矩形数目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟-9"><span class="toc-number">105.1.</span> <span class="toc-text"> 模拟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1996-游戏中弱角色的数量"><span class="toc-number">106.</span> <span class="toc-text"> 1996. 游戏中弱角色的数量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#排序-2"><span class="toc-number">106.1.</span> <span class="toc-text"> 排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2000-反转单词前缀"><span class="toc-number">107.</span> <span class="toc-text"> 2000. 反转单词前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟双指针-2"><span class="toc-number">107.1.</span> <span class="toc-text"> 模拟+双指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2016-增量元素之间的最大差值"><span class="toc-number">108.</span> <span class="toc-text"> 2016. 增量元素之间的最大差值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力算法-4"><span class="toc-number">108.1.</span> <span class="toc-text"> 暴力算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法-8"><span class="toc-number">108.2.</span> <span class="toc-text"> 贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2100-适合打劫银行的日子"><span class="toc-number">109.</span> <span class="toc-text"> 2100. 适合打劫银行的日子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力算法tle-2"><span class="toc-number">109.1.</span> <span class="toc-text"> 暴力算法（TLE）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前缀和"><span class="toc-number">109.2.</span> <span class="toc-text"> 前缀和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2104-子数组范围和"><span class="toc-number">110.</span> <span class="toc-text"> 2104. 子数组范围和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力算法-5"><span class="toc-number">110.1.</span> <span class="toc-text"> 暴力算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈on"><span class="toc-number">110.2.</span> <span class="toc-text"> 单调栈（O(N)）</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220806220141.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Qing's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">LeetCode刷题记录（Java）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-11-26 08:47:03"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-11-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-10-03 16:16:11"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2023-10-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">53.9k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 217 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/11/26/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/11/26/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="leetcode刷题记录java"><a class="markdownIt-Anchor" href="#leetcode刷题记录java"></a> LeetCode刷题记录（Java）</h1>
<h1 id="1两数之和"><a class="markdownIt-Anchor" href="#1两数之和"></a> 1.两数之和</h1>
<p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode 1.两数之和</a></p>
<h2 id="暴力算法"><a class="markdownIt-Anchor" href="#暴力算法"></a> 暴力算法</h2>
<p>没啥好说明的。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> data = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data == nums[j])&#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h2>
<p>LeetCode第1题，也是我刷的第一题，当时只知道暴力求解。其实用HashMap可以得出时间复杂度为O(n)的解法。</p>
<p>遍历nums数组，在HashMap中，<code>key</code>存储<code>target-nums[i]</code>，value存储索引<code>i</code>。</p>
<p>草稿如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502145649.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i]))&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = map.get(nums[i]);</span><br><span class="line">                ans[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(target-nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-两数相加"><a class="markdownIt-Anchor" href="#2-两数相加"></a> 2. 两数相加</h1>
<p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">LeetCode 2. 两数相加</a></p>
<h2 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h2>
<p>刚开始看到这题的时候，一看到每位数字都是按照<strong>逆序</strong>的方式存储的，我就想用栈来讲这些数字拼接成原始的n位数。毕竟<strong>栈先进后出的特性</strong>，很适合用来实现一些反转效果。</p>
<blockquote>
<p>一开始我写的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将链表1和链表2压入栈</span></span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(l1);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(l2);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 多次数据类型的转换，看起来很复杂其实实现的目的很单纯</span></span><br><span class="line">        StringBuilder stringBuilder1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty())&#123;</span><br><span class="line">            stringBuilder1.append(stack1.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack2.empty())&#123;</span><br><span class="line">            stringBuilder2.append(stack2.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(stringBuilder1);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(stringBuilder2);</span><br><span class="line">        <span class="comment">// 用Long是为了防止溢出</span></span><br><span class="line">        Long num1 = Long.valueOf(s1);</span><br><span class="line">        Long num2 = Long.valueOf(s2);</span><br><span class="line">        <span class="keyword">long</span> sum = num1+num2;</span><br><span class="line">        <span class="comment">// 结果的字符串数组，注意结果链表要倒序</span></span><br><span class="line">        String[] result = Long.toString(sum).split(<span class="string">""</span>);</span><br><span class="line">        Stack&lt;ListNode&gt; resultStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : result) &#123;   <span class="comment">// 字符串已经切割了，所以这里用integer没有问题</span></span><br><span class="line">            Integer integer = Integer.valueOf(s);</span><br><span class="line">            resultStack.push(<span class="keyword">new</span> ListNode(integer));</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = resultStack.pop();</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="keyword">while</span> (!resultStack.empty())&#123;</span><br><span class="line">            pre.next = resultStack.pop();</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始我用Integer类型接受反转后的数字，提交的时候会有测试用例<strong>溢出</strong>，后来我用Long类型还是会<strong>溢出</strong>，这下我就意识到不能一起加，解决这题还是得<strong>一位一位的加</strong>。</p>
</blockquote>
<p>既然要<strong>一位一位的加</strong>，那就没有必要用到栈了，直接从最低位开始加。需要注意的点有：</p>
<ul>
<li>在每一位的加法中，<strong>注意进位</strong></li>
<li><strong>两个链表的长度可能不一样</strong>，所以在代码中的第一个while循环结束后，我新增了两个while循环</li>
<li>运算结束后，<strong>最高位可能存在进位</strong>，所以我在最后的最后添加了一个if判断</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;    <span class="comment">// 是否进位标志</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode  = <span class="keyword">new</span> ListNode();   <span class="comment">// 结果链表的头节点</span></span><br><span class="line">        ListNode pre = dummyNode;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = l1.val + l2.val;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;  <span class="comment">// 有进位</span></span><br><span class="line">                sum++;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                sum = sum%<span class="number">10</span>;</span><br><span class="line">                flag = <span class="keyword">true</span>;    <span class="comment">// 之后有进位</span></span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上一个循环结束后，如果l1和l2的长度不一样，可能还有节点没有加完</span></span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = l1.val;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;  <span class="comment">// 有进位</span></span><br><span class="line">                sum++;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                sum = sum%<span class="number">10</span>;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = l2.val;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;  <span class="comment">// 有进位</span></span><br><span class="line">                sum++;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                sum = sum%<span class="number">10</span>;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后的最后，如果最后有进位，别忘了+1</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            pre.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记录一下LeetCode提交的坑</p>
<p>在最开始，我的flag是这样定义的：<code>private static boolean flag = false;</code>，最后发现在某些测试用例下，执行代码返回结果正确，但提交解答却出错了。这里参考一下LeetCode的文章：</p>
<p><strong><a href="https://support.leetcode-cn.com/hc/kb/article/1194344/" target="_blank" rel="noopener">为什么某些测试用例下，执行代码返回结果正确，但提交解答却出错了</a></strong></p>
<p>果不其然是全局变量的问题，改为<code>private boolean flag = false;</code> 再提交就ok了！</p>
</blockquote>
<h1 id="3-无重复字符的最长子串"><a class="markdownIt-Anchor" href="#3-无重复字符的最长子串"></a> 3. 无重复字符的最长子串</h1>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">LeetCode 3. 无重复字符的最长子串</a></p>
<h2 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h2>
<p>第一次看到这题，我的第一反应使用HashSet。但是后来发现HashSet不能完全满足条件。因为我们<strong>遍历的要求是：一旦发现重复值，那么就从前一个重复元素之后的元素开始继续遍历</strong>（<code>i = hashMap.get(s.charAt(i));</code>），直到遍历到字符串结尾。</p>
<p>所以选择<strong>使用HashMap，其中key存储字符，value存储字符在字符串中的索引</strong>。逻辑很简单打下草稿就能看懂。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;  <span class="comment">// 遍历过程中各个子串的长度</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                ans = Math.max(ans, temp);</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                i = hashMap.get(s.charAt(i));</span><br><span class="line">                hashMap.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(s.charAt(i), i);</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(ans, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:71 ms,击败了13.05% 的Java用户，内存消耗:39.1 MB,击败了8.85% 的Java用户</code></p>
</blockquote>
<h2 id="对哈希表方法的优化滑动窗口"><a class="markdownIt-Anchor" href="#对哈希表方法的优化滑动窗口"></a> 对哈希表方法的优化：滑动窗口</h2>
<p>上面使用HashMap的思路是正确的，但是还可以优化一下。参考<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/" target="_blank" rel="noopener">powcai</a>大佬提供的题解。</p>
<blockquote>
<p>什么是滑动窗口？其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p>
<p>如何移动？我们<strong>只要把队列的左边的元素移出就行了</strong>，直到满足题目要求！一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p>
<p>时间复杂度：O(n)</p>
</blockquote>
<p>而这题要求的是最长子串的长度而不是内容，所以我们可以用类似双指针的思想来求出长度，其中<code>left</code>指向子串左边，遍历过程中的<code>i</code>指向子串右边，子串长度即为<code>i-left+1</code>。这样就不用再创建一个双端队列来存储子串了。</p>
<blockquote>
<ul>
<li>首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标），此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值。</li>
<li>如果当前字符 ch 包含在 map中，此时有2类情况：
<ul>
<li><strong>当前字符包含在当前有效的子段中</strong>，如：<code>abca</code>，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，那么此时更新 <code>left</code> 为 <code>map.get(a)+1</code>（即我们在上面的方法中分析的，<strong>一旦发现重复值，那么就从前一个重复元素之后的元素开始继续遍历</strong>），当前有效子段更新为 bca；</li>
<li><strong>当前字符不包含在当前最长有效子段中</strong>，如：<code>abba</code>，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b，而且b包含在最长有效子段中，我们更新 <code>left=map.get(b)+1</code>（=2），此时子段更新为 b，而且<strong>map中仍然包含a</strong>，map.get(a)=0；随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像1）一样处理，就会发现 left=map.get(a)+1=1，<strong>实际上，left此时应该不变，left始终为2，子段变成 ba才对。</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p>感觉这种处理，其实就是，免去了我们之前<code>hashMap.clear();</code>的操作而已。</p>
<p>逻辑打下草稿就很清楚了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] array = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;  <span class="comment">// 遍历过程中指向子串左边</span></span><br><span class="line">        <span class="comment">// key为字符，value为该字符在字符串中最后出现的索引（遍历过程中）</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;    <span class="comment">// 遍历过程中i指向子串右边</span></span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                <span class="comment">// 新的left值取left当前值和重复元素的索引+1这两者之中的最大值</span></span><br><span class="line">                left = Math.max(left, hashMap.get(array[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(array[i],i);    <span class="comment">// 不管是否更新left，都要更新当前遍历字符的位置！</span></span><br><span class="line">            ans = Math.max(ans, i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:4 ms,击败了87.02% 的Java用户，内存消耗:38.6 MB,击败了41.79% 的Java用户</code></p>
</blockquote>
<h1 id="5-最长回文子串"><a class="markdownIt-Anchor" href="#5-最长回文子串"></a> 5. 最长回文子串</h1>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode 5. 最长回文子串</a></p>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p>虽然还没系统地看过动态规划，但是既然刷到了就试着做一下。</p>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p>创建一个二维布尔数组dp。</p>
<p>在<strong>边界条件之内</strong>，要判断一个字符串为回文，需要其<strong>两端的字符相等</strong>且<strong>去除两端后的中间字符为回文</strong>。可得状态转移方程：<code>dp[l][r] = dp[l+1][r-1]</code>（条件：<code>s[l]==s[r]</code>）。</p>
<p>现在我们来讨论边界条件，分解出来的子问题要构成不了区间，即<code>r-1-(l+1)+1&lt;2</code>，即<code>r-l&lt;3</code>。</p>
<p>边界条件之外的三种情况：</p>
<ol>
<li><code>r-l=0</code>，长度为1，肯定是回文，<code>dp[l][r] = true</code></li>
<li><code>r-l=1</code>，长度为2，判断两端，相等即为回文</li>
<li><code>r-l=2</code>，长度为3，判断两端，相等即为回文</li>
</ol>
<p><strong>边界条件之内才可以使用状态转移方程</strong>。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502145755.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;    <span class="comment">// 记录回文子串最大长度</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;  <span class="comment">// 记录回文开始的索引</span></span><br><span class="line">        <span class="comment">// 初始化二维布尔数组dp，dp[l][r]表示s[l]到s[r]之间的字符串是否为回文字符串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;    <span class="comment">// l和r相等，字符串长度为1，当然是回文</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; length; r++) &#123;  <span class="comment">// 从r开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; l++) &#123;   <span class="comment">// l只需要到r-1即可，因为dp[i][i]已经赋值为true了</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(l)!=s.charAt(r))&#123;  <span class="comment">// 左右两端都不一样，s[l]到s[r]之间不可能是回文</span></span><br><span class="line">                    dp[l][r] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 左右两端相等的情况</span></span><br><span class="line">                    <span class="keyword">if</span> (r-l&lt;<span class="number">3</span>)&#123;     <span class="comment">// 边界情况，不需要状态转移方程，左右两端相等，直接为true</span></span><br><span class="line">                        dp[l][r] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[l][r] = dp[l+<span class="number">1</span>][r-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 只要dp[l][r]为true，即表明s[l]到s[r]之间是回文，需要记录maxLen和begin</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[l][r] &amp;&amp; r-l+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">                        maxLen = r-l+<span class="number">1</span>;</span><br><span class="line">                        begin = l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-z-字形变换"><a class="markdownIt-Anchor" href="#6-z-字形变换"></a> 6. Z 字形变换</h1>
<p><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">LeetCode 6. Z 字形变换</a></p>
<h2 id="二维矩阵模拟"><a class="markdownIt-Anchor" href="#二维矩阵模拟"></a> 二维矩阵模拟</h2>
<p><a href="https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode-solution-4n3u/" target="_blank" rel="noopener">官方题解</a></p>
<p>设 <code>length</code> 为字符串 <code>s</code> 的长度，<code>r=numRows</code>。对于特殊情况的处理：</p>
<ul>
<li>s长度为1</li>
<li>numRow为1</li>
<li><strong>numRows大于等于s的长度</strong></li>
</ul>
<p>直接返回<code>s</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特殊情况处理（注意还有numRows&gt;=length的情况）</span></span><br><span class="line"><span class="keyword">if</span> (length==<span class="number">1</span> || numRows==<span class="number">1</span> || numRows&gt;=length)&#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据题意，当我们在矩阵上填写字符时，会向下填写 <code>r</code> 个字符，然后向右上继续填写 <code>r-2</code> 个字符，最后回到第一行。因此 <strong>Z 字形变换的周期</strong>：<code>t=r+r-2=2r-2</code>。每个周期会占用矩阵上的 <code>1+r-2=r-1</code> 列。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502145822.png" alt="" /></p>
<p>因此我们有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><mi>t</mi></mfrac><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\frac{length}{t}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">[</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">]</span></span></span></span></span></span> 个周期（<strong>向上取整</strong>）（最后一个周期视作完整周期），乘上每个周期的列数，得到矩阵的列数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mrow><mo fence="true">[</mo><mfrac><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><mi>t</mi></mfrac><mo fence="true">]</mo></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c=\left[\frac{length}{t}\right] \cdot(r-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">[</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p>
<p>注意这里<strong>向上取整的代码处理</strong>：<code>int c = (length+t-1)/t * (r-1);</code></p>
<p>接下来我们就创建一个 <code>r</code> 行 <code>c</code> 列的矩阵，然后遍历字符串 <code>s</code> 并按 Z 字形填写。具体来说，设当前填写的位置为 <code>(x,y)</code>，即矩阵的 <code>x</code> 行 <code>y</code> 列。初始 <code>(x,y)=(0,0)</code>，即矩阵左上角。</p>
<p>若当前字符下标 <code>i</code> ：</p>
<ul>
<li><code>i%t &lt; r-1</code>。则向下移动</li>
<li>否则，就向上移动</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="comment">// 特殊情况处理（注意还有numRows&gt;=length的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">1</span> || numRows==<span class="number">1</span> || numRows&gt;=length)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = numRows;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">2</span>*r-<span class="number">2</span>;  <span class="comment">// 周期</span></span><br><span class="line">        <span class="keyword">int</span> c = (length+t-<span class="number">1</span>)/t *(r-<span class="number">1</span>);  <span class="comment">// length/t的结果向上取整</span></span><br><span class="line">        <span class="keyword">char</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">char</span>[r][c]; <span class="comment">// 创建矩阵</span></span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;length)&#123;</span><br><span class="line">            matrix[x][y] = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (i%t &lt; r-<span class="number">1</span>)&#123; <span class="comment">// 向下移动</span></span><br><span class="line">                x++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 想右上方移动</span></span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aChar != <span class="number">0</span>)&#123;    <span class="comment">// 注意这里是不等于0!!!</span></span><br><span class="line">                    ans.append(aChar);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：<code>O(r*n)</code>。其中 <code>r*=*numRows</code>，<code>n</code> 为字符串 <code>s</code> 的长度。</li>
<li>空间复杂度：<code>O(r*n)</code>。矩阵需要<code>O(r*n)</code>的空间。</li>
</ul>
</blockquote>
<h1 id="7-整数反转"><a class="markdownIt-Anchor" href="#7-整数反转"></a> 7. 整数反转</h1>
<p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">LeetCode 7. 整数反转</a></p>
<h2 id="数学"><a class="markdownIt-Anchor" href="#数学"></a> 数学</h2>
<blockquote>
<p>一开始我写的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span> &amp;&amp; x &gt; -<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = String.valueOf(x);</span><br><span class="line">        <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 双指针实现反转，已经很熟悉了</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = arr.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">char</span> temp = arr[l];</span><br><span class="line">                arr[l] = arr[r];</span><br><span class="line">                arr[r] = temp;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// x为负数</span></span><br><span class="line">            <span class="comment">// 双指针实现反转，已经很熟悉了</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = arr.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">char</span> temp = arr[l];</span><br><span class="line">                arr[l] = arr[r];</span><br><span class="line">                arr[r] = temp;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;    <span class="comment">// 还没有处理前置位为0的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'0'</span> &amp;&amp; flag)&#123;    <span class="comment">// 处理前置位为0的情况</span></span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(ans.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在跑测试用例：9646324351时，会报错<code>9646324351 is not a valid value of type integer</code></p>
<p>所以还是不可以简单的先转字符串反转再转int。</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">官方题解</a></p>
<p>记 <code>rev</code> 为翻转后的数字，为完成翻转，我们可以重复<strong>弹出</strong>  <code>x</code> 的末尾数字，将其<strong>推入</strong> <code>rev</code> 的末尾，直至 <code>x</code> 为 0。</p>
<p>要在<strong>没有辅助栈或数组的帮助下弹出和推入数字</strong>，我们可以使用如下<strong>数学方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出 x 的末尾数字 digit</span></span><br><span class="line">digit = x % <span class="number">10</span></span><br><span class="line">x = x/<span class="number">10</span></span><br><span class="line"><span class="comment">// 将数字 digit 推入 rev 末尾</span></span><br><span class="line">rev = rev * <span class="number">10</span> + digit</span><br></pre></td></tr></table></figure>
<p>草稿如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502145856.png" alt="" /></p>
<p>（该方法对负数同样有效。在Java中：<code>-7%10=-7</code>；<code>-7/10=0</code>；<code>-12%10=-2</code>；<code>-12/10=-1</code>）</p>
<p>确定了通过数学处理来实现反转之后，接下来只需要<strong>注意溢出</strong>即可。</p>
<p>根据题目要求，我们需要在<code>推入</code>数字之前，判断是否满足：$$<br />
-2^{31} \leq \text { rev } \cdot 10+\text { digit } \leq 2^{31}-1</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">，</mi><mi mathvariant="normal">若</mi><mi mathvariant="normal">该</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">立</mi><mi mathvariant="normal">则</mi><mi mathvariant="normal">返</mi><mi mathvariant="normal">回</mi><mn>0</mn><mi mathvariant="normal">。</mi><mi mathvariant="normal">但</mi><mi mathvariant="normal">是</mi><mo>∗</mo><mo>∗</mo><mi mathvariant="normal">题</mi><mi mathvariant="normal">目</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">求</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">允</mi><mi mathvariant="normal">许</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mn>64</mn><mi mathvariant="normal">位</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">数</mi><mo>∗</mo><mo>∗</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">即</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">程</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">必</mi><mi mathvariant="normal">须</mi><mi mathvariant="normal">在</mi><mn>32</mn><mi mathvariant="normal">位</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">号</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">范</mi><mi mathvariant="normal">围</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">因</mi><mi mathvariant="normal">此</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">按</mi><mi mathvariant="normal">照</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">述</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">计</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">处</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">：</mi><mo>&gt;</mo><mi mathvariant="normal">判</mi><mi mathvariant="normal">断</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">式</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">，若该不等式不成立则返回 0。

但是**题目要求不允许使用 64 位整数**，即运算过程中的数字必须在 32 位有符号整数的范围内，因此我们不能直接按照上述式子计算，需要进行处理：

&gt; 判断不等式
&gt; </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">若</span><span class="mord cjk_fallback">该</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">立</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">返</span><span class="mord cjk_fallback">回</span><span class="mord">0</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">但</span><span class="mord cjk_fallback">是</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">允</span><span class="mord cjk_fallback">许</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord">6</span><span class="mord">4</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">必</span><span class="mord cjk_fallback">须</span><span class="mord cjk_fallback">在</span><span class="mord">3</span><span class="mord">2</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">范</span><span class="mord cjk_fallback">围</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">按</span><span class="mord cjk_fallback">照</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">述</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">：</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">判</span><span class="mord cjk_fallback">断</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">式</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p>
<blockquote>
<p>-2^{31} \leq \text { rev } \cdot 10+\text { digit } \leq 2^{31}-1</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">立</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">改</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">判</mi><mi mathvariant="normal">断</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">是否成立，可改为判断不等式、
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">立</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">改</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">判</span><span class="mord cjk_fallback">断</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">、</span></span></span></span></span></p>
<p>\left\lceil\frac{-2^{31}}{10}\right\rceil \leq r e v \leq\left\lfloor\frac{2^{31}-1}{10}\right\rfloor</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">详</mi><mi mathvariant="normal">细</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">学</mi><mi mathvariant="normal">推</mi><mi mathvariant="normal">论</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">考</mi><mo stretchy="false">[</mo><mi mathvariant="normal">官</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">题</mi><mi mathvariant="normal">解</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>h</mi><mi>t</mi><mi>t</mi><mi>p</mi><mi>s</mi><mo>:</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>e</mi><mi>e</mi><mi>t</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>−</mo><mi>c</mi><mi>n</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">/</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>r</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>e</mi><mo>−</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>g</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">详细数学推论可以参考[官方题解](https://leetcode-cn.com/problems/reverse-integer/)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">详</span><span class="mord cjk_fallback">细</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">学</span><span class="mord cjk_fallback">推</span><span class="mord cjk_fallback">论</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">考</span><span class="mopen">[</span><span class="mord cjk_fallback">官</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">解</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span> &amp;&amp; x &gt; -<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (rev&gt;Integer.MAX_VALUE/<span class="number">10</span> || rev&lt;Integer.MIN_VALUE/<span class="number">10</span>)&#123;  <span class="comment">// 溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digit = x % <span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">            rev = rev*<span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-回文数"><a class="markdownIt-Anchor" href="#9-回文数"></a> 9. 回文数</h1>
<p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">LeetCode 9. 回文数</a></p>
<h2 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h2>
<p>首先对特殊情况的处理：<code>x</code>为负数则一定返回<code>false</code>。</p>
<p>然后将<code>num</code>转换成<code>char数组</code>，使用双指针遍历即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>)&#123;   <span class="comment">// 特殊情况处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] arr = String.valueOf(x).toCharArray();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l]!=arr[r])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="11盛最多的水的容器"><a class="markdownIt-Anchor" href="#11盛最多的水的容器"></a> 11.盛最多的水的容器</h1>
<p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">LeetCode 11.盛最多水的容器</a></p>
<h2 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h2>
<p>说明：贪心算法的思想体现在左右边界的移动上，首先取最左边和最右边为边界。然后<strong>判断哪边的高小，哪边的边界就移动</strong>。（因为移动之后低就变小了，只有找到更大的高，才有可能找到更优的解）</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;    <span class="comment">// 最大结果</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;    <span class="comment">// 暂存体积</span></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;     <span class="comment">// 循环条件即左边界要小于右边界</span></span><br><span class="line">            temp = Math.min(height[left],height[right])*(right - left); <span class="comment">// 取较短的那一段为高，很好理解（盛水）</span></span><br><span class="line">            res = Math.max(temp,res);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里就开始体现到贪心算法而不是简单的暴力算法</span></span><br><span class="line"><span class="comment">             * 哪边低，移动哪边的边界</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (height[left]&lt;height[right])&#123;    <span class="comment">// 如果左边界的高小，则左边界的指针右移，去遍历看看有没有更优解</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 右边界高小，右边界左移一段</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法：贪心算法+双指针<br />
本题虽然用到了双指针作为辅助，但关键还是要<strong>有贪心的思想，循环每一种可能出现最优的结果</strong>（而不是简单的暴力遍历），不断保存局部最优解，等到循环结束的时候就是全局最优解，时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>本题用到的贪心思想的理解就是在循环的过程中，<strong>每次让较短的一端移动来更新res的最大值</strong>，比之前的值大就更新最大值，等到循环结束，其最终更新的值就是全局最优解。时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>此题也可以说是dp问题，都有最优子结构，主要原因是贪心是特殊的动态规划。 补充：</p>
<ul>
<li>动态规划具有两个性质：重叠子问题和最优子结构</li>
<li>贪心算法：贪心选择性质和最优子结构</li>
</ul>
<p>最优子结构性质是指问题的最优解包含其子问题的最优解时，就称该问题具有最优子结构性质，重叠子问题指的是子问题可能被多次用到， 多次计算，动态规划就是为了消除其重叠子问题而设计的。其实贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算，因此贪心算法其实是最简单的动态规划。</p>
</blockquote>
<h1 id="14-最长公共前缀"><a class="markdownIt-Anchor" href="#14-最长公共前缀"></a> 14. 最长公共前缀</h1>
<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode 14. 最长公共前缀</a></p>
<h1 id="19-删除链表的倒数第-n-个结点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第-n-个结点"></a> 19. 删除链表的倒数第 N 个结点</h1>
<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">LeetCode 19. 删除链表的倒数第 N 个结点</a></p>
<h2 id="单链表-2"><a class="markdownIt-Anchor" href="#单链表-2"></a> 单链表</h2>
<p>这题在之前数据结构笔记中的<a href="https://www.qingbo1011.top/2021/08/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#linkedlist%E7%9A%84%E5%AE%9E%E7%8E%B0">链表实现</a>部分中已经写过了，这里再说一下实现思路。</p>
<p>定义两个指针p1和p2，其中<strong>p2比p1快n个结点</strong>。这样当p2结点走到链表的最后一个时，我们要删除的倒数第n个结点即为p1指向的<strong>下一个</strong>结点，删除逻辑就很好实现了。这里要注意一个特殊情况：<strong>当n和链表长度一样时，在实现p2比p1快n个结点的循环体中会出现p2.next为null的空指针异常</strong>。这时由于n和链表长度一样，我们删除链表的第一个结点即可。代码体现在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 特殊情况：链表结点数和n相同，会在循环的最后一步中出现p2.next为null,而当链表结点数和n相同时，即删除第1个节点</span></span><br><span class="line">    <span class="keyword">if</span> (p2.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;   <span class="comment">// 删除链表中第一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    p2 = p2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502145923.png" alt="" /></p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 定义两个指针p1和p2，其中p2比p1快n个结点 */</span></span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 特殊情况：链表结点数和n相同，会在循环的最后一步中出现p2.next为null,而当链表结点数和n相同时，即删除第1个节点</span></span><br><span class="line">            <span class="keyword">if</span> (p2.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> head.next;   <span class="comment">// 删除链表中第一个结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后p2指向最后一个结点，要删除的结点即为p1的下一个结点</span></span><br><span class="line">        p1.next = p1.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="20-有效的括号"><a class="markdownIt-Anchor" href="#20-有效的括号"></a> 20. 有效的括号</h1>
<p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></p>
<h2 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h2>
<p>分析：这题是LeetCode上的简单题，我的思路是用栈来解决。用文字说明比较麻烦，直接上图吧，过程中注意一下图中逻辑要在<strong>栈的长度大于等于2</strong>的情况下。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502145956.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字符串变成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] array = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(array[<span class="number">0</span>]);   <span class="comment">// 先将第一个字符push到栈中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            stack.push(array[i]);</span><br><span class="line">            <span class="comment">// 在测试用例"()[]&#123;&#125;"中，如果不加以判断会存在栈的长度不足2的情况</span></span><br><span class="line">            <span class="keyword">if</span> (stack.size()&gt;=<span class="number">2</span>)&#123;   <span class="comment">// stack长度在大于等于2才能执行以下逻辑</span></span><br><span class="line">                Character pop = stack.pop();</span><br><span class="line">                Character peek = stack.peek();</span><br><span class="line">                <span class="comment">// 判断pop和peek(即栈的前两个元素)是不是能组成有效括号</span></span><br><span class="line">                <span class="comment">// 能组成有效括号的无非就三种情况，这里注意下pop后面的括号，peek是前面的括号即可</span></span><br><span class="line">                <span class="keyword">if</span> ( (pop==<span class="string">')'</span>&amp;&amp;peek==<span class="string">'('</span>) || (pop==<span class="string">']'</span>&amp;&amp;peek==<span class="string">'['</span>) || (pop==<span class="string">'&#125;'</span>&amp;&amp;peek==<span class="string">'&#123;'</span>) )&#123;</span><br><span class="line">                    stack.pop();    <span class="comment">// 将原本peek的也pop出栈</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123; <span class="comment">// pop和peek没有形成有效括号，记得pop要push回栈中</span></span><br><span class="line">                    stack.push(pop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty(); <span class="comment">// 栈为空，说明是有效括号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：<code>解答成功:执行耗时:2 ms,击败了56.70% 的Java用户,内存消耗:36.6 MB,击败了38.71% 的Java用户</code></p>
<blockquote>
<p>这里我自己写的代码运行时间为2ms，我看到也有人用栈来实现，但是只花了1ms。思路大概是一样的，但是对我最开始写的代码进行了许多优化（具体体现在可以提前判断不可能是有效括号，直接返回false。<strong><mark>提前返回false</mark></strong>：<strong>在迭代过程中，提前发现不符合的括号并且返回，提升算法效率</strong>）。</p>
<p><strong>判断提前返回false的重点在于右括号</strong>：当向栈中插入右括号时，一定要随时判断能否形成有效括号，若不能则直接返回false。<strong>我们在用栈来处理这个问题时，只要一出现右括号，其前一个括号必须要与之形成有效括号，否则就返回false</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'('</span>||c==<span class="string">'['</span>||c==<span class="string">'&#123;'</span>)&#123;    <span class="comment">// 是左括号，直接push</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是右括号，且栈已经是空了(插入的右括号在栈底，那么就永远不会出现有效括号与其匹配，直接return false)</span></span><br><span class="line">                <span class="keyword">if</span> (stack.empty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123; <span class="comment">// 下面的判断是对右括号但没有返回false的情况（即是右括号且栈不为空）</span></span><br><span class="line">                    Character pop = stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (c==<span class="string">')'</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (pop!=<span class="string">'('</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">']'</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (pop!=<span class="string">'['</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'&#125;'</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (pop!=<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty(); <span class="comment">// 栈为空，说明是有效括号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：<code>解答成功:执行耗时:1 ms,击败了98.94% 的Java用户,内存消耗:36.2 MB,击败了92.51% 的Java用户</code></p>
</blockquote>
<h1 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> 21. 合并两个有序链表</h1>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode 21. 合并两个有序链表</a></p>
<h2 id="双指针-2"><a class="markdownIt-Anchor" href="#双指针-2"></a> 双指针</h2>
<p>这题跟<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode 88. 合并两个有序数组</a>思路挺像的，都可以用双指针来实现。</p>
<p>思路很清晰，打个草稿就可以了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode p = dummyNode;</span><br><span class="line">        ListNode p1 = list1;</span><br><span class="line">        ListNode p2 = list2;</span><br><span class="line">        <span class="keyword">while</span> (p1!=<span class="keyword">null</span> &amp;&amp; p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val&lt;p2.val)&#123;</span><br><span class="line">                p.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上个循环结束后，可能还有链表没有走完</span></span><br><span class="line">        <span class="keyword">while</span> (p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="22-括号生成"><a class="markdownIt-Anchor" href="#22-括号生成"></a> 22. 括号生成</h1>
<p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">LeetCode 22. 括号生成</a></p>
<h2 id="回溯剪枝"><a class="markdownIt-Anchor" href="#回溯剪枝"></a> 回溯+剪枝</h2>
<p>参考<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/" target="_blank" rel="noopener">liweiwei1419</a>大佬的题解。</p>
<blockquote>
<p>这一类问题是在一棵隐式的树上求解，可以用深度优先遍历，也可以用广度优先遍历。<br />
一般用深度优先遍历。原因是：</p>
<ul>
<li>代码好写，使用递归的方法，直接借助系统栈完成状态的转移；</li>
<li>广度优先遍历得自己编写结点类和借助队列。</li>
</ul>
</blockquote>
<p>首先我们要知道，<strong>有效的括号，从左到右依次遍历下来，左括号的数量一定严格大于等于右括号</strong>，即<code>(</code>的个数一定严格大于等于<code>)</code>。</p>
<p>以n=2为例：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150112.png" alt="" /></p>
<p>根据上面的分析以及图，可以得出以下结论：</p>
<ul>
<li>当前左右括号都可以使用的时候，即左右括号剩余数量大于0，才产生分支；</li>
<li><strong>产生左分支的时候，只看当前是否还有左括号可以使用</strong>，即左括号剩余数量大于0；</li>
<li><strong>产生右分支的时候，还受到左分支的限制，左括号的数量一定严格大于等于右括号</strong>的时候，才可以产生分支；</li>
<li>在左括号和右括号剩余数量都等于0的时候结算。</li>
</ul>
<p>总之一句话：在遍历过程中，<strong>无效的括号即是出现了左括号小于右括号的情况</strong>。这就是我们要<strong>剪枝</strong>的。</p>
<p>回溯算法的代码中，为了方便理解，可以将<code>return</code>理解为<strong>回溯到上一步</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; result  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder path = <span class="keyword">new</span> StringBuilder();   <span class="comment">// 回溯过程中生成的字符串</span></span><br><span class="line">        dfs(path,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左括号使用数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 左括号使用数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 给定的n值，即左右括号数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(StringBuilder path, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右括号都用完了，到达叶子结点了，将结果添加到result中，然后回溯到上一步</span></span><br><span class="line">        <span class="keyword">if</span> (left==n&amp;&amp;right==n)&#123;</span><br><span class="line">            result.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剪枝（剪掉无效的括号，即已经使用的左括号left&lt;已经使用的右括号right）</span></span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;     <span class="comment">// 回溯到上一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 产生分支</span></span><br><span class="line">        <span class="keyword">if</span> (left&lt;n)&#123;    <span class="comment">// 产生左分支</span></span><br><span class="line">            path.append(<span class="string">"("</span>);</span><br><span class="line">            dfs(path, left+<span class="number">1</span>, right, n);    <span class="comment">// 使用了左括号，left+1</span></span><br><span class="line">            path.deleteCharAt(path.length()-<span class="number">1</span>);   <span class="comment">// 每一个dfs执行完后，即当前结点已经无路可走了，回溯到上一个结点，别忘了要删除path的最后一个括号</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right&lt;n)&#123;    <span class="comment">// 产生右分支</span></span><br><span class="line">            path.append(<span class="string">")"</span>);</span><br><span class="line">            dfs(path, left, right+<span class="number">1</span>, n);    <span class="comment">// 使用了右括号，right+1</span></span><br><span class="line">            path.deleteCharAt(path.length()-<span class="number">1</span>);   <span class="comment">// 每一个dfs执行完后，即当前结点已经无路可走了，回溯到上一个结点，别忘了要删除path的最后一个括号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一次学习回溯法的时候，代码看下来是很懵的。但是结合这个代码并且在IDE中进行debug，我有了自己的理解：</p>
<ul>
<li>递归过程中<code>dfs()</code>函数的每一次调用，都可以理解为向下生成结点</li>
<li>在生成分支的代码部分，每次<code>dfs()</code>函数执行完后，都会<strong>删除path的最后一个字符</strong>，这里就体现到<strong>回溯</strong>了，回溯到上一个结点，如果能继续产生分支的话，就继续向下生成结点；不能生成分支了，就继续向上回溯到上一个<code>dfs()</code>函数，同时删除path的最后一个字符。（这里的逻辑可以一边debug一边画剪枝树，体现到了<strong>深度优先搜索</strong>的思想）</li>
<li><code>return</code>也可以理解为<strong>回溯到上一步</strong>，因此代码中有3中情况需要回溯：
<ul>
<li>该结点所有能走的路已经全部走完了，回溯到上一个结点（具体体现在每一个<code>dfs()</code>函数执行完后，都会删除path的最后一个括号。这里回溯到上一个结点，即执行上一个<code>dfs()</code>函数，完全是通过递归实现的）</li>
<li>该结点是叶子结点，记录结果后回溯到上一个结点（具体体现在<code>add</code>之后就<code>return</code>了）</li>
<li>该结点不满足我们分析的条件（即不能保证是有效括号），需要剪枝掉该结点，然后回溯到上一个结点（具体体现在我们判断出<code>left&lt;right</code>后，直接<code>return</code>）</li>
</ul>
</li>
</ul>
<p>这是我当时一边debug一边打的草稿，很潦草但是我不想再画一次了，不懂的话可以一边debug一边再画一下，很好理解的。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150138.png" alt="" /></p>
<h1 id="30-串联所有单词的子串"><a class="markdownIt-Anchor" href="#30-串联所有单词的子串"></a> 30. 串联所有单词的子串</h1>
<p><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">LeetCode 30. 串联所有单词的子串</a></p>
<h2 id="哈希表子数组匹配"><a class="markdownIt-Anchor" href="#哈希表子数组匹配"></a> 哈希表+子数组匹配</h2>
<p><a href="https://www.bilibili.com/video/BV1nM4y1V7Wg?spm_id_from=333.1007.top_right_bar_window_history.content.click" target="_blank" rel="noopener"><strong>视频讲解</strong></a></p>
<p>首先要注意题目给出的关键信息：单词数组<code>words</code>中的各个单词<strong>长度相同</strong>。</p>
<p>这题我们<strong>通过HashMap，将字符串s转换为对应的数组</strong>，然后根据<strong>子数组匹配问题</strong>的相关算法，完成本题。</p>
<blockquote>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150201.png" alt="" /></p>
</blockquote>
<p>在转换words时，<strong>list存储各个子串出现的次数</strong>。但是我们不知道list中各个索引处的值表示的是哪个子串出现的次数，所以我们还需要使用HashMap。map的key是子串，<strong>value存储ist中的一个l索引，可以通过该索引和list查出该子串出现的次数。<strong>最后我们再将list转换成数组times。这时我们就</strong>将words数组转换成一个int数组times了</strong>，其中words数组的各个子串被映射到了times数组的各个索引。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150221.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w_len = words.length;   <span class="comment">// words数组长度（一维）</span></span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 注意map的value存储的是索引（list中的）</span></span><br><span class="line">        <span class="comment">// 将words转换为times数组</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 存储子串出现次数</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(word)) &#123; <span class="comment">// 该子串已经出现过了，那么更新list即可</span></span><br><span class="line">                Integer value_index = map.get(word);</span><br><span class="line">                list.set(value_index, list.get(value_index) + <span class="number">1</span>);  <span class="comment">// 在value_index索引处更新list</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 首先更新map，其次将新的子串出现的次数添加到list中</span></span><br><span class="line">                map.put(word, index++);</span><br><span class="line">                list.add(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// list转换为一个times数组</span></span><br><span class="line">        <span class="keyword">int</span>[] times = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            times[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串s转为为数组,并进行子数组匹配算法</span></span><br><span class="line">        <span class="keyword">int</span> size = words[<span class="number">0</span>].length();   <span class="comment">// words数组中字符串长度（二维）</span></span><br><span class="line">        List&lt;Integer&gt; out = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; keep = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+size; j &lt;= s.length(); j+=size) &#123;   <span class="comment">// 每次采样size个单词</span></span><br><span class="line">                keep.add(map.getOrDefault(s.substring(j-size,j),-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子数组匹配</span></span><br><span class="line">            <span class="comment">// 先定义两个指针</span></span><br><span class="line">            <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span>[] rest = times.clone();</span><br><span class="line">            <span class="keyword">while</span> (p2&lt; keep.size())&#123;</span><br><span class="line">                <span class="keyword">if</span> (keep.get(p2)==-<span class="number">1</span>)&#123;</span><br><span class="line">                    p2++;</span><br><span class="line">                    p1=p2;</span><br><span class="line">                    rest = times.clone();   <span class="comment">// 复原rest</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> index2 = keep.get(p2);</span><br><span class="line">                    <span class="keyword">while</span> (rest[index2]==<span class="number">0</span>)&#123;</span><br><span class="line">                        rest[keep.get(p1++)]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rest[index2]--;</span><br><span class="line">                    p2++;</span><br><span class="line">                    <span class="keyword">if</span> (p2-p1 == words.length)&#123;</span><br><span class="line">                        out.add(p1*size+i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="36-有效的数独"><a class="markdownIt-Anchor" href="#36-有效的数独"></a> 36. 有效的数独</h1>
<p><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">LeetCode 36. 有效的数独</a></p>
<h2 id="哈希表-2"><a class="markdownIt-Anchor" href="#哈希表-2"></a> 哈希表</h2>
<p>参考<a href="https://leetcode-cn.com/problems/valid-sudoku/solution/gong-shui-san-xie-yi-ti-san-jie-ha-xi-bi-ssxp/" target="_blank" rel="noopener">三叶大佬</a>题解。</p>
<p>使用 <strong>哈希表</strong> 来记录某行/某列/某个区域出现过哪些数字，来帮助我们判断是否符合有效数独的定义。这样我们去遍历<code>i</code>行<code>j</code>列即可。</p>
<p>使用哈希表比较麻烦的地方就在如何根据给定<code>i</code>和<code>j</code>来确定<code>3x3</code>区域的编号<code>id_area</code>。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150246.png" alt="" /></p>
<p>可以推导出如下关系：<code>id_area = (i/3)*3 + j/3;</code></p>
<p>因此在<code>i</code>行<code>j</code>列的遍历过程中：</p>
<ul>
<li>如果第<code>i</code>行出现重复数字，return false；</li>
<li>如果第j列出现重复数字，return false；</li>
<li>如果第<code>id_area</code>个区域出现重复数字，return false；</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, HashSet&lt;Character&gt;&gt; row = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 检测每一行是否合法</span></span><br><span class="line">        Map&lt;Integer, HashSet&lt;Character&gt;&gt; col = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 检测每一列是否合法</span></span><br><span class="line">        Map&lt;Integer, HashSet&lt;Character&gt;&gt; area = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 检测每个3x3区域是否合法</span></span><br><span class="line">        <span class="comment">// 初始化每一个需要检测区域的HashSet</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            row.put(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            col.put(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            area.put(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始遍历数独，往HashSet中存储数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j]==<span class="string">'.'</span>)&#123;  <span class="comment">// 不是数字，不用往HashSet中存储，因为规则只是1-9的数字只能出现一次</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> id_area = (i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span>;</span><br><span class="line">                <span class="comment">// 如果第i行或第j列或第id_area个3x3区域存在重复数字，即为不合法数独</span></span><br><span class="line">                <span class="keyword">if</span> (row.get(i).contains(board[i][j]) || col.get(j).contains(board[i][j]) || area.get(id_area).contains(board[i][j]) )&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                row.get(i).add(board[i][j]);</span><br><span class="line">                col.get(j).add(board[i][j]);</span><br><span class="line">                area.get(id_area).add(board[i][j]); <span class="comment">// 注意这里是id_area</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：在固定 <code>9*9</code> 的问题里，计算量不随数据变化而变化。<strong>复杂度为 O(1)</strong>。</li>
<li>空间复杂度：在固定 <code>9*9</code> 的问题里，存储空间不随数据变化而变化。<strong>复杂度为 O(1)</strong>。</li>
</ul>
</blockquote>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<p>同样是参考<a href="https://leetcode-cn.com/problems/valid-sudoku/solution/gong-shui-san-xie-yi-ti-san-jie-ha-xi-bi-ssxp/" target="_blank" rel="noopener">三叶大佬</a>题解。</p>
<p>大多数的哈希表计数问题，都能转换为使用数组解决。</p>
<p>虽然时间复杂度一样，但哈希表的更新和查询复杂度为均摊 O(1)，而定长数组的的更新和查询复杂度则是严格 O(1)。</p>
<p>因此从执行效率上来说，数组要比哈希表快上不少。</p>
<p>思路比较清晰，举个例子：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150306.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] rol = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[][] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[][] area = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (c==<span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> value = c - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span> (rol[i][value] || col[j][value] || area[(i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span>][value])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                rol[i][value] = <span class="keyword">true</span>;</span><br><span class="line">                col[j][value] = <span class="keyword">true</span>;</span><br><span class="line">                area[(i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span>][value] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="42-接雨水"><a class="markdownIt-Anchor" href="#42-接雨水"></a> 42. 接雨水</h1>
<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LeetCode 42. 接雨水</a></p>
<h2 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h2>
<p>这道题目可以用单调栈来做。<strong>单调栈就是比普通的栈多一个性质，即维护一个栈内元素单调。</strong></p>
<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/" target="_blank" rel="noopener">单调栈O(n)解决，动图预警</a></p>
<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/" target="_blank" rel="noopener">官方题解</a></p>
<p>上面大佬提供的题解已经说的非常清楚了，这里我用自己的语言理解一下。</p>
<p>注意：<strong>单调栈中存放的不是高度本身，而是其在height数组中的索引</strong>。（这种处理已经很熟悉了，在[739. 每日温度](#739. 每日温度)中也是这么处理的）</p>
<p>从左到右遍历height数组，遍历到下标 <code>i</code> 时，如果栈内至少有两个元素，记栈顶元素为 <code>top</code>，<code>top</code>的下面一个元素是 <code>left</code>，则一定有<code>height[left]&gt;=height[top]</code>（因为我们会保证其是单调栈），如果<code>height[i]&gt;height[top]</code>，则得到一个可以接雨水的区域（同时<strong>为了保证单调栈我们会将top元素push出栈</strong>），该区域的<strong>宽度</strong>是<code>i-left-1</code>，<strong>高度</strong>是<code>Math.min(height[i], height[left]) - height[top]</code>。得出高度和宽度之后，就可以计算出能接到的水了。</p>
<p><mark>这么理解</mark>：<strong>要能接到水</strong>，必须得是<strong>凹结构</strong>，即<strong>高-低-高</strong>。在我们遍历的过程中，<strong>left元素即为左边柱子</strong>，<strong>i即为右边柱子</strong>（因为<code>height[i]&gt;height[top]</code>所以能接到水），<strong>top即为中间最低的柱子</strong>。所以我们在<strong>计算宽度时与top无关的</strong>，宽度为：<code>i-left-1</code>；但是在<strong>计算高度时就与top有关</strong>了，高度为：<code>Math.min(height[i], height[left]) - height[top]</code>（这个非常好理解，因为<strong>求能接水的高度肯定是左右两边最矮的减去中间的高度</strong>）（画一下图应该就能理解了）</p>
<p>这样就好理解多了，因此，<strong>为了保证能够接到水，我们必须要保证有三个柱子（元素）</strong>，因此<strong>栈中元素至少要有两个</strong>我们才能计算能接到的水。所以在while循环下会有这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// for循环遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="comment">// while循环保证单调栈，同时计算结果</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i]&gt; height[stack.getLast()])&#123;</span><br><span class="line">            Integer top = stack.removeLast();</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;   <span class="comment">// 保证栈中至少有两个元素（高-低-高结构才能接水）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">……</span><br><span class="line">        &#125;</span><br><span class="line">        stack.addLast(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>for循环遍历结束后，栈中剩下的柱子（元素）无法再出现高-低-高的情况，所以不会再接到水，我们无需处理。</p>
<p>代码大体框架同[739. 每日温度](#739. 每日温度)中一样的：<strong>for循环开始遍历height数组</strong>，for循环下面还有一个<strong>while循环来保证栈是单调栈同时计算接到的雨水</strong>。while循环结束后即将当前遍历的内容push到栈中。</p>
<p>其他的细节上面的题解以及提供的gif已经很清晰了，这里搬运一张gif：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150325.gif" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">// 单调栈</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;     <span class="comment">// 结果</span></span><br><span class="line">        <span class="comment">// for循环遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="comment">// while循环保证单调栈，同时计算结果</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i]&gt; height[stack.getLast()])&#123;</span><br><span class="line">                Integer top = stack.removeLast();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty())&#123;   <span class="comment">// 保证栈中至少有两个元素（高-低-高结构才能接水）</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> w = i - stack.getLast() - <span class="number">1</span>;    <span class="comment">// 接水宽度</span></span><br><span class="line">                <span class="keyword">int</span> h = Math.min(height[stack.getLast()], height[i]) - height[top]; <span class="comment">// 接水高度</span></span><br><span class="line">                result = result + h*w;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>时间复杂度：O(n)</strong>。其中n是数组height的长度。<strong>从 0到 n-1的每个下标最多只会入栈和出栈各一次</strong></li>
<li>空间复杂度：O(n)。其中n是数组height的长度。空间复杂度主要取决于栈空间，栈的大小不会超过 n</li>
</ul>
</blockquote>
<h1 id="43-字符串相乘"><a class="markdownIt-Anchor" href="#43-字符串相乘"></a> 43. 字符串相乘</h1>
<p><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">LeetCode 43. 字符串相乘</a></p>
<h2 id="模拟"><a class="markdownIt-Anchor" href="#模拟"></a> 模拟</h2>
<p><a href="https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p>这里我们<strong>使用数组代替字符串来存储结果</strong>，则可以减少对字符串的操作。</p>
<blockquote>
<p>数学知识：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220713181117.png" alt="" /></p>
</blockquote>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220713181141.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况处理</span></span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = num1.length();</span><br><span class="line">        <span class="keyword">int</span> n = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] ansArr = <span class="keyword">new</span> <span class="keyword">int</span>[m + n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                ansArr[i+j+<span class="number">1</span>] = ansArr[i+j+<span class="number">1</span>]+(x*y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ansArr[i-<span class="number">1</span>] = ansArr[i-<span class="number">1</span>]+(ansArr[i]/<span class="number">10</span>);</span><br><span class="line">            ansArr[i] = ansArr[i]%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理首位为0的情况</span></span><br><span class="line">        <span class="keyword">int</span> index = ansArr[<span class="number">0</span>]==<span class="number">0</span>? <span class="number">1</span>:<span class="number">0</span>;  <span class="comment">// 使用三元表达式更加简便</span></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; m+n; i++) &#123;</span><br><span class="line">            ans.append(ansArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="45-跳跃游戏-ii"><a class="markdownIt-Anchor" href="#45-跳跃游戏-ii"></a> 45. 跳跃游戏 II</h1>
<p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">LeetCode 45. 跳跃游戏 II</a></p>
<h2 id="贪心算法-2"><a class="markdownIt-Anchor" href="#贪心算法-2"></a> 贪心算法</h2>
<p>这个的贪心思想有点绕，<a href="https://www.bilibili.com/video/BV1uT4y1J7qP" target="_blank" rel="noopener">视频讲解</a>。</p>
<p>分析：相较于<a href="#55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F">55.跳跃游戏</a>，这题是两步贪心。55.跳跃游戏只需要一步贪心——即<strong>根据当前下标i能跳到的最远下标farthest进行贪心选择</strong>。但是这题却需要两步贪心，不仅需要<strong>当前下标i能跳到的最远下标currentMax</strong>，还需要考虑，<strong>从当前下标i跳到下一个下标i2后，从i2开始能够到达的最远下标nextMax</strong>。我们<strong>需要在这两步贪心中，找到需要跳跃的下标i并更新i，同时跳跃数steps++</strong>。最后返回steps。</p>
<blockquote>
<p>我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。</p>
<p>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。<strong>下标 0 可到达的位置中</strong>，下标 1 的值是 3，<strong>从下标 1 出发可以达到更远的位置（nextMax为4）</strong>，因此第一步到达下标 1。</p>
<p>从下标 1 出发，最远可到达下标 4。<strong>下标 1 可到达的位置中</strong>，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150352.png" alt="" /></p>
<p>在具体的实现中，<strong>我们维护当前能够到达的最大下标位置，记为currentMax。我们从左到右遍历数组，到达currentMax时，更新currentMax并将跳跃数steps+1。</strong></p>
<p><strong><mark>在遍历数组时，我们不访问最后一个元素</mark></strong>，这是因为在访问最后一个元素之前，我们的currentMax一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;   <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;    <span class="comment">// 跳跃次数</span></span><br><span class="line">        <span class="keyword">int</span> currentMax = <span class="number">0</span>;     <span class="comment">// 当前下标i能到达的最远下标</span></span><br><span class="line">        <span class="keyword">int</span> nextMax = <span class="number">0</span>;        <span class="comment">// 从当前下标i跳到下一个下标i2后，从i2开始能够到达的最远下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            nextMax = Math.max(nextMax, i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i==currentMax)&#123;     <span class="comment">// 到达currentMax,即当前下标i==currentMax</span></span><br><span class="line">                currentMax = nextMax;   <span class="comment">// 进行一次跳跃，currentMax更新为nextMax</span></span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="46-全排列"><a class="markdownIt-Anchor" href="#46-全排列"></a> 46. 全排列</h1>
<p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">LeetCode 46. 全排列</a></p>
<h2 id="回溯算法"><a class="markdownIt-Anchor" href="#回溯算法"></a> 回溯算法</h2>
<p><a href="https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/" target="_blank" rel="noopener">官方题解</a></p>
<p>根据题意可得出如下草图：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150409.png" alt="" /></p>
<p>在回溯过程中，我们需要的状态变量有：</p>
<ul>
<li>递归到了第几层depth（逻辑上即为path中已有的元素个数）</li>
<li>已经选了哪些数path（过程变量）</li>
<li>布尔数组used（存储数组中元素的使用情况）</li>
</ul>
<blockquote>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150423.png" alt="" /></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();   <span class="comment">// 状态变量</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];  <span class="comment">// 状态变量（false表示没有使用，true为已使用）</span></span><br><span class="line">        dfs(nums,length,<span class="number">0</span>,used,path,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span> depth, <span class="keyword">boolean</span>[] used, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth==length)&#123;     <span class="comment">// 递归出口</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i])&#123;   <span class="comment">// 当前数已被使用</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前数未被使用</span></span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(nums, length, depth+<span class="number">1</span>, used, path, result);</span><br><span class="line">            <span class="comment">// 递归结束后别忘了回溯状态变量</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="47-全排列-ii"><a class="markdownIt-Anchor" href="#47-全排列-ii"></a> 47. 全排列 II</h1>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">LeetCode 47. 全排列 II</a></p>
<h2 id="回溯算法-2"><a class="markdownIt-Anchor" href="#回溯算法-2"></a> 回溯算法</h2>
<p>像这种nums数组中有重复元素的处理，我们选择跟[90. 子集 II](#90. 子集 II)一样，使用<code>Set</code>来处理。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();   <span class="comment">// 状态变量</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];  <span class="comment">// 状态变量（false表示没有使用，true为已使用）</span></span><br><span class="line">        dfs(nums,length,<span class="number">0</span>,used,path,result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span> depth, <span class="keyword">boolean</span>[] used, Deque&lt;Integer&gt; path, Set&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth==length)&#123;     <span class="comment">// 递归出口</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i])&#123;   <span class="comment">// 当前数已被使用</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前数未被使用</span></span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(nums, length, depth+<span class="number">1</span>, used, path, result);</span><br><span class="line">            <span class="comment">// 递归结束后别忘了回溯状态变量</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="50-powx-n"><a class="markdownIt-Anchor" href="#50-powx-n"></a> 50. Pow(x, n)</h1>
<p><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">LeetCode 50. Pow(x, n)</a></p>
<h2 id="分治算法"><a class="markdownIt-Anchor" href="#分治算法"></a> 分治算法</h2>
<p>在看分治法之前，我们先来看一下简单的暴力算法。</p>
<blockquote>
<p>最简单的暴力算法，时间复杂度为O(n)。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                ans = ans*x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; -n; i++) &#123;</span><br><span class="line">                ans = ans*(<span class="number">1</span>/x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果自然是超时了，<code>Time Limit Exceeded</code>。所以还是需要用分治法来解。</p>
</blockquote>
<p>分治法的思想就是拆分若干个子问题，然后将子问题的解结合起来得到题解。</p>
<p>这题我们的分治思想是：<strong>将Pow(x,n)分解为pow(x,n/2)这样的子问题</strong>，最后根据子问题的解求出题解（这里注意一下奇偶性的不同，合并处理不一样）。</p>
<p>以求<code>2^10</code>为例：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150441.png" alt="" /></p>
<p>使用分治法就只需要进行4次乘法而不是暴力算法的10次，<strong>时间复杂度为O(logN)</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先将n转成正数，后面返回结果时再处理n为负数的情况</span></span><br><span class="line">        <span class="comment">// 注意这里n要为long类型的，不然后面会报java.lang.StackOverflowError</span></span><br><span class="line">        <span class="keyword">double</span> ans = divideGenerate(x, Math.abs((<span class="keyword">long</span>) n));</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分治法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">divideGenerate</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;   <span class="comment">// x^1 = x</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.子问题</span></span><br><span class="line">        <span class="keyword">double</span> sub = divideGenerate(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 3.合并</span></span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sub*sub;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sub*sub*x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：<code>解答成功:执行耗时:0 ms,击败了100.00% 的Java用户，内存消耗:36.3 MB,击败了94.66% 的Java用户</code></p>
<blockquote>
<p>最开始我写的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">0</span>)&#123;   <span class="comment">// 对n为负数的处理</span></span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> divideGenerate(x, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分治法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">divideGenerate</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;   <span class="comment">// x^1 = x</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.子问题</span></span><br><span class="line">        <span class="keyword">double</span> sub = divideGenerate(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 3.合并</span></span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sub*sub;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sub*sub*x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是会报<code>java.lang.StackOverflowError</code>，原因还没分析出来。后来将代码修改成以上代码，就跑通了。</p>
</blockquote>
<h1 id="53-最大子数组和"><a class="markdownIt-Anchor" href="#53-最大子数组和"></a> 53. 最大子数组和</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">LeetCode 53. 最大子数组和</a></p>
<h2 id="贪心算法-3"><a class="markdownIt-Anchor" href="#贪心算法-3"></a> 贪心算法</h2>
<p>这题需要用贪心思想简单分析，就可以得出时间复杂度为O(n)的算法，而不是完全暴力的O(n^2)。</p>
<p>贪心思想：在遍历过程中，<strong>如果前面几个数加起来的和temp&lt;0了，那下一个数当然不愿意加上前面的和，所以就舍去前面的子数组，重新开始计算连续子数组和</strong>。</p>
<p>我们用max来存储最大值，temp来存储遍历过程中子数组的和。在遍历过程中：</p>
<ul>
<li>如果<code>temp&lt;0</code>，那么就舍去前面的数，从i开始继续向下遍历（<code>temp=nums[i]</code>）</li>
<li>如果<code>temp&gt;=0</code>，继续向下遍历即可</li>
<li>注意更新<code>max</code></li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp+nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="55跳跃游戏"><a class="markdownIt-Anchor" href="#55跳跃游戏"></a> 55.跳跃游戏</h1>
<p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">LeetCode 55.跳跃游戏</a></p>
<h2 id="贪心算法-4"><a class="markdownIt-Anchor" href="#贪心算法-4"></a> 贪心算法</h2>
<blockquote>
<p><strong>有关动态规划的问题，大多是让你求最值的</strong>，比如最长子序列，最小编辑距离，最长公共子串等等等。这就是规律，因为动态规划本身就是运筹学里的一种求最值的算法。</p>
<p>那么贪心算法作为特殊的动态规划也是一样，一般也是让你求个最值。这道题表面上不是求最值，但是可以改一改：<strong>请问通过题目中的跳跃规则，最多能跳多远</strong>？如果能够越过最后一格，返回 true，否则返回 false。</p>
<p>所以说，这道题肯定可以用动态规划求解的。但是由于它比较简单，这里直接上贪心的思路：</p>
</blockquote>
<p>这里，我们用贪心的思想，求出前<strong>n-1个数</strong>（<strong>注意是前n-1个数</strong>，因为最后一个数是多少并不重要，只要能到达最后一个数所在的下标即可。n = nums.length）。能到达的下标的最大值farthest是否&gt;=n-1（<strong>n-1即为nums最后一个数所在下标</strong>）。</p>
<p>前n-1个数在代码中体现在：<code>for (int i = 0; i &lt; n-1; i++)</code></p>
<p>分析：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150507.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> farthest = <span class="number">0</span>;   <span class="comment">// 最远距离（所在下标）</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) &#123;   <span class="comment">// 注意，这里是i&lt;n-1，因为我们要判断的是前n-1个数能到大的最远下标farthest能否到达终点(下标n-1)（特例如：[3,0,0,0]）</span></span><br><span class="line">            farthest = Math.max(farthest,i+nums[i]);    <span class="comment">// 求出能走的最远距离（所在下标）</span></span><br><span class="line">            <span class="keyword">if</span> (farthest &lt;= i)&#123;  <span class="comment">// 如果最大距离（所在下标）都小于或等于i了，说明i之前的数字无论如何也无法跳跃到i之后（中途遇到0卡住了）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> farthest&gt;=n-<span class="number">1</span>;    <span class="comment">// 若最远距离恰好是终点，即farthest=n-1，所以判断标准为farthest&gt;=n-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="56合并区间"><a class="markdownIt-Anchor" href="#56合并区间"></a> 56.合并区间</h1>
<p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">LeetCode 56.合并区间</a></p>
<h2 id="暴力算法-2"><a class="markdownIt-Anchor" href="#暴力算法-2"></a> 暴力算法</h2>
<p>分析：先将区间按照指定规则排序。<strong>排序规则</strong>为：<strong>先按照start升序排序，若start一样，则按照end进行升序排序</strong>。排序结束后就开始遍历ArrayList了，首先要明确<strong>区间合并条件</strong>：若<code>start(i)&lt;=start(i+1)&lt;=end(i)</code>，那么就<strong>合并第i个和第i+1个区间</strong>为新的区间<code>[start(i),Math.max(end(i),end(i+1))]</code>。（<strong>注意end值要取两个中的最大值</strong>）（这个合并逻辑画一下图就能搞清楚了）</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;   <span class="comment">// 一共n个区间</span></span><br><span class="line">        ArrayList&lt;<span class="keyword">int</span>[]&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(n); <span class="comment">// 定义ArrayList存储一维数组(区间)</span></span><br><span class="line">        <span class="comment">// 排序二维数组</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="comment">// 定义排序规则</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>]==o2[<span class="number">0</span>])&#123;  <span class="comment">//  start相同，按end升序排序</span></span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将排序后的intervals全部存入到ArrayList中</span></span><br><span class="line">        Collections.addAll(arrayList, intervals);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size()-<span class="number">1</span>; i++) &#123;  <span class="comment">// 注意</span></span><br><span class="line">            <span class="comment">// 合并区间条件</span></span><br><span class="line">            <span class="keyword">if</span> (arrayList.get(i)[<span class="number">0</span>]&lt;=arrayList.get(i+<span class="number">1</span>)[<span class="number">0</span>]&amp;&amp;</span><br><span class="line">                    arrayList.get(i+<span class="number">1</span>)[<span class="number">0</span>]&lt;=arrayList.get(i)[<span class="number">1</span>])&#123;</span><br><span class="line">                arrayList.set(i, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;arrayList.get(i)[<span class="number">0</span>], Math.max(arrayList.get(i)[<span class="number">1</span>],arrayList.get(i+<span class="number">1</span>)[<span class="number">1</span>])&#125;);</span><br><span class="line">                arrayList.remove(i+<span class="number">1</span>);</span><br><span class="line">                i--;    <span class="comment">// 合并后要用合并的区间继续跟其他区间比较</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[arrayList.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：上述代码中我们对二维数组进行了排序，这里给出参考资料：<a href="https://blog.csdn.net/qq_41682302/article/details/95949646" target="_blank" rel="noopener">Java Arrays.sort方法重写及二维数组排序</a>，<a href="http://note.youdao.com/noteshare?id=3e481c1a044b05d197adeb453089626a&amp;sub=5E3424BDB4BB48CAB7AAC6F2D3DBFC1D" target="_blank" rel="noopener">Java Collections工具类（Comparable和Comparator）</a>。</p>
<p>其中排序那段代码还可以用Lambda表达式替换，直接Alt+Enter即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义排序规则，排序二维数组</span></span><br><span class="line"><span class="comment">// 使用Lambda表达式</span></span><br><span class="line">Arrays.sort(intervals, (o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (o1[<span class="number">0</span>]==o2[<span class="number">0</span>])&#123;  <span class="comment">//  start相同，按end升序排序</span></span><br><span class="line">        <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>毕竟是暴力算法，用时太长了。运行结果为：<code>解答成功:执行耗时:14 ms,击败了6.59% 的Java用户，内存消耗:40.4 MB,击败了97.17% 的Java用户</code>。（本来想用贪心做的，莫名其妙卡进暴力了，难受＞﹏＜）</p>
<blockquote>
<p>优化前我新建了区间类继承Comparable接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;   <span class="comment">// 一共n个区间</span></span><br><span class="line">        ArrayList&lt;Interval&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            arrayList.add(<span class="keyword">new</span> Interval(interval[<span class="number">0</span>], interval[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        arrayList.sort(Interval::compareTo);    <span class="comment">// 按照我们规定的规则将区间排序</span></span><br><span class="line">        <span class="comment">/* 执行合并区间 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 合并条件</span></span><br><span class="line">            <span class="keyword">if</span> (arrayList.get(i).start&lt;=arrayList.get(i+<span class="number">1</span>).start&amp;&amp;</span><br><span class="line">                    arrayList.get(i+<span class="number">1</span>).start &lt;= arrayList.get(i).end)&#123;</span><br><span class="line">                <span class="comment">// 注意这里end的新值要取两个中的最大值（从合并区间的条件中可以看出）</span></span><br><span class="line">                arrayList.set(i,<span class="keyword">new</span> Interval(arrayList.get(i).start,Math.max(arrayList.get(i).end,arrayList.get(i+<span class="number">1</span>).end)));</span><br><span class="line">                arrayList.remove(i+<span class="number">1</span>);</span><br><span class="line">                i--;    <span class="comment">// 合并后要用合并的区间继续跟其他区间比较</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* arrayList转为二维数组 */</span></span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[arrayList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">            result[i][<span class="number">0</span>] = arrayList.get(i).start;</span><br><span class="line">            result[i][<span class="number">1</span>] = arrayList.get(i).end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义区间类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Interval</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 排序规则：先按照start升序排序，若start一样，按照end升序排序</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Interval o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.start==o.start)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.end - o.end;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.start - o.start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：<code>解答成功:执行耗时:14 ms,击败了6.59% 的Java用户，内存消耗:40.5 MB,击败了95.83% 的Java用户</code></p>
</blockquote>
<h2 id="贪心算法stack"><a class="markdownIt-Anchor" href="#贪心算法stack"></a> 贪心算法+Stack</h2>
<p>该算法题解参考<a href="https://leetcode-cn.com/problems/merge-intervals/solution/tan-xin-suan-fa-java-by-liweiwei1419-3/" target="_blank" rel="noopener">liweiwei1419</a>大佬的贪心题解，这里仅做搬运。</p>
<p>分析：相较于相面的暴力算法，贪心算法<strong>只需要我们对start进行升序排序</strong>。通过画图我们可以发现，合并条件为：<strong>只要有交集的区间就可以合并</strong>。在对start进行升序排序后，遍历区间数组（二维数组**，从第二个区间开始跟前一个区间进行对比**），贪心思想如下：</p>
<ul>
<li>如果<strong>遍历的区间的start&gt;结果集中最后一个区间end</strong>，说明两个区间没有交集无法合并，直接将遍历的区间push到结果集中</li>
<li>如果<strong>遍历的区间的start&lt;=结果集中最后一个区间end</strong>，说明两个区间有交集可以合并，这时我们的处理为：<strong>修改结果集中的最后一个区间的end</strong>，<strong>新的end值</strong>取<strong>遍历的区间end和结果集中最后一个区间end值的<mark>最大值</mark></strong>（注意这里要去两个中的最大值，画一下图就能理解了）。（start不变因为我们已经对初始区间数组按照start生序排序了）</li>
</ul>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150537.png" alt="" /></p>
<p>贪心思想明确了，代码就很明确了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">// 结果集我们选择使用Stack，因为只需要对结果集的最后一个元素进行操作(也可以用ArrayList)</span></span><br><span class="line">        Stack&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 区间集合按照start生序排序（这里用了Lambda表达式）</span></span><br><span class="line">        Arrays.sort(intervals, (o1, o2) -&gt; o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">        result.push(intervals[<span class="number">0</span>]);  <span class="comment">// 将排序后的第一个区间先push到结果集中</span></span><br><span class="line">        <span class="comment">// 根据贪心思想进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>]&gt;result.peek()[<span class="number">1</span>])&#123;  <span class="comment">// 遍历的区间的start&gt;结果集中最后一个区间end</span></span><br><span class="line">                <span class="comment">/* 两个区间没有交集无法合并，直接将该区间push到结果集中 */</span></span><br><span class="line">                result.push(intervals[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 遍历的区间的start&lt;=结果集中最后一个区间end,根据我们的分析合并区间</span></span><br><span class="line">                <span class="keyword">int</span> newEnd = Math.max(intervals[i][<span class="number">1</span>],result.peek()[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span>[] interval = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;result.peek()[<span class="number">0</span>],newEnd&#125;;    <span class="comment">// 更新后的区间</span></span><br><span class="line">                <span class="comment">// 更新result，先pop旧的区间，再push新的区间</span></span><br><span class="line">                result.pop();</span><br><span class="line">                result.push(interval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[result.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：<code>解答成功:执行耗时:8 ms,击败了25.72% 的Java用户，内存消耗:40.7 MB,击败了87.91% 的Java用户</code>。（其实还可以再优化一下，在下面给出了大佬题解的原代码）</p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(NlogN)，这里 N 是区间的长度</li>
<li>空间复杂度：O(N)，保存结果集需要的空间，这里计算的是最坏情况，也就是所有的区间都没有交点的时候</li>
</ul>
<p>说明：<code>Arrays.sort(intervals, (o1, o2) -&gt; o1[0]-o2[0]);</code> 是 Java8 以后提供的一种函数式编程语法。等同于如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这题在多次提交后的runtime误差好大，而且相同的代码提交之后误差也好大。<a href="https://blog.csdn.net/vcx08/article/details/88530049" target="_blank" rel="noopener">LeetCode 的 Runtime 指标是否可信？</a>这篇博客中给出了以下总结：</p>
<ul>
<li>这是玄学</li>
<li>英文版的服务器比中文版的服务器好</li>
<li>尽量挑没人做题的时候提交</li>
<li>以后除非有更好的思路和方法，再也不做优化！</li>
</ul>
<blockquote>
<p>以上代码是我根据大佬题解思路自己敲的。</p>
<p>这里给出大佬题解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = intervals.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按照起点排序</span></span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 也可以使用 Stack，因为我们只关心结果集的最后一个区间</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curInterval = intervals[i];</span><br><span class="line">            <span class="comment">// 每次新遍历到的列表与当前结果集中的最后一个区间的末尾端点进行比较</span></span><br><span class="line">            <span class="keyword">int</span>[] peek = res.get(res.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (curInterval[<span class="number">0</span>] &gt; peek[<span class="number">1</span>]) &#123;</span><br><span class="line">                res.add(curInterval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意，这里应该取最大</span></span><br><span class="line">                peek[<span class="number">1</span>] = Math.max(curInterval[<span class="number">1</span>], peek[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：<code>解答成功:执行耗时:7 ms,击败了48.71% 的Java用户，内存消耗:40.8 MB,击败了80.93% 的Java用户</code></p>
</blockquote>
<h2 id="队列接近双百"><a class="markdownIt-Anchor" href="#队列接近双百"></a> 队列（接近双百）</h2>
<p>搬运自<a href="https://leetcode-cn.com/u/thiner/" target="_blank" rel="noopener">thiner</a>大佬的题解</p>
<p>上面的暴力算法、贪心算法和官方提供的题解都要先将初始数组进行排序。而如果我们使用队列来处理，就**<mark>无需对初始的区间数组进行排序</mark>**。这样的结果就接近双百了。</p>
<p>分析：使用<strong>队列</strong>merged存储答案，在<strong>遍历intervals数组</strong>时，<strong>将merged队列中的元素<mark>逐个弹出</mark>（结果区间中弹出的区间记为resultInterval）</strong>，<strong>与当前区间currentInterval比较</strong></p>
<ul>
<li>如果有可以合并区间，则<strong>将当前currentInterval区间更新</strong>，将更新后的区间add到队列中，并继续与merged队列中的剩余元素比较，直至完成一次队列循环</li>
<li>如果不能合并区间，则将结果集中不能合并区间resultInterval，add到队列中，<strong>退出while循环后</strong>再将不能和合并的currentInterval区间add到队列中</li>
</ul>
<p><strong>注意</strong>：由于这个算法<strong>并没有将初始区间数组进行排序</strong>，所以我们的判定是否能合并的条件和合并的规则和上面的贪心算法<strong>有所不同</strong>：</p>
<ul>
<li>判断区间是否能合并：我们取min为<code>currentInterval[0]</code>和<code>resultInterval[0]</code>的最小值，max为<code>currentInterval[1]</code>和<code>resultInterval[1]</code>的最大值。如果<code>max-min&lt;=(currentInterval[1]-currentInterval[0])+(resultInterval[1]-resultInterval[0])</code>，就说明可以合并。（画个图就能理解了）</li>
<li>合并规则：合并后的区间为<code>[min,max]</code>（画图就能理解）。在代码中我们可以这样处理：<strong>将currentInterval重置</strong>为<code>[min,max]</code>，因为在while循环后（结果队列遍历完成后），我们会将currentInterval区间add到队列中的</li>
</ul>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150600.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">/* 用标准库中的LinkedList来模拟队列 */</span></span><br><span class="line">        Deque&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        merged.add(intervals[<span class="number">0</span>]);   <span class="comment">// 先将数组中的第一个区间插入到队列尾中</span></span><br><span class="line">        <span class="comment">/* 遍历给定的区间数组 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;    <span class="comment">// 第一个已经插入到队列了，i可以从1开始</span></span><br><span class="line">            <span class="keyword">int</span> k = merged.size();  <span class="comment">// 每次遍历数组时队列长度都要重新获取</span></span><br><span class="line">            <span class="keyword">int</span>[] currentInterval = intervals[i];</span><br><span class="line">            <span class="comment">/* 遍历队列 */</span></span><br><span class="line">            <span class="keyword">while</span> (k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] resultInterval = merged.poll();</span><br><span class="line">                <span class="keyword">int</span> min = Math.min(currentInterval[<span class="number">0</span>],resultInterval[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> max = Math.max(currentInterval[<span class="number">1</span>],resultInterval[<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 合并条件</span></span><br><span class="line">                <span class="keyword">if</span> (max-min&lt;=(currentInterval[<span class="number">1</span>]-currentInterval[<span class="number">0</span>])+(resultInterval[<span class="number">1</span>]-resultInterval[<span class="number">0</span>]))&#123;</span><br><span class="line">                    currentInterval[<span class="number">0</span>] = min;</span><br><span class="line">                    currentInterval[<span class="number">1</span>] = max;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    merged.add(resultInterval); <span class="comment">// 不能遍历，让resultIntervala回到队列中（此时add进队尾了）</span></span><br><span class="line">                &#125;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意：一定要在while循环结束后才将当前interval加入队列，否则可能导致死循环</span></span><br><span class="line">            merged.add(currentInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlog(n))，空间复杂度：O(n)。运行结果为：解<code>答成功:执行耗时:2 ms,击败了99.25% 的Java用户，内存消耗:39.9 MB,击败了99.73% 的Java用户</code></p>
<h2 id="bitset无排序2ms"><a class="markdownIt-Anchor" href="#bitset无排序2ms"></a> BitSet（无排序，2ms）</h2>
<p>该算法是在评论区中参考<a href="https://leetcode-cn.com/u/lan-bo-7/" target="_blank" rel="noopener">兰博</a>大佬的。</p>
<p><a href="https://blog.csdn.net/liuxiao723846/article/details/104993374" target="_blank" rel="noopener">java BitSet类</a></p>
<p>大佬题解代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        BitSet bitSet = <span class="keyword">new</span> BitSet();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = interval[<span class="number">1</span>] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            bitSet.set(interval[<span class="number">0</span>] * <span class="number">2</span>, temp, <span class="keyword">true</span>);</span><br><span class="line">            max = temp &gt;= max ? temp : max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; max) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = bitSet.nextSetBit(index);</span><br><span class="line">            <span class="keyword">int</span> end = bitSet.nextClearBit(start);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] item = &#123;start / <span class="number">2</span>, (end - <span class="number">1</span>) / <span class="number">2</span>&#125;;</span><br><span class="line">            intervals[count++] = item;</span><br><span class="line"></span><br><span class="line">            index = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[count][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            ret[i] = intervals[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：<code>解答成功:执行耗时:2 ms,击败了99.22% 的Java用户，内存消耗:40.9 MB,击败了57.72% 的Java用户</code></p>
<p>根据提示改进，max可以直接用<code>bitSet.length</code>。改进代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        BitSet bitSet = <span class="keyword">new</span> BitSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            bitSet.set(interval[<span class="number">0</span>] * <span class="number">2</span>, interval[<span class="number">1</span>] * <span class="number">2</span> + <span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; bitSet.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = bitSet.nextSetBit(index);</span><br><span class="line">            <span class="keyword">int</span> end = bitSet.nextClearBit(start);</span><br><span class="line">            <span class="keyword">int</span>[] item = &#123;start / <span class="number">2</span>, (end - <span class="number">1</span>) / <span class="number">2</span>&#125;;</span><br><span class="line">            intervals[count++] = item;</span><br><span class="line">            index = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[count][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            ret[i] = intervals[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>位图法我还不是特别熟。大佬的这个题解我大概看明白了，但是让我自己写一个这样的还真不太行…</p>
<h1 id="67-二进制求和"><a class="markdownIt-Anchor" href="#67-二进制求和"></a> 67. 二进制求和</h1>
<p><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">LeetCode 67. 二进制求和</a></p>
<h2 id="模拟栈"><a class="markdownIt-Anchor" href="#模拟栈"></a> 模拟+栈</h2>
<p>在写完[43. 字符串相乘](#43. 字符串相乘)之后，对于将结果存储在数组中的一些思想就很容易想到了。很容易得出结论：两个二进制相加，结果的长度最多为其中最长二进制长度+1。由此我们可以确定最终结果数组的长度。</p>
<p>草稿如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150742.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length_a = a.length();</span><br><span class="line">        <span class="keyword">int</span> length_b = b.length();</span><br><span class="line">        <span class="keyword">int</span> length = Math.max(length_a, length_b) + <span class="number">1</span>;  <span class="comment">// 最终结果最大长度</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack_a = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack_b = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">// 存储最终结果的栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length_a; i++) &#123;</span><br><span class="line">            stack_a.addLast(a.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length_b; i++) &#123;</span><br><span class="line">            stack_b.addLast(b.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack_a.isEmpty() || !stack_b.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 竖式加法，空位补0</span></span><br><span class="line">            <span class="keyword">int</span> numa = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> numb = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!stack_a.isEmpty())&#123;</span><br><span class="line">                numa = stack_a.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack_b.isEmpty())&#123;</span><br><span class="line">                numb = stack_b.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(numa+numb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将stack中的数存储到数组中，方便进位处理</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i] = stack.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进位处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                arr[i] = arr[i]%<span class="number">2</span>;</span><br><span class="line">                arr[i+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对结果首位是否为0的处理</span></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (arr[length-<span class="number">1</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            ans.append(arr[length-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="69-x-的平方根"><a class="markdownIt-Anchor" href="#69-x-的平方根"></a> 69. x 的平方根</h1>
<p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">LeetCode 69. x 的平方根</a></p>
<h2 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h2>
<p>参考<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">liweiwei1419</a>大佬题解</p>
<p>从题目的要求和示例我们可以看出，这其实是一个查找整数的问题，并且这个整数是有范围的。根据二分查找的思想：</p>
<ul>
<li>如果这个整数的平方 <strong>恰好等于</strong> 输入整数<code>x</code>，那么我们就找到了这个整数；</li>
<li>如果这个整数的平方 <strong>严格大于</strong> 输入整数<code>x</code>，那么这个整数肯定不是我们要找的那个数；</li>
<li>如果这个整数的平方 <strong>严格小于</strong> 输入整数<code>x</code>，那么这个整数 <strong><mark>可能</mark></strong> 是我们要找的那个数（举个例子，<code>2*2=4&lt;8</code>，但是8开根号的整数部分正好是2）。</li>
</ul>
<p>二分查找的关键，是弄清楚<strong>mid的取值</strong>和<strong>搜索区间的更新</strong>。一开始我也是经常弄混导致死循环或结果比正确结果多1，最后参考大佬题解后成功AC。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊值判断</span></span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">0</span> || x==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x/<span class="number">2</span>;    <span class="comment">// right取x/2即可</span></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid&gt;x/mid)&#123;     <span class="comment">// 用除法防止乘法溢出</span></span><br><span class="line">                right = mid-<span class="number">1</span>;  <span class="comment">// mid肯定不是，更新搜索区间为[left,mid-1]</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;     <span class="comment">// mid可能是，更新搜索区间为[mid,right]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(logx)。每一次搜索的区间大小约为原来的<code>1/2</code>，时间复杂度为 O(log2x)=O(logx)</li>
<li>空间复杂度：O(1)。</li>
</ul>
</blockquote>
<h1 id="71-简化路径"><a class="markdownIt-Anchor" href="#71-简化路径"></a> 71. 简化路径</h1>
<p><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">LeetCode 71. 简化路径</a></p>
<h2 id="模拟栈-2"><a class="markdownIt-Anchor" href="#模拟栈-2"></a> 模拟+栈</h2>
<p>来自宫水三叶大佬的题解：<a href="https://leetcode-cn.com/problems/simplify-path/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-w7xi/" target="_blank" rel="noopener">【宫水三叶】简单字符串模拟题</a></p>
<p>根据题意，使用栈进行模拟即可。</p>
<p>具体的，从前往后处理 path，每次以 <code>item</code> 为单位进行处理（有效的文件名），根据 item 为何值进行分情况讨论：</p>
<ul>
<li><code>item</code> 为有效值 ：存入栈中；</li>
<li><code>item</code> 为 <code>..</code> ：弹出栈顶元素（若存在）；</li>
<li><code>item</code> 为 <code>.</code> ：不作处理。</li>
</ul>
<p>举个例子：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150806.png" alt="" /></p>
<p>至于如何识别有效文件名，只需要用到<strong>双指针</strong>即可：</p>
<ul>
<li>指针<code>i</code>在遇到<code>/</code>后，继续向右移动一个单位（<code>i++</code>）</li>
<li>指针<code>i</code>在遇到非<code>/</code>后，此时指针<code>j</code>移动到<code>i</code>的下一位（<code>j=i+1</code>）</li>
<li>此时判断指针<code>j</code>是否遇到<code>/</code>，若遇到了，此时有效文件名<code>item</code>即为<code>path.substring(i, j)</code>；若没有遇到<code>/</code>，指针j继续向右移动（<code>j++</code>）直到遇到为止。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = path.length();</span><br><span class="line">        ArrayDeque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这个遍历一是想栈中存储有效的文件名item；而是遇到..后pop出栈顶元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ) &#123; <span class="comment">// path是一个有效的 Unix 风格绝对路径,i=0一定指向/。所以i=1开始</span></span><br><span class="line">            <span class="keyword">if</span> (path.charAt(i)==<span class="string">'/'</span>)&#123;   <span class="comment">// 指针i在遇到/后，继续向右移动一个单位（i++）</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;    <span class="comment">// 指针i在遇到非/后，此时指针j移动到i的下一位（j=i+1）</span></span><br><span class="line">            <span class="keyword">while</span> (j&lt;length &amp;&amp; path.charAt(j)!=<span class="string">'/'</span>)&#123;    <span class="comment">// 若没有遇到/，指针j继续向右移动（j++）直到遇到为止</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若j遇到/了，此时有效文件名item即为path.substring(i, j)</span></span><br><span class="line">            String item = path.substring(i, j);</span><br><span class="line">            <span class="keyword">if</span> (item.equals(<span class="string">".."</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty())&#123; <span class="comment">// 要执行removeLast()操作，肯定要保证stack不为空</span></span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!item.equals(<span class="string">"."</span>))&#123;   <span class="comment">// 这里的!item.equals(".")就比较灵性了，因为如果是“.”的话我们应该什么也不做</span></span><br><span class="line">                stack.addLast(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后，i指针指向j指针的下一个位置</span></span><br><span class="line">            i = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终的栈确定下来后，简化后的路径就很好确定了</span></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            ans.append(<span class="string">"/"</span>);</span><br><span class="line">            ans.append(stack.removeFirst());    <span class="comment">// 注意这里是removeFirst！打下草稿就清楚了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.length()==<span class="number">0</span>? <span class="string">"/"</span>: ans.toString();    <span class="comment">// 如果最后栈为空的话，ans应该是/而不是空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</blockquote>
<h1 id="73-矩阵置零"><a class="markdownIt-Anchor" href="#73-矩阵置零"></a> 73. 矩阵置零</h1>
<p><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">LeetCode 73. 矩阵置零</a></p>
<h2 id="二维数组的一维表示"><a class="markdownIt-Anchor" href="#二维数组的一维表示"></a> 二维数组的一维表示</h2>
<p>跟以前做过的一样，对于一个行数为 m，<strong>列数为 n</strong>，行列下标都从 0 开始编号的二维数组，我们可以通过下面的方式，将其中的每个元素 <code>(i, j)</code> 映射到整数域内，并且它们按照<strong>行优先</strong>的顺序一一对应着 <code>[0, m*n)</code>中的每一个整数。形象化地来说，我们把这个二维数组<strong>排扁</strong>成了一个一维数组。</p>
<p>这样的映射即为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>→</mo><mi>i</mi><mo>×</mo><mi>n</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">(i, j) \rightarrow i \times n+j
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span></p>
<p>同样地，我们可以将<strong>整数 x 映射回其在矩阵中的下标</strong>，即：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>=</mo><mi>x</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>j</mi><mo>=</mo><mi>x</mi><mi mathvariant="normal">%</mi><mi>n</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{array}{l}
i=x / n \\
j=x \% n
\end{array}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault">n</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mord">%</span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这个搞清楚了，这题就很好解了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;  m * n; x++) &#123; <span class="comment">// 记录为0的位置</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[x/n][x%n]==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer x : list) &#123;   <span class="comment">// 当前行和列需要全置0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123;   <span class="comment">// 当前行置0</span></span><br><span class="line">                matrix[x/n][c] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) &#123;   <span class="comment">// 当前列置0</span></span><br><span class="line">                matrix[r][x%n] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>执行耗时:1 ms,击败了69.31% 的Java用户，内存消耗:42.9 MB,击败了22.99% 的Java用户</code></p>
</blockquote>
<h2 id="数组-2"><a class="markdownIt-Anchor" href="#数组-2"></a> 数组</h2>
<p>这题就直接嵌套两层for循环，无需什么二维数组的一维化，效率还更高些。</p>
<p>主要思路就是：</p>
<ul>
<li>只要第<code>i</code>行有0，那么整个第<code>i</code>行都要为0</li>
<li>只要第<code>j</code>列有0，那么整个第<code>j</code>列都要为0</li>
</ul>
<p>结合代码画个草图就能搞懂了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[] row = <span class="keyword">new</span> <span class="keyword">boolean</span>[m]; <span class="comment">// 第i行是否有0</span></span><br><span class="line">        <span class="keyword">boolean</span>[] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">// 第j列是否有0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]==<span class="number">0</span>)&#123;   <span class="comment">// 第i行，j列有0</span></span><br><span class="line">                    row[i] = <span class="keyword">true</span>;</span><br><span class="line">                    col[j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j])&#123;  <span class="comment">// 注意这里是或</span></span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:0 ms,击败了100.00% 的Java用户，内存消耗:42.8 MB,击败了26.63% 的Java用户</code></p>
</blockquote>
<h1 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集"></a> 78. 子集</h1>
<p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">LeetCode 78. 子集</a></p>
<h2 id="回溯算法-3"><a class="markdownIt-Anchor" href="#回溯算法-3"></a> 回溯算法</h2>
<p><a href="https://www.bilibili.com/video/BV147411A7Yq?p=2" target="_blank" rel="noopener">liweiwei大佬视频题解</a>。</p>
<blockquote>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150832.png" alt="" /></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 最终结果</span></span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="comment">// 对数组长度的特殊判断</span></span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 记录回溯过程中的结果</span></span><br><span class="line">        dfs(nums,length,<span class="number">0</span>,path,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 题目所给数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 题目所给数组长度，因为不想在dfs函数中每次都去读取nums.length，所以直接将其作为参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前遍历到nums数组的索引（当index==length，不能再向下遍历了）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 记录回溯过程中的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 最终返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span> index, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index&gt;length-<span class="number">1</span>)&#123; <span class="comment">// 不能再向下遍历了，记录结果</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在结点的分支中，我们要考虑的是是否要选择当前这个数</span></span><br><span class="line">        <span class="comment">// 1.不选择，直接到下一个结点</span></span><br><span class="line">        dfs(nums,length,index+<span class="number">1</span>,path,result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.选择，将当前这个数添加到path中，然后继续向下一个结点</span></span><br><span class="line">        path.add(nums[index]);</span><br><span class="line">        dfs(nums,length,index+<span class="number">1</span>,path,result);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>); <span class="comment">// 别忘了状态变量的还原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>result.add(new ArrayList&lt;&gt;(path));</code>中，如果只是写成<code>result.add(path);</code>，最后得到的结果全为空<code>[]</code>。</p>
</blockquote>
<p>回溯法，还是要子集debug一下才能更详细的体会到。</p>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n*2^n)</li>
<li>空间复杂度：O(n*2^n)</li>
</ul>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150900.png" alt="" /></p>
</blockquote>
<h1 id="82-删除排序链表中的重复元素ii"><a class="markdownIt-Anchor" href="#82-删除排序链表中的重复元素ii"></a> 82. 删除排序链表中的重复元素II</h1>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">LeetCode 82. 删除排序链表中的重复元素 II</a></p>
<h2 id="双指针-3"><a class="markdownIt-Anchor" href="#双指针-3"></a> 双指针</h2>
<p>这题其实和<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">LeetCode 83. 删除排序链表中的重复元素</a>差不多，只是这里我们需要删除所有重复的元素。最开始，我仿照之前的双指针方法，但是像开头前几个重复元素的情况（如[1,1,1,2,3]）就还是会出问题。后来就突然想到，在链表的题目中我们常用<strong>dummyNode</strong>来作为链表的头节点，以区分于首元节点。所以我们创建一个dummyNode，其val为-101，保证它不会和链表的其他元素重复，使<code>dummyNode.next = head</code>。</p>
<p>双指针思路如下：定义两个指针p1，p2，初始都指向<code>dummyNode</code>节点。从宏观上看，遍历就是p2指针从<code>dummyNode</code>节点走到链表的最后一个节点。遍历过程中：</p>
<ul>
<li>首先判断p2节点及以后能否构成连续的3个节点：
<ul>
<li>若不能，判断<code>p2</code>和<code>p2.next</code>的值：
<ul>
<li>如果是重复元素，则p2遍历到下一个节点(<code>p2 = p2.next;</code>)，同时p1指向null    (<code>p1.next = null;</code>)。说明：因为p2已经遍历到链表的倒数第二个节点了，而p2=p2.next，说明最后两个是重复元素，直接删除即可。</li>
<li>如果不是重复元素，则p2遍历到下一个节点(<code>p2 = p2.next;</code>)，然后p1.next指向p2    (<code>p1.next = p2;</code>)，最后p1也遍历到下一个节点（<code>p1 = p1.next;</code>）。</li>
</ul>
</li>
<li>若能，则判断<code>p2</code>和<code>p2.next</code>还有<code>p2.next.next</code>这三个节点中是否有重复元素：
<ul>
<li>如果有重复元素，不需要什么额外操作，p2继续遍历到下一个节点(<code>p2 = p2.next;</code>)。</li>
<li>如果没有重复元素，则p2遍历到下一个节点(<code>p2 = p2.next;</code>)，然后p1.next指向p2    (<code>p1.next = p2;</code>)，最后p1也遍历到下一个节点（<code>p1 = p1.next;</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上面虽然说的复杂，但是逻辑一点也不复杂。简单来说就是<strong>判断p2和p2之后的两个节点这三个节点是否有重复元素</strong>，如果有，p2遍历到下一个节点；如果没有，p2遍历到下一个节点，然后p1.next指向p2，最后p1也遍历到下一个节点。这个实现逻辑打下草稿就能搞懂。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dummyNode的val设置为-101，保证dummyNode不可能跟链表中任何节点重复</span></span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">101</span>, head);</span><br><span class="line">        ListNode p1 = dummyNode;</span><br><span class="line">        ListNode p2 = dummyNode;</span><br><span class="line">        <span class="comment">// 开始遍历p2</span></span><br><span class="line">        <span class="keyword">while</span> (p2.next!=<span class="keyword">null</span>)&#123;  <span class="comment">// p2到链表终点，遍历结束</span></span><br><span class="line">            <span class="keyword">if</span> (p2.next.next==<span class="keyword">null</span>)&#123;    <span class="comment">// p2及之后无法构成3个连续的节点</span></span><br><span class="line">                <span class="keyword">if</span> (p2.val!=p2.next.val)&#123;</span><br><span class="line">                    p2 = p2.next;</span><br><span class="line">                    p1.next = p2;</span><br><span class="line">                    p1 = p1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    p2 = p2.next;</span><br><span class="line">                    p1.next = <span class="keyword">null</span>; <span class="comment">// 因为p2已经遍历到倒数第二个节点了，而p2=p2.next</span></span><br><span class="line">                                    <span class="comment">// 说明最后两个是重复元素，直接删除即可</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;      <span class="comment">//  p2及之后可以构成3个连续的节点</span></span><br><span class="line">                <span class="keyword">if</span> (p2.val!=p2.next.val &amp;&amp; p2.val!=p2.next.next.val</span><br><span class="line">                &amp;&amp; p2.next.val!=p2.next.next.val )&#123; <span class="comment">// 连续三个节点都不一样</span></span><br><span class="line">                    p2 = p2.next;</span><br><span class="line">                    p1.next = p2;</span><br><span class="line">                    p1 = p1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;      <span class="comment">// 连续三个节点存在重复</span></span><br><span class="line">                    p2 = p2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止链表从开头开始全是重复元素的情况，如[1,1,1]</span></span><br><span class="line">        <span class="keyword">if</span> (p1==dummyNode)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方题解给出的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = cur.next.val;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == x) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我认为，在链表相关的题目中要舍得用变量，如果老是想着节省变量，最后很可能被逻辑绕晕。</p>
<p>评论区中<a href="https://leetcode-cn.com/u/lixiyu/" target="_blank" rel="noopener">lixiyu</a>大佬的观点，我觉得很对：</p>
<ol>
<li>舍得用变量，千万别想着节省变量，否则容易被逻辑绕晕</li>
<li>head 有可能需要改动时，先增加一个假head（dummyNode），返回的时候直接取假dummyNode.next，<strong>这样就不需要为修改 head 增加一大堆逻辑了</strong>。</li>
</ol>
</blockquote>
<h1 id="83-删除排序链表中的重复元素"><a class="markdownIt-Anchor" href="#83-删除排序链表中的重复元素"></a> 83. 删除排序链表中的重复元素</h1>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">LeetCode 83. 删除排序链表中的重复元素</a></p>
<h2 id="双指针-4"><a class="markdownIt-Anchor" href="#双指针-4"></a> 双指针</h2>
<p>因为题目说了链表是已经排序好了的，所以第一次看这题我的想法是：定义两个指针p1，p2，初始都指向头节点，然后移动p2节点开始遍历链表。直到p2走到链表终点。遍历过程中：</p>
<ul>
<li>遍历开始时，p2先走一步（<code>p2 = p2.next;</code>）</li>
<li>如果p1和p2节点的值不同，那么让p1的下一个节点指向p2（<code>p1.next = p2;</code>），然后让p1走到p2的位置（<code>p1 = p2;</code>）</li>
</ul>
<p>遍历结束后，因为存在链表的最后几个节点的元素是重复的元素，所以我们还要执行<code>p1.next = null;</code>操作。逻辑很简单，画一下图就能搞懂。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p1，p2两个指针，初始都指向head</span></span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (p2.next != <span class="keyword">null</span>) &#123;  <span class="comment">// p2到链表终点，遍历结束</span></span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            <span class="keyword">if</span> (p2.val != p1.val) &#123;   <span class="comment">// 发现不同节点</span></span><br><span class="line">                p1.next = p2;</span><br><span class="line">                p1 = p2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止链表的最后几个节点相同的情况</span></span><br><span class="line">        p1.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="84-柱状图中最大的矩形"><a class="markdownIt-Anchor" href="#84-柱状图中最大的矩形"></a> 84. 柱状图中最大的矩形</h1>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LeetCode 84. 柱状图中最大的矩形</a></p>
<h2 id="暴力算法tle"><a class="markdownIt-Anchor" href="#暴力算法tle"></a> 暴力算法（TLE）</h2>
<p>暴力算法虽然<code>Time Limit Exceeded</code>，但是写一遍代码，对于理解这题的一些细节上还是很有帮助的。</p>
<p>暴力算法的大致意思是：因为最终的结果一定是一个<code>height*weight</code>的形式，所以我们<strong>遍历每一个height，并根据当前的height，向左右扩展来找出最大的weight</strong>，最终得到一个max_result。在遍历height时，有一个for循环，在向左右扩展时，会有嵌套的for循环，所以时间复杂度是O(n^2)。</p>
<blockquote>
<p>来自<a href="https://leetcode-cn.com/u/liweiwei1419/" target="_blank" rel="noopener">liweiwei1419L6</a>大佬的题解分析<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/" target="_blank" rel="noopener">暴力解法、栈（单调栈、哨兵技巧）</a></p>
<p>这道问题的暴力解法比「接雨水」那道题要其实好想得多：可以枚举以每个柱形为高度的最大矩形的面积。</p>
<p>具体来说是：依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150933.png" alt="" /></p>
<p>为此，我们需要：</p>
<p>左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；<br />
右边看一下，看最多能向右延伸多长；找到大于等于当前柱形高度的最右边元素的下标。<br />
对于每一个位置，我们都这样操作，得到一个矩形面积，求出它们的最大值。</p>
</blockquote>
<blockquote>
<ul>
<li>时间复杂度：O(n^2)，这里n是heights数组的长度。</li>
<li>空间复杂度：O(1)，使用常数个临时变量</li>
</ul>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历过程中的临时高和宽</span></span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> weight = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;  <span class="comment">// 遍历高</span></span><br><span class="line">            height = heights[i];</span><br><span class="line">            <span class="keyword">if</span> (height==<span class="number">0</span>)&#123; <span class="comment">// 如果该高为0，无需判断weight了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            weight = <span class="number">1</span>;     <span class="comment">// weight先置1（即还没向左右遍历的状态，weight为1）</span></span><br><span class="line">            <span class="comment">// 要求遍历过程中的临时宽，需要以i为中心向两边遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = i - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (heights[l] &lt; heights[i]) &#123; <span class="comment">// 如果左边的高比i处的高小，那么就以后都不可以扩展</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                weight++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = i + <span class="number">1</span>; r &lt; heights.length; r++) &#123;   <span class="comment">// 向右遍历</span></span><br><span class="line">                <span class="keyword">if</span> (heights[r] &lt; heights[i]) &#123; <span class="comment">// 如果右边的高比i处的高小，那么就以后都不可以扩展</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                weight++;</span><br><span class="line">            &#125;</span><br><span class="line">            max_result = Math.max(max_result, height * weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈-2"><a class="markdownIt-Anchor" href="#单调栈-2"></a> 单调栈</h2>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/" target="_blank" rel="noopener">官方题解</a></p>
<p>这题跟[42. 接雨水](#42. 接雨水)很像，都可以用单调栈来解决。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/" target="_blank" rel="noopener">liweiwei1419</a>大佬的题解已经写得非常详细了，这里写一点自己的想法。</p>
</blockquote>
<p>在理解完暴力算法后，就可以很好的理解单调栈的思路了。</p>
<p>使用单调栈解决，<strong>在确定某一块不可能再<mark>向右</mark>扩展后，计算出那一块能确定的最大面积</strong>（其实就是能扩展的最大宽度weight，因为height就是这个块）</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502150954.png" alt="" /></p>
<p>最后注意一下，我们在单调栈中存储的是各个块<strong>在heights数组的索引</strong>，这种应该已经遇到过很多次了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = heights.length;</span><br><span class="line">        <span class="comment">// 对heights特殊长度的判断</span></span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_result = heights[<span class="number">0</span>];    <span class="comment">// 初始值</span></span><br><span class="line">        <span class="comment">// 单调栈,如果新push的块让当前栈的栈顶元素不能再扩展了，那么我们就要pop栈顶元素，并计算栈顶那个块能确定的最大面积</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">// for循环遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// while循环保证单调栈，同时计算结果</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peekLast()])&#123;   <span class="comment">// 栈顶块不能向右扩展了</span></span><br><span class="line">                <span class="comment">// 求出该pop的块的最大面积</span></span><br><span class="line">                <span class="keyword">int</span> curHeight = heights[stack.removeLast()];</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; curHeight==heights[stack.peekLast()])&#123;   <span class="comment">// 考虑到新的栈顶元素跟当前块高度一样的情况</span></span><br><span class="line">                    stack.removeLast();    <span class="comment">// 直接pop即可</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> curWeight;  <span class="comment">// 接下来要求该块能扩展的最大宽度了</span></span><br><span class="line">                <span class="comment">// 这个特殊情况，一定要画一下草图就能搞懂了</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty())&#123;   <span class="comment">// 如果栈顶元素在pop之后为空了，weight为i</span></span><br><span class="line">                    curWeight = i;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    curWeight = i- stack.peekLast()-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max_result = Math.max(max_result, curHeight*curWeight);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);  <span class="comment">// 注意栈中存储的是索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接下来处理单调栈中剩余的元素</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curHeight = heights[stack.removeLast()];</span><br><span class="line">            <span class="keyword">int</span> curWeight;</span><br><span class="line">            <span class="comment">// 这个特殊情况，也是要画一下草图就能搞懂了</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;   <span class="comment">// stack为空了，说明当前pop的栈已经是所有块中最矮的，当然能扩展到尽头</span></span><br><span class="line">                curWeight = length;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;     <span class="comment">// 这个情况画一下图就能搞懂</span></span><br><span class="line">                curWeight = length-stack.peekLast()-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max_result = Math.max(max_result, curHeight*curWeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N)，<strong>输入数组里的每一个元素入栈一次，出栈一次</strong>。</li>
<li>空间复杂度：O(N)，栈的空间最多为 N。</li>
</ul>
</blockquote>
<h2 id="单调栈哨兵优化"><a class="markdownIt-Anchor" href="#单调栈哨兵优化"></a> 单调栈（哨兵优化）</h2>
<p>同样是<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/" target="_blank" rel="noopener">liweiwei1419</a>大佬的题解。</p>
<p>在上面单纯的使用单调栈时，需要考虑两种特殊的情况：</p>
<ol>
<li>弹栈的时候，栈为空</li>
<li>遍历完成以后，栈中还有元素（<strong>所以在for循环之后还有一个while循环处理剩下的单调栈</strong>）</li>
</ol>
<p>为此可以我们可以<strong>在输入数组的两端加上两个高度为 0</strong> （或者是 0.5，只要比 1 严格小都行）的柱形，<strong>可以回避上面这两种分类讨论</strong>。</p>
<p>这两个站在两边的柱形有一个很形象的名词，叫做<strong>哨兵</strong>（Sentinel）。</p>
<p>有了这两个柱形：</p>
<ul>
<li>最左边的柱形（<strong>第 1 个哨兵</strong>）由于它一定比输入数组里任何一个元素小，它肯定不会出栈，因此<strong>栈一定不会为空</strong>；</li>
<li>最右边的柱形（<strong>第 2 个哨兵</strong>）也正是因为它一定比输入数组里任何一个元素小，它<strong>会让所有输入数组里的元素出栈</strong>（第 1 个哨兵元素除外）。</li>
</ul>
<blockquote>
<p>这里栈对应到高度，呈单调增加不减的形态，因此称为单调栈（Monotone Stack）。它是暴力解法的优化，计算每个柱形的高度对应的最大矩形的顺序由出栈顺序决定。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = heights.length;</span><br><span class="line">        <span class="comment">// 对heights特殊长度的判断</span></span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_result = heights[<span class="number">0</span>];    <span class="comment">// 初始值</span></span><br><span class="line">        <span class="comment">// 创建新数组newHeights，与heights相比只是在其两端上各加1个0</span></span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">2</span>];</span><br><span class="line">        newHeights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        newHeights[length+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, heights.length);</span><br><span class="line">        length = length+<span class="number">2</span>;  <span class="comment">// 此时将length设置为newHeights数组的长度</span></span><br><span class="line">        <span class="comment">// 单调栈</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.addLast(<span class="number">0</span>);   <span class="comment">// 添加最左边的哨兵，这样在对单调栈的操作中栈永远不会为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;  <span class="comment">// 已经添加最左边的哨兵了，所以注意i从1开始</span></span><br><span class="line">            <span class="keyword">while</span> (newHeights[i]&lt;newHeights[stack.peekLast()])&#123;</span><br><span class="line">                <span class="keyword">int</span> curHeight = newHeights[stack.removeLast()];</span><br><span class="line">                <span class="keyword">int</span> curWeight = i-stack.peekLast()-<span class="number">1</span>;</span><br><span class="line">                max_result = Math.max(max_result,curHeight*curWeight);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比上面的代码，使用哨兵优化代码无疑要简化的多。</p>
<h1 id="88-合并两个有序数组"><a class="markdownIt-Anchor" href="#88-合并两个有序数组"></a> 88. 合并两个有序数组</h1>
<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode 88. 合并两个有序数组</a></p>
<h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h2>
<p>先将<code>nums2</code>的数组添加到<code>nums1</code>中，然后对<code>nums1</code>进行排序即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;n)&#123;</span><br><span class="line">            nums1[i] = nums2[j];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针-5"><a class="markdownIt-Anchor" href="#双指针-5"></a> 双指针</h2>
<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/" target="_blank" rel="noopener">官方题解</a></p>
<p>思路：定义两个指针分别遍历<code>nums1</code>和<code>nums2</code>。然后按降序将结果存储到新的数组<code>sorted</code>中。最后将<code>nums1</code>变为<code>sorted</code>即可。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151017.gif" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; sorted = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;m || j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=m)&#123;  <span class="comment">// i指针已经走完nums1了</span></span><br><span class="line">                sorted.add(nums2[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j&gt;=n)&#123;  <span class="comment">// j指针已经走完nums2了（i还没有走完）</span></span><br><span class="line">                sorted.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[i]&lt;nums2[j])&#123;   <span class="comment">// 都没有走完</span></span><br><span class="line">                sorted.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums2[j]&lt;=nums1[i])&#123;</span><br><span class="line">                sorted.add(nums2[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; sorted.size(); index++) &#123;</span><br><span class="line">            nums1[index] = sorted.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(m+n)。</li>
<li>空间复杂度：O(m+n)。</li>
</ul>
</blockquote>
<h2 id="逆向双指针"><a class="markdownIt-Anchor" href="#逆向双指针"></a> 逆向双指针</h2>
<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/" target="_blank" rel="noopener">官方题解</a></p>
<p>方法二中，之所以要使用临时变量，是因为如果直接合并到数组<code>nums1</code>中，<code>nums1</code>中的元素可能会在取出之前被覆盖。那么如何直接避免覆盖 <code>nums1</code> 中的元素呢？观察可知，<code>nums1</code>的<strong>后半部分是空的，可以直接覆盖而不会影响结果</strong>。因此<strong>可以设置指针为从后向前遍历</strong>，每次取两者之中的<strong>较大者</strong>放进<code>nums1</code>的<strong>最后面</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 逆向双指针</span></span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (end&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;<span class="number">0</span>)&#123;   <span class="comment">// i指针走完了</span></span><br><span class="line">                nums1[end] = nums2[j];</span><br><span class="line">                end--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j&lt;<span class="number">0</span>)&#123;   <span class="comment">// j指针已经走完nums2了（i还没有走完）</span></span><br><span class="line">                nums1[end] = nums1[i];</span><br><span class="line">                end--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[i]&gt;nums2[j])&#123;   <span class="comment">// 都没有走完</span></span><br><span class="line">                nums1[end] = nums1[i];</span><br><span class="line">                end--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[end] = nums2[j];</span><br><span class="line">                end--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(m+n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
</blockquote>
<h1 id="90-子集-ii"><a class="markdownIt-Anchor" href="#90-子集-ii"></a> 90. 子集 II</h1>
<p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">LeetCode 90. 子集 II</a></p>
<h2 id="回溯算法-4"><a class="markdownIt-Anchor" href="#回溯算法-4"></a> 回溯算法</h2>
<p>这题跟[78. 子集](#78. 子集)很像，只是需要去除重复的子集即可。这里我们使用Set来进行去重。</p>
<p>首先<strong>要对nums进行排序</strong>。这样是为了后续可以更好地进行去重。大致思路如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151037.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 最终结果</span></span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="comment">// 对数组长度的特殊判断</span></span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 记录回溯过程中的结果</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums,length,<span class="number">0</span>,path,result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 题目所给数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 题目所给数组长度，因为不想在dfs函数中每次都去读取nums.length，所以直接将其作为参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前遍历到nums数组的索引（当index==length，不能再向下遍历了）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 记录回溯过程中的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 最终返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span> index, List&lt;Integer&gt; path, Set&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index&gt;length-<span class="number">1</span>)&#123; <span class="comment">// 不能再向下遍历了，记录结果</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在结点的分支中，我们要考虑的是是否要选择当前这个数</span></span><br><span class="line">        <span class="comment">// 1.不选择，直接到下一个结点</span></span><br><span class="line">        dfs(nums,length,index+<span class="number">1</span>,path,result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.选择，将当前这个数添加到path中，然后继续向下一个结点</span></span><br><span class="line">        path.add(nums[index]);</span><br><span class="line">        dfs(nums,length,index+<span class="number">1</span>,path,result);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>); <span class="comment">// 别忘了状态变量的还原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="92-反转链表-ii"><a class="markdownIt-Anchor" href="#92-反转链表-ii"></a> 92. 反转链表 II</h1>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">LeetCode 92. 反转链表 II</a></p>
<h2 id="单链表先切割再合并"><a class="markdownIt-Anchor" href="#单链表先切割再合并"></a> 单链表（先切割再合并）</h2>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/" target="_blank" rel="noopener">官方题解</a>给出的第一种方法，跟我一开始的想法是一样的：即先将要反转的链表片段切割出来，然后执行[206反转链表](#206. 反转链表)的操作，最后将反转后的链表与原链表两端对接即可。这里注意一下，为了处理left的多种情况，我选择使用了头结点root用以区分首元结点head。在写单链表的1一些题目时，有时并不是特别区分头结点和首元结点的叫法。但是我们心里一定要清楚<strong>头结点和首元结点</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;  <span class="comment">// left==right,直接返回head即可</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了方便起见，我们还是要来用一个头结点root，区别于首元结点head</span></span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode();</span><br><span class="line">        root.next = head;</span><br><span class="line">        <span class="comment">// 反转中间链表，需要重点关注4个结点</span></span><br><span class="line">        ListNode left_Node = root;  <span class="comment">//  left节点的前一个节点</span></span><br><span class="line">        ListNode leftNode = root;   <span class="comment">// left节点</span></span><br><span class="line">        ListNode rightNode = root;  <span class="comment">// right节点</span></span><br><span class="line">        ListNode rightNode1 = root; <span class="comment">// right节点的下一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            left_Node = left_Node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        leftNode = left_Node.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right; i++) &#123;</span><br><span class="line">            rightNode = rightNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        rightNode1 = rightNode.next;</span><br><span class="line">        <span class="comment">// 切割链表</span></span><br><span class="line">        left_Node.next = <span class="keyword">null</span>;</span><br><span class="line">        rightNode.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 反转切割出来的链表,用left-1节点指向反转后的链表的头节点</span></span><br><span class="line">        left_Node.next = reverseLinkedList(leftNode);</span><br><span class="line">        leftNode.next = rightNode1;     <span class="comment">// 反转后的链表，leftNode节点即为最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseLinkedList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = pre; <span class="comment">// 修改结点指向</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="头插法"><a class="markdownIt-Anchor" href="#头插法"></a> 头插法</h2>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/" target="_blank" rel="noopener">官方题解</a>中给出的第二个方法，即为头插法。这里搬运一下官方题解思路：</p>
<blockquote>
<p>方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)O(N)，但遍历了链表 22 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。</p>
<p>我们依然以方法一的示例为例进行说明。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151104.png" alt="" /></p>
<p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151119.png" alt="" /></p>
<p>下面我们具体解释如何实现。使用三个指针变量 <code>pre</code>、<code>curr</code>、<code>next</code> 来记录反转的过程中需要的变量，它们的意义如下：</p>
<ul>
<li><code>curr</code>：指向待反转区域的第一个节点 <code>left</code>；</li>
<li><code>next</code>：永远指向 <code>curr</code> 的下一个节点，循环过程中，<code>curr</code> 变化以后 <code>next</code> 会变化；</li>
<li><code>pre</code>：永远指向待反转区域的第一个节点 <code>left</code> 的前一个节点，在循环过程中不变。</li>
</ul>
<p>第 1 步，我们使用 ①、②、③ 标注「穿针引线」的步骤。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151138.png" alt="" /></p>
<p><strong><mark>操作步骤</mark></strong>：</p>
<ul>
<li>先将 <code>curr</code> 的下一个节点记录为 <code>next</code>；</li>
<li>执行操作 ①：把 <code>curr</code> 的下一个节点指向 <code>next</code> 的下一个节点；</li>
<li>执行操作 ②：把 <code>next</code> 的下一个节点指向 <code>pre</code> 的下一个节点；</li>
<li>执行操作 ③：把 <code>pre</code> 的下一个节点指向 <code>next</code>。</li>
</ul>
<p>这个循环执行<code>right-left</code>次。</p>
<p>第 1 步完成以后「拉直」的效果如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151152.png" alt="" /></p>
<p>第 2 步，同理。同样需要注意 <strong>「穿针引线」操作的先后顺序</strong>。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151209.png" alt="" /></p>
<p>第 2 步完成以后「拉直」的效果如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151227.png" alt="" /></p>
<p>第三步同理，一共执行<code>right-left</code>次后就完成了。</p>
</blockquote>
<p>因为代码是我根据头插法的思路自己敲的，所以代码跟官方题解有些不一致，这里说明一下：</p>
<ul>
<li><code>cur</code>：<strong>永远</strong>指向 <code>left</code>节点；（在循环的过程中，left-1节点的下一个节点不一定是left（cur）节点了）</li>
<li><code>next</code>：永远指向 <code>cur</code> 的下一个节点，循环过程中，<code>cur</code> 变化以后 <code>next</code> 会变化；</li>
<li><code>left_Node</code>：永远指向待反转区域的第一个节点 <code>left</code> 的前一个节点，在循环过程中不变。</li>
</ul>
<p>for循环内的**<mark>操作步骤</mark>**：</p>
<ul>
<li><code>next</code>节点赋值为 <code>cur</code> 的下一个节点记录为 ；</li>
<li>把 <code>cur</code> 的下一个节点指向 <code>next</code> 的下一个节点；</li>
<li>把 <code>next</code> 的下一个节点指向 <code>left_Node</code> 的下一个节点；</li>
<li>把 <code>left_Node</code> 的下一个节点指向 <code>next</code>。</li>
</ul>
<p>这个循环执行<code>right-left</code>次。</p>
<p>只看文字可能有点绕，画个草稿应该可以搞清楚。这里可以看一下比较潦草的草稿：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151249.png" alt="" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;  <span class="comment">// left==right,直接返回head即可</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了方便起见，我们还是要来用一个头结点root，区别于首元结点head</span></span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode();</span><br><span class="line">        root.next = head;</span><br><span class="line">        <span class="comment">// 反转中间链表，需要重点关注4个结点</span></span><br><span class="line">        ListNode left_Node = root;  <span class="comment">//  left节点的前一个节点</span></span><br><span class="line">        ListNode cur = root;   <span class="comment">// left节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            left_Node = left_Node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = left_Node.next;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="comment">// 循环right - left次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">            next.next = left_Node.next;</span><br><span class="line">            left_Node.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈-2"><a class="markdownIt-Anchor" href="#栈-2"></a> 栈</h2>
<p>由大佬<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/92-fan-zhuan-lian-biao-ii-shi-jian-100ne-6uwe/" target="_blank" rel="noopener">耗子扛刀一路找猫</a>提供的思路。这种思路<strong>并没有像上面两种方法那样对节点的指向(next)进行修改</strong>，而是<strong>修改链表本身的val值</strong>。</p>
<p>分析如下：</p>
<ul>
<li>要反转链表，只需要<strong>将该链表的对称两端节点的val值互换即可</strong></li>
<li>要实现对称互换的效果，可以将要反转的链表分为<code>[left,（left+right）/2+1]</code>，<code>[（left+right）/2+1,right]</code>这两部分，保证<strong>这两部分关于链表中心对称</strong></li>
<li>互换的实现可以借助<strong>栈</strong>，<strong>用栈来存储右半部分的节点</strong>。</li>
</ul>
<p>大致思想如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151312.png" alt="" /></p>
<p>大佬代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode leftNode = head;</span><br><span class="line">        ListNode rightNode = head;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (left + right) / <span class="number">2</span>; i++)</span><br><span class="line">            rightNode = rightNode.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (left + right) / <span class="number">2</span> + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.push(rightNode);</span><br><span class="line">            rightNode = rightNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++)</span><br><span class="line">            leftNode = leftNode.next;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            rightNode = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> temp = rightNode.val;</span><br><span class="line">            rightNode.val = leftNode.val;</span><br><span class="line">            leftNode.val = temp;</span><br><span class="line">            leftNode = leftNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94-二叉树的中序遍历"></a> 94. 二叉树的中序遍历</h1>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">LeetCode 94. 二叉树的中序遍历</a></p>
<h2 id="深度优先搜索dfs"><a class="markdownIt-Anchor" href="#深度优先搜索dfs"></a> 深度优先搜索（DFS）</h2>
<p>二叉树的四种遍历在数据结构的学习中就已经实现过了（<a href="https://www.qingbo1011.top/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86">笔记链接</a>），这里直接给出代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            inorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="101-对称二叉树"><a class="markdownIt-Anchor" href="#101-对称二叉树"></a> 101. 对称二叉树</h1>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">LeetCode 101. 对称二叉树</a></p>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p><strong>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</strong></p>
<p>判断两个树是否互为镜像：</p>
<ul>
<li>它们的两个根结点具有相同的值</li>
<li>每个树的右子树都与另一个树的左子树镜像对称</li>
</ul>
<p>我们可以实现这样一个递归函数，通过<strong>同步移动</strong>两个指针的方法来遍历这棵树，<code>p</code> 指针和 <code>q</code> 指针一开始都指向这棵树的根，随后 <code>p</code> 右移时，<code>q</code> 左移，<code>p</code> 左移时，<code>q</code> 右移。</p>
<p>每次检查当前 <code>p</code> 和 <code>q</code> 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)&#123;    <span class="comment">// 当p和q都到空了还没用返回false，说明是对称的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p==<span class="keyword">null</span> || q==<span class="keyword">null</span>)&#123;  <span class="comment">// 出现p为空q不为空或q为空p不为空，不可能是对称的了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有走到递归出口，就递归的判断p和q的值是否相等，p的左子树是否和q的右子树对称，p的右子树是否和q的左子树相等</span></span><br><span class="line">        <span class="keyword">return</span> p.val==q.val &amp;&amp; check(p.left,q.right) &amp;&amp; check(p.right,q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>（n为树的结点数）</p>
</blockquote>
<h1 id="102-二叉树的层序遍历"><a class="markdownIt-Anchor" href="#102-二叉树的层序遍历"></a> 102. 二叉树的层序遍历</h1>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode 102. 二叉树的层序遍历</a></p>
<h2 id="广度优先搜索bfs"><a class="markdownIt-Anchor" href="#广度优先搜索bfs"></a> 广度优先搜索（BFS）</h2>
<p>二叉树的四种遍历在数据结构的学习中就已经实现过了（<a href="https://www.qingbo1011.top/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86">笔记链接</a>）</p>
<p>但是这里的输出是以嵌套列表的形式输出，所以按照笔记上的那种解法还不够，需要<strong>两层while循环</strong>来控制每一层在同一个列表中。但是还是用<strong>队列</strong>来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;    <span class="comment">// 如果树为空，直接返回空列表</span></span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();    <span class="comment">// 用队列来实现</span></span><br><span class="line">        deque.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> count = deque.size();    <span class="comment">// 记录队列当前长度，即为当前层的结点数</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 存储当前层结果列表</span></span><br><span class="line">            <span class="keyword">while</span> (count&gt;<span class="number">0</span>)&#123;    <span class="comment">// 这里是count&gt;0而不是!deque.isEmpty()，就是为了控制每一层的结点在同一个列表中</span></span><br><span class="line">                TreeNode node = deque.remove();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    deque.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    deque.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上面的while循环结束后，该层的遍历结束</span></span><br><span class="line">            lists.add(list);</span><br><span class="line">            <span class="comment">// 但是由于有deque.add(node.left)和deque.add(node.right)这样的操作</span></span><br><span class="line">            <span class="comment">// count=0只是该层遍历结束，deque还不为空，会继续循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="104-二叉树的最大深度"><a class="markdownIt-Anchor" href="#104-二叉树的最大深度"></a> 104. 二叉树的最大深度</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode 104. 二叉树的最大深度</a></p>
<h2 id="深度优先搜索dfs-2"><a class="markdownIt-Anchor" href="#深度优先搜索dfs-2"></a> 深度优先搜索（DFS）</h2>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p>使用深度优先搜索的思想。递归地求出二叉树左子树和右子树的深度<code>leftDepth</code>和<code>rightDepth</code>，最后返回<code>Math.max(leftDepth,rightDepth)+1</code>即可。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftDepth = maxDepth(root.left);</span><br><span class="line">        int rightDepth = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(leftDepth,rightDepth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="105-从前序与中序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#105-从前序与中序遍历序列构造二叉树"></a> 105. 从前序与中序遍历序列构造二叉树</h1>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">LeetCode 105. 从前序与中序遍历序列构造二叉树</a></p>
<h1 id="118-杨辉三角"><a class="markdownIt-Anchor" href="#118-杨辉三角"></a> 118. 杨辉三角</h1>
<p><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">LeetCode 118. 杨辉三角</a></p>
<h2 id="数学-2"><a class="markdownIt-Anchor" href="#数学-2"></a> 数学</h2>
<p>根据杨辉三角的概念，嵌套两层for循环求解。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span> || j==i)&#123;</span><br><span class="line">                    path.add(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    path.add(res.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)+res.get(i-<span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="119-杨辉三角-ii"><a class="markdownIt-Anchor" href="#119-杨辉三角-ii"></a> 119. 杨辉三角 II</h1>
<p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">LeetCode 119. 杨辉三角 II</a></p>
<h2 id="数学-3"><a class="markdownIt-Anchor" href="#数学-3"></a> 数学</h2>
<p>按照<a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">LeetCode 118. 杨辉三角</a>中的题解，求出杨辉三角前<code>rowIndex+1</code>行，最后第<code>rowIndex</code>行即为<code>res.get(rowIndex)</code>。（因为题目说从第0行开始算）</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">            path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span> || j==i)&#123;</span><br><span class="line">                    path.add(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    path.add(res.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)+res.get(i-<span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.get(rowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数学优化"><a class="markdownIt-Anchor" href="#数学优化"></a> 数学优化</h2>
<p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/solution/yang-hui-san-jiao-ii-by-leetcode-solutio-shuk/" target="_blank" rel="noopener">官方题解</a></p>
<p>因为题目要求第<code>rowIndex</code>的杨辉三角，所以就不需要生成整个杨辉三角。</p>
<p>由组合数公式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="script">C</mi><mi>n</mi><mi>m</mi></msubsup><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><mrow><mi>m</mi><mo stretchy="false">!</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mathcal{C}_{n}^{m}=\frac{n !}{m !(n-m) !}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mclose mtight">!</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">m</span><span class="mclose mtight">)</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，可以得到同一行的相邻组合数的关系</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="script">C</mi><mi>n</mi><mi>m</mi></msubsup><mo>=</mo><msubsup><mi mathvariant="script">C</mi><mi>n</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>×</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">\mathcal{C}_{n}^{m}=\mathcal{C}_{n}^{m-1} \times \frac{n-m+1}{m}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="script">C</mi><mi>n</mi><mn>0</mn></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mathcal{C}_{n}^{0}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，利用上述公式我们可以在线性时间计算出第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 行的所有组合数。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151337.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span> || i==rowIndex)&#123;</span><br><span class="line">                res.add(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 注意这里有溢出的问题</span></span><br><span class="line">                res.add((<span class="keyword">int</span>) ((<span class="keyword">long</span>)res.get(i-<span class="number">1</span>) * (rowIndex-i+<span class="number">1</span>)/i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="121-买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121-买卖股票的最佳时机"></a> 121. 买卖股票的最佳时机</h1>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">LeetCode 121. 买卖股票的最佳时机</a></p>
<h2 id="单调栈-3"><a class="markdownIt-Anchor" href="#单调栈-3"></a> 单调栈</h2>
<p>这题看到之后，首先想到的就是使用单调栈，<strong>保证栈顶永远大于栈底</strong>。</p>
<p>具体思路用文字不好说，草稿图如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151353.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; prices[i]&lt;stack.peekLast())&#123;</span><br><span class="line">                Integer removeLast = stack.removeLast();</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty())&#123;</span><br><span class="line">                    res = Math.max(res, removeLast-stack.peekFirst());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后，如果单调栈不为空，别忘了记录此时栈顶-栈底的值</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty())&#123;</span><br><span class="line">            res = Math.max(res, stack.peekLast()-stack.peekFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="134-加油站"><a class="markdownIt-Anchor" href="#134-加油站"></a> 134. 加油站</h1>
<p><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">LeetCode 134. 加油站</a></p>
<h2 id="贪心算法-5"><a class="markdownIt-Anchor" href="#贪心算法-5"></a> 贪心算法</h2>
<p>分析：主要有两点：</p>
<ul>
<li>首先，gas数组之和减去cost数组之和sum一定要大于等于0，否则无论如何也不可能绕一圈</li>
<li>在确保可以绕一圈后，就要开始贪心思想了：<strong>如果从加油站i到加油站j时，汽车油量oil变成了负数。说明加油站i到加油站j中的<mark>任何一个加油站</mark>都不可能作为起点。并且<mark>加油站j的gas一定小于cost</mark>，因此加油站j自己也不可能作为起点。</strong>（这里的贪心思想非常关键，通过此思路就可以实现贪心算法而不是暴力算法）</li>
</ul>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151420.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = gas.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            arr[i] = gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            sum = sum+arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum&lt;<span class="number">0</span>)&#123;     <span class="comment">// 不可能绕一圈</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> oil = <span class="number">0</span>;    <span class="comment">// 剩余油量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                oil = oil+arr[i];</span><br><span class="line">                <span class="keyword">if</span> (oil&lt;<span class="number">0</span>)&#123;     <span class="comment">/* 举个例子，若i=0，i=1时，oil都大于0，i=2时oil&lt;0</span></span><br><span class="line"><span class="comment">                                    根据我们分析的贪心算法，这就说明从0到2之间</span></span><br><span class="line"><span class="comment">                                    任意一个加油站都不可能成为起点，result直接取i+1</span></span><br><span class="line"><span class="comment">                                    再重置oil为0 */</span></span><br><span class="line">                    oil = <span class="number">0</span>;</span><br><span class="line">                    result = i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result==length)&#123;    <span class="comment">// 因为是环形，起点为数组长度length，即为起点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="136-只出现一次的数字"><a class="markdownIt-Anchor" href="#136-只出现一次的数字"></a> 136. 只出现一次的数字</h1>
<p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">LeetCode 136. 只出现一次的数字</a></p>
<h2 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h2>
<p>如果要求：算法具有线性时间复杂度，不使用额外空间来实现。那么就不能使用哈希表了。我们可以使用位<strong>运算来</strong>实现。</p>
<p>由于题目所给的非空整数数组，<strong>除了某个元素只出现一次以外，其余每个元素均出现两次</strong>。</p>
<p>同时结合简单的数学知识：</p>
<ul>
<li><strong>相同的数异或运算结果为0</strong></li>
<li><strong>0和任何数进行异或运算都等于这个数本身</strong></li>
</ul>
<p>所以我们将nums数组中所有数进行异或操作，由于相同的两个数异或结果为0，最终结果即为0异或只出现一次的数字，结果即为这个数字本身。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            result  =result^num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表"></a> 141. 环形链表</h1>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCode 141. 环形链表</a></p>
<h2 id="哈希表-3"><a class="markdownIt-Anchor" href="#哈希表-3"></a> 哈希表</h2>
<p>思路也比较简单。遍历单链表，使用HashSet来记录遍历过的节点Node。如果出现遍历到的节点的下一个节点<code>node.next</code>在HashSet中出现过，那么就说明是环形链表。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.add(p.next))&#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 是环形链表</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:3 ms,击败了22.34% 的Java用户，内存消耗:42 MB,击败了60.67% 的Java用户</code></p>
</blockquote>
<h2 id="快慢指针"><a class="markdownIt-Anchor" href="#快慢指针"></a> 快慢指针</h2>
<p>在一般面试时，比较经典的回答还是<strong>双指针</strong>。思路就是：使用两个指针<code>p1</code>，<code>p2</code>。<strong>p1指针每次走一步，p2指针每次走两步</strong>。在指针走到尽头之前，如果p1等于p2了，那么就说明有环。（事实上如果有环了话，两个指针就永远不刽走到尽头，迟早会相遇的）</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head.next;</span><br><span class="line">        <span class="keyword">while</span> (p2!=<span class="keyword">null</span> &amp;&amp; p2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1==p2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:0 ms,击败了100.00% 的Java用户，内存消耗:42.6 MB,击败了24.28% 的Java用户</code></p>
</blockquote>
<h1 id="142-环形链表-ii"><a class="markdownIt-Anchor" href="#142-环形链表-ii"></a> 142. 环形链表 II</h1>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode 142. 环形链表 II</a></p>
<h2 id="哈希表-4"><a class="markdownIt-Anchor" href="#哈希表-4"></a> 哈希表</h2>
<p>使用哈希表思路跟<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCode 141. 环形链表</a>一样简单，使用<code>HashSet</code>即可解决。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:3 ms,击败了20.26% 的Java用户，内存消耗:42.4 MB,击败了5.06% 的Java用户</code></p>
</blockquote>
<h2 id="快慢指针-2"><a class="markdownIt-Anchor" href="#快慢指针-2"></a> 快慢指针</h2>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p><strong>快慢指针，当slow指针和fast指针相遇后，再让ptr指针从头结点开始，和slow指针每次向后移动一个位置。最终，它们会在入环点相遇。</strong></p>
<blockquote>
<p>数学推论：</p>
<p>我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后， slow指针每次向后移动 一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。<br />
如下图所示，设链表中环外部分的长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 。 slow 指针进入环后，又走了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的距离与 fast 相 遇。此时，fast 指针已经走完了环的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 圈，因此它走过的总距离为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi><mo>=</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo></mrow><annotation encoding="application/x-tex">a+n(b+c)+b=a+(n+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">+</span></span></span></span> 1) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>+</mo><mi>n</mi><msub><mi>c</mi><mtext>。 </mtext></msub></mrow><annotation encoding="application/x-tex">b+n c_{\text {。 }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">。</span><span class="mord mtight"> </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502151449.png" alt="" /></p>
<p>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>b</mi><mo>+</mo><mi>n</mi><mi>c</mi><mo>=</mo><mn>2</mn><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>⟹</mo><mi>a</mi><mo>=</mo><mi>c</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a+(n+1) b+n c=2(a+b) \Longrightarrow a=c+(n-1)(b+c)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span></span></p>
<p>有了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>c</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a=c+(n-1)(b+c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span> 的等量关系，我们会发现：从相遇点到入环点的距离加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 圈 的环长，恰好等于从链表头部到入环点的距离。<br />
<strong>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随 后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</strong></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode ptr = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow==fast)&#123;</span><br><span class="line">                <span class="keyword">while</span> (ptr!=slow)&#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:0 ms,击败了100.00% 的Java用户，内存消耗:41.6 MB,击败了44.39% 的Java用户</code></p>
</blockquote>
<h1 id="144-二叉树的前序遍历"><a class="markdownIt-Anchor" href="#144-二叉树的前序遍历"></a> 144. 二叉树的前序遍历</h1>
<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">LeetCode 144. 二叉树的前序遍历</a></p>
<h2 id="深度优先搜索dfs-3"><a class="markdownIt-Anchor" href="#深度优先搜索dfs-3"></a> 深度优先搜索（DFS）</h2>
<p>二叉树的四种遍历在数据结构的学习中就已经实现过了（<a href="https://www.qingbo1011.top/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86">笔记链接</a>），这里直接给出代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="145-二叉树的后序遍历"><a class="markdownIt-Anchor" href="#145-二叉树的后序遍历"></a> 145. 二叉树的后序遍历</h1>
<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">LeetCode 145. 二叉树的后序遍历</a></p>
<h2 id="深度优先搜索dfs-4"><a class="markdownIt-Anchor" href="#深度优先搜索dfs-4"></a> 深度优先搜索（DFS）</h2>
<p>二叉树的四种遍历在数据结构的学习中就已经实现过了（<a href="https://www.qingbo1011.top/2021/08/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86">笔记链接</a>），这里直接给出代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            postorderTraversal(root.left);</span><br><span class="line">            postorderTraversal(root.right);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="146-lru-缓存"><a class="markdownIt-Anchor" href="#146-lru-缓存"></a> 146. LRU 缓存</h1>
<p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LeetCode 146. LRU 缓存</a></p>
<h2 id="哈希表-双向链表"><a class="markdownIt-Anchor" href="#哈希表-双向链表"></a> 哈希表 + 双向链表</h2>
<p><a href="https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p>LRU 缓存机制可以通过<strong>哈希表</strong>辅以<strong>双向链表</strong>实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<ul>
<li>双向链表按照被使用的顺序存储了这些键值对，<strong>靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</strong></li>
<li>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</li>
</ul>
<p>这样以来，我们<strong>首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部</strong>，即可在 O(1) 的时间内完成 <code>get</code> 或者 <code>put</code> 操作。具体的方法如下：</p>
<ul>
<li>对于 <code>get</code> 操作，首先判断 <code>key</code> 是否存在：
<ul>
<li>如果 <code>key</code> 不存在，则返回 −1；</li>
<li>如果 <code>key</code> 存在，则 <code>key</code> 对应的节点是最近被使用的节点。通<strong>过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部</strong>，最后返回该节点的值。</li>
</ul>
</li>
<li>对于 <code>put</code> 操作，首先判断 <code>key</code> 是否存在：
<ul>
<li>如果 <code>key</code> 不存在，使用 <code>key</code> 和 <code>value</code> 创建一个新的节点，**在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。**然后判断双向链表的节点数是否超出容量，<strong>如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</strong></li>
<li>如果 <code>key</code> 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 <code>value</code>，<strong>并将该节点移到双向链表的头部</strong>。</li>
</ul>
</li>
</ul>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的<strong>头部添加节点</strong>、<strong>在双向链表的尾部删除节点</strong>的复杂度也为 O(1)。而<strong>将一个节点移到双向链表的头部</strong>，可以分成<strong>删除该节点</strong>和<strong>在双向链表的头部添加节点</strong>两步操作，都可以在 O(1) 时间内完成。</p>
<blockquote>
<p>在双向链表的实现中，<strong>使用一个伪头部（dummy head）和伪尾部（dummy tail）<strong>标记界限，这样</strong>在添加节点和删除节点的时候就不需要检查相邻的节点是否存在</strong>。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双向节点类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        LinkedNode pre;</span><br><span class="line">        LinkedNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkedNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkedNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义LRU相关的全局变量</span></span><br><span class="line">    <span class="comment">// key存储key建值，value存储双向节点（包含key和value）</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, LinkedNode&gt; cache = <span class="keyword">new</span> HashMap&lt;Integer, LinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">// LRUCache大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;   <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="comment">// 伪头结点和末尾结点</span></span><br><span class="line">    <span class="keyword">private</span> LinkedNode dummyHead;</span><br><span class="line">    <span class="keyword">private</span> LinkedNode dummyTail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化LRUCache</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> LinkedNode();</span><br><span class="line">        dummyTail = <span class="keyword">new</span> LinkedNode();</span><br><span class="line">        <span class="comment">// 双向链表，互相指向</span></span><br><span class="line">        dummyHead.next = dummyTail;</span><br><span class="line">        dummyTail.pre = dummyHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        LinkedNode linkedNode = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (linkedNode==<span class="keyword">null</span>)&#123;  <span class="comment">// key不存在，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key存在，先将该节点移到头部（最近使用），然后返回该节点值</span></span><br><span class="line">        moveToHead(linkedNode);</span><br><span class="line">        <span class="keyword">return</span> linkedNode.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        LinkedNode linkedNode = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (linkedNode==<span class="keyword">null</span>)&#123;  <span class="comment">// key不存在，需要创建一个新的节点</span></span><br><span class="line">            LinkedNode newLinkedNode = <span class="keyword">new</span> LinkedNode(key, value);</span><br><span class="line">            addToHead(newLinkedNode);   <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            cache.put(key,newLinkedNode);   <span class="comment">// 添加进哈希表</span></span><br><span class="line">            <span class="comment">// 然后要判断容量</span></span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size&gt;capacity)&#123; <span class="comment">// 超出容量</span></span><br><span class="line">                <span class="comment">// 删除双向链表的尾部节点</span></span><br><span class="line">                LinkedNode tail = removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                size--; <span class="comment">// 别忘了size--</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;     <span class="comment">// key存在（linkedNode不为null），更新即可</span></span><br><span class="line">            linkedNode.value = value;   <span class="comment">// 更新节点值</span></span><br><span class="line">            moveToHead(linkedNode);      <span class="comment">//将该节点移到双向链表的头部</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移动指定节点到头部（最近使用）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> linkedNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(LinkedNode linkedNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先删除再插入来实现</span></span><br><span class="line">        removeNode(linkedNode);</span><br><span class="line">        addToHead(linkedNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加指定节点到头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(LinkedNode addNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现画一下草图就能搞懂</span></span><br><span class="line">        dummyHead.next.pre = addNode;    <span class="comment">// 切断了dummyHead与node节点的pre连接</span></span><br><span class="line">        addNode.next = dummyHead.next;   <span class="comment">// 更新了addNode与node的next连接</span></span><br><span class="line">        dummyHead.next = addNode;</span><br><span class="line">        addNode.pre = dummyHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> removeNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(LinkedNode removeNode)</span> </span>&#123;</span><br><span class="line">        removeNode.pre.next = removeNode.next;</span><br><span class="line">        removeNode.next.pre = removeNode.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除最后一个节点（最久未使用），并返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LinkedNode <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode res = dummyTail.pre;</span><br><span class="line">        removeNode(res);    <span class="comment">// 删除节点</span></span><br><span class="line">        <span class="keyword">return</span> res;         <span class="comment">// 返回该节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="155-最小栈"><a class="markdownIt-Anchor" href="#155-最小栈"></a> 155. 最小栈</h1>
<p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">LeetCode 155. 最小栈</a></p>
<h2 id="栈辅助栈"><a class="markdownIt-Anchor" href="#栈辅助栈"></a> 栈+辅助栈</h2>
<p>官方提供的<a href="https://leetcode-cn.com/problems/min-stack/solution/zui-xiao-zhan-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>，比我最开始自己写的辅助栈要好多了。</p>
<p>常规解法，一个栈stack来实现push、pop和top操作，另一个辅助栈min_stack用来实现getMin。大体思路是：</p>
<ul>
<li>每次push的时候，stack正常push，<strong>min_stack则push进目前stack的最小值</strong></li>
<li>每次pop的时候，stack和min_stack都要执行pop操作</li>
</ul>
<p>看个动图就能搞懂：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220713181208.gif" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayDeque&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">public</span> ArrayDeque&lt;Integer&gt; min_stack;  <span class="comment">// 辅助栈(用来实现getMin方法)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        min_stack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        min_stack.addLast(Integer.MAX_VALUE);  <span class="comment">// 初始化的时候就push一个Max值，方便后续操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        stack.addLast(val);</span><br><span class="line">        min_stack.addLast(Math.min(val,min_stack.getLast()));  <span class="comment">// 辅助栈push stack中最小的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.removeLast();</span><br><span class="line">        min_stack.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单链表-3"><a class="markdownIt-Anchor" href="#单链表-3"></a> 单链表</h2>
<p>搬运自英文网站的高票解。</p>
<p>链表的节点包含以下信息：</p>
<ul>
<li><strong>该节点值value</strong></li>
<li><strong>该节点及以后（类似于栈中从某元素到栈底）的最小值min</strong></li>
<li><strong>节点指向的下一个节点next</strong></li>
</ul>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153043.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(value,min,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> min, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.min = min;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123; <span class="comment">// 这里什么都不要做，不要初始化head！</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)&#123;    <span class="comment">// 栈为空，直接push，min即为该节点的value</span></span><br><span class="line">            head = <span class="keyword">new</span> Node(val,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 栈已经有元素了，需要判断一下min该怎么取</span></span><br><span class="line">            head = <span class="keyword">new</span> Node(val, Math.min(val, head.min),head);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表"></a> 160. 相交链表</h1>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">LeetCode 160. 相交链表</a></p>
<h2 id="哈希表-5"><a class="markdownIt-Anchor" href="#哈希表-5"></a> 哈希表</h2>
<p>使用哈希表是可以过的，思路比较清晰，但是效率比较低下。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            set.add(p1);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(p2))&#123;</span><br><span class="line">                <span class="keyword">return</span> p2;</span><br><span class="line">            &#125;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(m+n)。m和n分别为链表headA和headB的长度。</li>
<li>空间复杂度：O(m)。m为链表headA的长度.需要用哈希表来存储headA链表的全部节点。</li>
</ul>
<p>结果如下：<code>解答成功:执行耗时:5 ms,击败了24.12% 的Java用户，内存消耗:44.2 MB,击败了32.56% 的Java用户</code></p>
</blockquote>
<h2 id="双指针空间复杂度o1"><a class="markdownIt-Anchor" href="#双指针空间复杂度o1"></a> 双指针（空间复杂度O(1)）</h2>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/" target="_blank" rel="noopener">官方题解</a></p>
<p>其实原理很好懂，就是可能很难想到。（<code>a+b=b+a</code>）</p>
<p>首先定义两个指针<code>p1</code>，<code>p2</code>，分别指向<code>headA</code>和<code>headB</code>。特殊情况判断：当<code>p1</code>或者<code>p2</code>为空时，两个链表肯定不会相交，返回<code>null</code>。</p>
<p>接下来开始遍历<code>p1</code>，<code>p2</code>指针：</p>
<ul>
<li>当<code>p1</code>和<code>p2</code>指向的节点一样时，说明两个链表相交了；</li>
<li><strong>当<code>p1</code>为空时，<code>p1</code>指向<code>headB</code>；</strong></li>
<li><strong>当<code>p2</code>为空时，<code>p2</code>指向<code>headA</code>；</strong></li>
<li>当<code>p1</code>和<code>p2</code>节点下一个<strong>都为空</strong>时，遍历结束，说明两个链表没有相交，返回<code>null</code>。</li>
</ul>
<p>思路很好理解，画一下图甚至看一下图就能搞懂了。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153106.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (p1!=<span class="keyword">null</span> || p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1==<span class="keyword">null</span>)&#123;</span><br><span class="line">                p1 = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p2==<span class="keyword">null</span>)&#123;</span><br><span class="line">                p2 = headA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1==p2)&#123;</span><br><span class="line">                <span class="keyword">return</span> p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(m+n)。m和n分别为链表headA和headB的长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<p>结果为：<code>解答成功:执行耗时:1 ms,击败了99.16% 的Java用户，内存消耗:44.6 MB,击败了5.12% 的Java用户</code></p>
</blockquote>
<h1 id="169-多数元素"><a class="markdownIt-Anchor" href="#169-多数元素"></a> 169. 多数元素</h1>
<p><a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">LeetCode 169. 多数元素</a></p>
<h2 id="hashmap-2"><a class="markdownIt-Anchor" href="#hashmap-2"></a> HashMap</h2>
<p>一看到要统计数组各个数出现次数的相关题目，第一想法就是使用HashMap。这题使用HashMap的思路也比较简单。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue()&gt;nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                ans = entry.getKey();</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:13 ms,击败了20.52% 的Java用户,内存消耗:46.6 MB,击败了4.99% 的Java用户</code></p>
</blockquote>
<h2 id="分治算法-2"><a class="markdownIt-Anchor" href="#分治算法-2"></a> 分治算法</h2>
<p><a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<blockquote>
<p>数学知识：如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。</p>
<p>我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 <code>l / 2</code> + <code>r / 2</code> 次，其中 l 和 r 分别是左半部分和右半部分的长度。由于 <code>l / 2 + r / 2</code> &lt;= <code>(l + r) / 2</code>，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。</p>
</blockquote>
<p>这样以来，我们就可以使用<strong>分治法</strong>解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p>
<p>我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。</p>
<ul>
<li>长度为 1 的子数组中唯一的数显然是众数，直接返回即可。</li>
<li><strong>如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并</strong>：
<ul>
<li>如果它们的<strong>众数相同</strong>，那么显然这一段区间的众数是它们相同的值；</li>
<li>否则，我们需要<strong>比较两个众数在整个区间内出现的次数来决定该区间的众数</strong>。</li>
</ul>
</li>
</ul>
<p>初看比较绕，结合草稿和代码应该会比较清晰了：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153131.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> majorityElementRec(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分治法递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 题目所给数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l 左边开始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 右边结束索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回l-r区间内的多数元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">majorityElementRec</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l==r)&#123;  <span class="comment">// base case，只有一个元素就返回这个元素</span></span><br><span class="line">            <span class="keyword">return</span> nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不止一个元素，就进行分治</span></span><br><span class="line">        <span class="keyword">int</span> mid = (r - l) / <span class="number">2</span> + l;  <span class="comment">// 分治后的中间位置索引</span></span><br><span class="line">        <span class="keyword">int</span> left = majorityElementRec(nums, l, mid);    <span class="comment">// 左区间多数元素</span></span><br><span class="line">        <span class="keyword">int</span> right = majorityElementRec(nums, mid+<span class="number">1</span>, r);    <span class="comment">// 右区间多数元素</span></span><br><span class="line">        <span class="keyword">if</span> (left==right)&#123;   <span class="comment">// 两个区间多数元素相等，则合并后的区间多数元素也是这个</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个区间多数元素不相等，那么就要比较合并后的区间中这两个数哪个更多了</span></span><br><span class="line">        <span class="keyword">int</span> leftCount = countInRange(nums,left,l,r);</span><br><span class="line">        <span class="keyword">int</span> rightCount = countInRange(nums,right,l,r);</span><br><span class="line">        <span class="keyword">return</span> leftCount&gt;rightCount? left:right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计一段区间内某个数出现的次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 所给数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 所指定的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l 区间左边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 区间右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回该数在该区间的出现次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countInRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==num)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:1 ms,击败了99.92% 的Java用户,内存消耗:44.6 MB,击败了26.50% 的Java用户</code></p>
</blockquote>
<h1 id="179-最大数"><a class="markdownIt-Anchor" href="#179-最大数"></a> 179. 最大数</h1>
<p><a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener">LeetCode 179. 最大数</a></p>
<h2 id="贪心优先队列"><a class="markdownIt-Anchor" href="#贪心优先队列"></a> 贪心+优先队列</h2>
<p>由<a href="https://leetcode-cn.com/problems/largest-number/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-vn86e/" target="_blank" rel="noopener">宫水三叶</a>大佬提供的题解。</p>
<blockquote>
<p>对于 numsnums 中的任意两个值 aa 和 bb，我们无法直接从常规角度上确定其大小/先后关系。但我们可以<strong>根据「结果」来决定 aa 和 bb 的排序关系</strong>：</p>
<p><strong>如果拼接结果 abab 要比 baba 好，那么我们会认为 aa 应该放在 bb 前面</strong>。</p>
<p>另外，<strong>注意我们需要处理前导零</strong>（最多保留一位）。</p>
</blockquote>
<p>这题如果没有想到好的方向，似乎挺难的。但是如果想对方向了，似乎思路也挺简单的。</p>
<p>这题主要用到的数据结构为<strong>优先队列</strong>，贪心思想主要体现在自定义比较器<strong>Comparator</strong>中。</p>
<p>根据结果来确定排序，直接上代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义排序规则</span></span><br><span class="line">Comparator&lt;String&gt; comparator = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        String o1 = s1 + s2;</span><br><span class="line">        String o2 = s2 + s1;</span><br><span class="line">        <span class="comment">// o2.compareTo(o1)&gt;0，说明字符串o2大于o1，s1和s2要交换顺序(实现类似降序排列)</span></span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>给个例子：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153157.png" alt="" /></p>
<p>排序规则写好后，使用优先队列来求解就非常简单了：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153213.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 自定义排序规则</span></span><br><span class="line">        Comparator&lt;String&gt; comparator = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                String o1 = s1 + s2;</span><br><span class="line">                String o2 = s2 + s1;</span><br><span class="line">                <span class="comment">// o2.compareTo(o1)&gt;0，说明字符串o2大于o1，s1和s2要交换顺序(实现类似降序排列)</span></span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        PriorityQueue&lt;String&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(comparator);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;  <span class="comment">// 入队</span></span><br><span class="line">            priorityQueue.add(String.valueOf(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            stringBuilder.append(priorityQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面的处理是为了消去结果前面的0，比如说测试用例：[0,0,0],应该返回0而不是000</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(stringBuilder);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (stringBuilder.charAt(k)==<span class="string">'0'</span>&amp;&amp;k&lt;stringBuilder.length()-<span class="number">1</span>)&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后k即为第一个非0字符所在索引</span></span><br><span class="line">        <span class="keyword">return</span> stringBuilder.substring(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>时间复杂度：由于是对 StringString 进行排序，当排序对象不是 JavaJava 中的基本数据类型时，不会使用快排（考虑排序稳定性问题）。Arrays.sort() 的底层实现会「元素数量/元素是否大致有序」决定是使用插入排序还是归并排序。这里直接假定使用的是「插入排序」。复杂度为 O(n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
</blockquote>
<p>我最开始是看的<a href="https://leetcode-cn.com/problems/largest-number/solution/you-xian-dui-lie-tan-xin-jian-zhi-chao-g-ufna/" target="_blank" rel="noopener">开心</a>大佬提供的题解，打下草稿发现大致思路跟上面一样</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 自定义排序规则</span></span><br><span class="line">        Comparator&lt;String&gt; comparator = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">char</span> a,b;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length()+s2.length(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i&lt;s1.length())&#123;</span><br><span class="line">                        a = s1.charAt(i);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        a = s2.charAt(i-s1.length());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i&lt;s2.length())&#123;</span><br><span class="line">                        b = s2.charAt(i);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        b = s1.charAt(i-s2.length());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (a!=b)&#123; <span class="comment">// 在从第一位比较的过程中，只要发现a和b不相同，return b-a</span></span><br><span class="line">                        <span class="keyword">return</span> b-a;     <span class="comment">// 按照(类似)降序排列，所以是b-a</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 循环结束后还没有判断出s1和s2的排序，return 0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        PriorityQueue&lt;String&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(comparator);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;  <span class="comment">// 入队</span></span><br><span class="line">            priorityQueue.add(String.valueOf(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            stringBuilder.append(priorityQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        String s = <span class="keyword">new</span> String(stringBuilder);</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>)==<span class="string">'0'</span>)&#123;  <span class="comment">// 对于特殊用例：[0,0]，应该输出0而不是00</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</blockquote>
<h1 id="191-位1的个数"><a class="markdownIt-Anchor" href="#191-位1的个数"></a> 191. 位1的个数</h1>
<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode 191. 位1的个数</a></p>
<h2 id="位运算-2"><a class="markdownIt-Anchor" href="#位运算-2"></a> 位运算</h2>
<p>这题在写过<a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/" target="_blank" rel="noopener">LeetCode 1601. 最多可达成的换楼请求数目</a>之后就非常简单了。在那题中，此题只是其中一个方法。</p>
<blockquote>
<p>观察这个运算： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n \&amp;(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，<strong>其运算结果恰为把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的二进制位中的最低位的 1 变为 0 之后的结果。</strong><br />
如: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mn>6</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo>=</mo><mo stretchy="false">(</mo><mn>110</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo separator="true">,</mo><mn>4</mn><mo>=</mo><mo stretchy="false">(</mo><mn>100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">6 \&amp;(6-1)=4,6=(110)_{2}, 4=(100)_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后 的结果。</p>
</blockquote>
<p>在位运算中用到了<code>lowbit</code> 运算。具体体现在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num; i != <span class="number">0</span>; i = i&amp;(i-<span class="number">1</span>)) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lowbit</code>还有另一种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num; i != <span class="number">0</span>; i = i-(i&amp;-i)) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/lesileqin/article/details/102418143" target="_blank" rel="noopener">【位运算】深入理解并证明 lowbit 运算</a></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i != <span class="number">0</span>; i = i&amp;(i-<span class="number">1</span>)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> 200. 岛屿数量</h1>
<p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">LeetCode 200. 岛屿数量</a></p>
<h2 id="深度优先搜索dfs-5"><a class="markdownIt-Anchor" href="#深度优先搜索dfs-5"></a> 深度优先搜索（DFS）</h2>
<p><strong><a href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/" target="_blank" rel="noopener">岛屿类问题的通用解法、DFS 遍历框架</a></strong></p>
<p>具体思路大佬题解中已经说的非常详细了，这里注意一下：</p>
<ul>
<li>0：海洋格子</li>
<li>1：陆地格子（未遍历过）</li>
<li>2：陆地格子（已遍历过）</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 双层for循环，其实就是遍历每一个网格(r行c列)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; grid.length; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    dfs(grid,r,c);  <span class="comment">// 发现还未遍历过的陆地，开始深度优先搜索进行遍历</span></span><br><span class="line">                    count++;    <span class="comment">// 深度优先搜索结束后，岛屿数量+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网格的深度优先搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断 base case</span></span><br><span class="line">        <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">        <span class="comment">// 如果不是陆地，也直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!inArea(grid, r, c) || grid[r][c]==<span class="string">'0'</span> || grid[r][c]==<span class="string">'2'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="string">'2'</span>;     <span class="comment">// 标记为已经遍历过的陆地</span></span><br><span class="line">        <span class="comment">// 开始网格的深度优先搜索（上下左右）</span></span><br><span class="line">        dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断坐标(r,c)是否超出了grid的范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (r&gt;=<span class="number">0</span> &amp;&amp; r&lt;grid.length) &amp;&amp; (c&gt;=<span class="number">0</span> &amp;&amp; c&lt;grid[<span class="number">0</span>].length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="203-移除链表元素"><a class="markdownIt-Anchor" href="#203-移除链表元素"></a> 203. 移除链表元素</h1>
<p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">LeetCode 203. 移除链表元素</a></p>
<h2 id="双指针-6"><a class="markdownIt-Anchor" href="#双指针-6"></a> 双指针</h2>
<p>首先还是定义<code>dummyNode</code>，<code>dummyNode.next = head;</code>。这种处理在单链表中已经是很常见了（即区别于头结点和首元节点）。</p>
<p>定义两个指针。<code>p1</code>初始指向<code>dummyNode</code>，<code>p2</code>初始指向<code>head</code>。接下来<code>p2</code>开始遍历单链表知道尽头：</p>
<ul>
<li>如果<code>p2</code>所指节点的<code>val</code>不为指定值：<code>p1</code>和<code>p2</code>都向后移动一个节点</li>
<li>如果<code>p2</code>所指节点的<code>val</code>为指定值：<code>p2</code>继续移动直到<code>p2</code>所指节点不为<code>val</code>，此时令<code>p1.next = p2</code>。</li>
</ul>
<p>打下草稿就能搞懂。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        ListNode p1 = dummyNode;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p2.val!=val)&#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2!=<span class="keyword">null</span> &amp;&amp; p2.val == val)&#123;</span><br><span class="line">                    p2 = p2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                p1.next = p2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> 206. 反转链表</h1>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode 206. 反转链表</a></p>
<h2 id="单链表-4"><a class="markdownIt-Anchor" href="#单链表-4"></a> 单链表</h2>
<p>反转链表在之前的数据结构学习中就已经实现过了，可以参考<a href="https://www.qingbo1011.top/2021/08/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#linkedlist%E7%9A%84%E5%AE%9E%E7%8E%B0">笔记</a>。这题本身也是个简单题，直接给出代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = pre; <span class="comment">// 修改结点指向</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="215-数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#215-数组中的第k个最大元素"></a> 215. 数组中的第K个最大元素</h1>
<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">LeetCode 215. 数组中的第K个最大元素</a></p>
<h1 id="217-存在重复元素"><a class="markdownIt-Anchor" href="#217-存在重复元素"></a> 217. 存在重复元素</h1>
<h2 id="哈希表-6"><a class="markdownIt-Anchor" href="#哈希表-6"></a> 哈希表</h2>
<p>这题使用哈希表来求解，思路就非常简单了。直接给出代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 将nums按升序排序</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">/* 若向HashSet中插入重复元素，则返回false</span></span><br><span class="line"><span class="comment">            hashSet.add(nums[i])为真，即没有重复元素</span></span><br><span class="line"><span class="comment">            所以我们条件为!hashSet.add(nums[i])，有重复元素，返回true*/</span></span><br><span class="line">            <span class="keyword">if</span> (!hashSet.add(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最开始我是这么写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 将nums按升序排序</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashSet.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是运行结果为：<code>解答成功:执行耗时:9 ms,击败了7.65% 的Java用户，内存消耗:43.9 MB,击败了37.45% 的Java用户</code>。于是我把代码改成上述代码，结果为：<code>解答成功:执行耗时:7 ms,击败了29.90% 的Java用户，内存消耗:42.6 MB,击败了40.24% 的Java用户</code>。</p>
</blockquote>
<h1 id="225-用队列实现栈"><a class="markdownIt-Anchor" href="#225-用队列实现栈"></a> 225. 用队列实现栈</h1>
<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">LeetCode 225. 用队列实现栈</a></p>
<h2 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h2>
<p>比较简单。主要是要熟悉队列和栈这种数据结构，以及在Java中对应的集合类。通常，<strong>我们在Java中都会用ArrayDeque来实现栈和队列</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        deque.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="226-翻转二叉树"><a class="markdownIt-Anchor" href="#226-翻转二叉树"></a> 226. 翻转二叉树</h1>
<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">LeetCode 226. 翻转二叉树</a></p>
<h1 id="232-用栈实现队列"><a class="markdownIt-Anchor" href="#232-用栈实现队列"></a> 232. 用栈实现队列</h1>
<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">LeetCode 232. 用栈实现队列</a></p>
<h2 id="栈入队on-出队o1"><a class="markdownIt-Anchor" href="#栈入队on-出队o1"></a> 栈(入队：O(n)， 出队：O(1))</h2>
<p><strong>入队：O(n)， 出队：O(1)</strong></p>
<p>用栈来实现队列，只是在<strong>push</strong>的时候有点麻烦，需要用到一个辅助栈。处理push的逻辑目的只有一个：<strong>要保证栈顶是队头，栈底是队尾</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;Integer&gt; deque;  <span class="comment">// 在后面的逻辑中，要保证栈顶是队头，栈底是队尾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();    <span class="comment">// 辅助栈</span></span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty())&#123;</span><br><span class="line">            deque2.push(deque.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后将x元素push到deque中，这是x即为deque队尾</span></span><br><span class="line">        deque.push(x);</span><br><span class="line">        <span class="comment">// 最后将辅助栈中的元素push回deque中</span></span><br><span class="line">        <span class="keyword">while</span> (!deque2.isEmpty())&#123;</span><br><span class="line">            deque.push(deque2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈进阶入队o1出队摊还复杂度-o1"><a class="markdownIt-Anchor" href="#栈进阶入队o1出队摊还复杂度-o1"></a> 栈（进阶：入队：O(1)，出队：摊还复杂度 O(1)）</h2>
<p><strong>入队：O(1)，出队：摊还复杂度 O(1)</strong></p>
<p>来自<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/" target="_blank" rel="noopener">官方题解</a>提供的方法二。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;Integer&gt; deque1;</span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;Integer&gt; deque2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;  <span class="comment">// 队头元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        deque1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        deque2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (deque1.isEmpty())&#123;</span><br><span class="line">            front = x;</span><br><span class="line">        &#125;</span><br><span class="line">        deque1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (deque2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque1.isEmpty())</span><br><span class="line">                deque2.push(deque1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!deque2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> deque2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque1.isEmpty()&amp;&amp; deque2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> 239. 滑动窗口最大值</h1>
<p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">LeetCode 239. 滑动窗口最大值</a></p>
<h2 id="单调队列"><a class="markdownIt-Anchor" href="#单调队列"></a> 单调队列</h2>
<p>关于单调队列这种数据结构，我们在之前的<a href="https://www.qingbo1011.top/2021/08/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">笔记</a>中有简单提到过。<strong>单调队列经常用来解决数组滑动窗口的最值问题</strong>。</p>
<p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/dong-hua-yan-shi-dan-diao-dui-lie-239hua-hc5u/" target="_blank" rel="noopener">动画演示 单调队列 239.滑动窗口最大值</a></p>
<p>大佬给出的题解中动画演示已经非常清晰了，这里给出关键的总结如下：</p>
<ul>
<li>遍历给定数组中的元素，<strong>如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除</strong>（<code>pollLast()</code>）。直到，队列为空或当前考察元素小于新的队尾元素（<strong>要保证是单调递减队列</strong>）；</li>
<li>当队首元素的下标小于滑动窗口左侧边界left时，表示队首元素已经不再滑动窗口内，因此将其从队首移除。（<code>poll()</code> ）</li>
<li>由于数组下标从0开始，因此<strong>当窗口右边界right+1大于等于窗口大小k时，意味着窗口形成</strong>。此时，<strong>队首元素就是该窗口内的最大值</strong>。（<code>peek()</code>）</li>
</ul>
<p>注意：<strong>在单调队列中，我们存储的不是nums数组中元素的值，而是nums元素的下标值！</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 用LinkedList来实现双端队列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义左下标和右下标</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right;</span><br><span class="line">        <span class="comment">// 下面的代码中，left表示左下标，right表示右下标</span></span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。</span></span><br><span class="line">            <span class="comment">// 直到，队列为空或当前考察元素小于新的队尾元素</span></span><br><span class="line">            <span class="comment">// 注意这里要用while而不是if,因为要保证是单调递减队列</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty()&amp;&amp;nums[right]&gt;=nums[deque.peekLast()])&#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(right); <span class="comment">// 存储符合规则的元素下标,注意这里存储的是元素下标</span></span><br><span class="line">            <span class="comment">// 如果右下标right大于等于k-1，说明窗口形成(当right为k-1时，left正好为0)</span></span><br><span class="line">            <span class="keyword">if</span> (right&gt;=k-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 当队首元素的下标小于滑动窗口左侧边界left时，表示队首元素已经不再滑动窗口内，因此将其从队首移除</span></span><br><span class="line">                <span class="keyword">if</span> (deque.peek()&lt;left)&#123;</span><br><span class="line">                    deque.poll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不满足上述if条件，则说明队首元素的下标是在窗口内，而我们又保证了该队列是单调递减队列</span></span><br><span class="line">                <span class="comment">// 直接将队首元素放到result数组中即可</span></span><br><span class="line">                result[left] = nums[deque.peek()];</span><br><span class="line">                <span class="comment">// 当窗口形成后，right++的同时left也要++</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：<code>解答成功:执行耗时:27 ms,击败了93.78% 的Java用户，内存消耗:49.9 MB,击败了99.23% 的Java用户</code></p>
<h1 id="242-有效的字母异位词"><a class="markdownIt-Anchor" href="#242-有效的字母异位词"></a> 242. 有效的字母异位词</h1>
<p><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">LeetCode 242. 有效的字母异位词</a></p>
<h2 id="数组-3"><a class="markdownIt-Anchor" href="#数组-3"></a> 数组</h2>
<p>全是小写字母，使用数组来处理这种方式已经非常熟悉了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr_s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] arr_t = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            arr_s[s.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            arr_t[t.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_s[i]!=arr_t[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="258-各位相加"><a class="markdownIt-Anchor" href="#258-各位相加"></a> 258. 各位相加</h1>
<p><a href="https://leetcode-cn.com/problems/add-digits/" target="_blank" rel="noopener">LeetCode 258. 各位相加</a></p>
<h2 id="模拟-2"><a class="markdownIt-Anchor" href="#模拟-2"></a> 模拟</h2>
<p>根据题意，将给定的num的各个位的值一个一个相加即可。这里的代码处理是：先将<code>num%10</code>得到最低位，然后<code>num = num/10</code>。直到<code>num</code>为0。思路很清晰，主要就是<strong>代码实现num的每一位的相加</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num&gt;=<span class="number">10</span>)&#123;    <span class="comment">// 需要进行各位的相加</span></span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (num&gt;<span class="number">0</span>)&#123;  <span class="comment">// num各位相加的代码实现</span></span><br><span class="line">                temp = temp+num%<span class="number">10</span>;</span><br><span class="line">                num = num/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = temp; <span class="comment">// num更新为各位相加之后的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(logn)。n为给定的num值。对于num 计算一次各位相加需要 O(logn) 的时间，由于num <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\leq 2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因此对于 num 计算一次各位相加的最大可能结果是 82，对于任意两位数最多只需要计算两次各位相加的结果即可得到一位数。</li>
<li>空间复杂度：O(1)</li>
</ul>
</blockquote>
<h2 id="数学双o1"><a class="markdownIt-Anchor" href="#数学双o1"></a> 数学（双O(1)）</h2>
<p><a href="https://leetcode-cn.com/problems/add-digits/solution/ge-wei-xiang-jia-by-leetcode-solution-u4kj/" target="_blank" rel="noopener">官方题解</a></p>
<p>这道题的本质是计算自然数num的数根。</p>
<blockquote>
<p>数根又称数字根（Digital root），是自然数的一种性质，每个自然数都有一个数根。对于给定的自然数，反复将各个位上的数字相加，直到结果为一位数，则该一位数即为原自然数的数根。</p>
</blockquote>
<p><strong>我们利用自然数的性质，则能在 O(1) 的时间内计算数根。</strong></p>
<p>假设整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">n u m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 的十进制表示有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 位，从最低位到最高位依次是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> ，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">n u m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 可以 写成如下形式:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext> num </mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>a</mi><mi>i</mi></msub><mo>×</mo><mn>1</mn><msup><mn>0</mn><mi>i</mi></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>a</mi><mi>i</mi></msub><mo>×</mo><mrow><mo fence="true">(</mo><mn>1</mn><msup><mn>0</mn><mi>i</mi></msup><mo>−</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>a</mi><mi>i</mi></msub><mo>×</mo><mrow><mo fence="true">(</mo><mn>1</mn><msup><mn>0</mn><mi>i</mi></msup><mo>−</mo><mn>1</mn><mo fence="true">)</mo></mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>a</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text { num } &amp;=\sum_{i=0}^{n-1} a_{i} \times 10^{i} \\
&amp;=\sum_{i=0}^{n-1} a_{i} \times\left(10^{i}-1+1\right) \\
&amp;=\sum_{i=0}^{n-1} a_{i} \times\left(10^{i}-1\right)+\sum_{i=0}^{n-1} a_{i}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:10.136346000000001em;vertical-align:-4.818173000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.318173000000001em;"><span style="top:-7.318173000000001em;"><span class="pstrut" style="height:3.8011130000000004em;"></span><span class="mord"><span class="mord text"><span class="mord"> num </span></span></span></span><span style="top:-3.9393910000000005em;"><span class="pstrut" style="height:3.8011130000000004em;"></span><span class="mord"></span></span><span style="top:-0.5606089999999997em;"><span class="pstrut" style="height:3.8011130000000004em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.818173000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.318173000000001em;"><span style="top:-7.318173000000001em;"><span class="pstrut" style="height:3.8011130000000004em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.9393910000000005em;"><span class="pstrut" style="height:3.8011130000000004em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span><span style="top:-0.5606089999999997em;"><span class="pstrut" style="height:3.8011130000000004em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.818173000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mi>i</mi></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">10^{i}-1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 是 9 的倍数；当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 是正整数时， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mi>i</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">10^{i}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 是由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 位 9 组成的整数， 也是 9 的倍数。因此对于任意非负整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mi>i</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i, 10^{i}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.019104em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 都是 9 的倍数。由此可得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">n u m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 与其各位相加的结果模 9 同余。（即num和num各位之和<code>%9</code>的结果<strong>是一样的</strong>。比如说：<code>38%9=2</code>,<code>11%9=2</code>）</p>
<p>重复计算各位相加的结果直到结果为一位数时，该一位数即为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">n u m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 的数根，<strong><mark>num 与其数根模 9 同余</mark></strong>。</p>
<p><strong>我们对 num 分类讨论：</strong></p>
<ul>
<li><strong>num 不是 9 的倍数时，其数根即为 num 除以 9 的余数</strong>。</li>
<li><strong>num 是 9 的倍数时：</strong>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n u m=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，则其数根是 0 ；</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n u m&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，则各位相加的结果大于 0 ，其数根也大于 0 ，因此其数根是 9</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num%<span class="number">9</span>!=<span class="number">0</span>)&#123;  <span class="comment">// num不是9的倍数</span></span><br><span class="line">            <span class="keyword">return</span> num%<span class="number">9</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num==<span class="number">0</span>? <span class="number">0</span>:<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="316-去除重复字母"><a class="markdownIt-Anchor" href="#316-去除重复字母"></a> 316. 去除重复字母</h1>
<p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">LeetCode 316. 去除重复字母</a></p>
<blockquote>
<p>注意：该题与<a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/" target="_blank" rel="noopener">1081. 不同字符的最小子序列</a>相同。</p>
</blockquote>
<h2 id="单调栈-4"><a class="markdownIt-Anchor" href="#单调栈-4"></a> 单调栈</h2>
<p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/" target="_blank" rel="noopener"><strong>官方题解（含视频）</strong></a></p>
<p>这题感觉如果没有正确的方向的话是挺难的。官方提供的题解已经说的很好了，这里我用自己的语言分析一下。</p>
<p>要解决这个问题，需要用到：</p>
<ul>
<li>一个<strong>单调栈</strong>：<strong>为什么要用单调栈呢，因为要保证栈中的结果永远都是字典序最小</strong></li>
<li>两个数组：<strong>lastIndex数组存储字符串s中各个字母出现的最后一个位置</strong>，<strong>visited数组存储各个字符是否已经存在于栈中</strong></li>
</ul>
<p>接下来就可以遍历字符串s，分析一下单调栈的存储过程：</p>
<ul>
<li>
<p>首先，<strong>先判断当前字符是否已经存在于栈中</strong>，如果已经存在，什么都不做开始遍历下一个字符（<code>continue</code>）</p>
</li>
<li>
<p>如果该字符不存在与栈中（这里用<code>while</code>）：</p>
<ul>
<li>
<p>那么就先<strong>判断遍历的字符是否大于栈顶元素top</strong>，如果遍历的字符大于栈顶字符top，那么就无需执行下面的操作，直接跳出while循环</p>
</li>
<li>
<p>如果字符小于栈顶元素top，那么就<strong>先判断栈的栈顶元素top是否还会再次出现</strong>（<code>i&lt;lastIndex[top-'a']</code>），如果top字符在字符串s后面的遍历中还会出现的话，那么就pop出该栈顶元素，同时在visited数组中设置该字符不存在于栈中（<code>visited[top-'a']=false</code>）</p>
<p>。接着继续拿遍历的字符跟<strong>新的栈顶元素</strong>进行上述比较（同样要<strong>先判断遍历的字符是否大于栈顶元素top</strong>，<strong>再判断栈的栈顶元素top是否还会再次出现</strong>）（这么做是为了<strong>保证栈中的结果永远都是字典序最小</strong>，所以要用<code>while</code>）</p>
</li>
<li>
<p><strong>while循环结束后</strong>，将该字符push到栈中，同时在visited数组中设置该字符已经存在于栈中</p>
<p>（<code>visited[charArray[i]-'a']=true</code>）</p>
</li>
</ul>
</li>
<li>
<p>字符串s遍历之后，栈中从栈底到栈顶的顺序即为我们的结果</p>
</li>
</ul>
<p>光看文字描述可能很迷糊，但光看代码也会很迷糊，文字结合代码一起看应该就比较清晰了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 一个单调栈，两个数组</span></span><br><span class="line">        ArrayDeque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">// 题目已经说了都是小写，所以长度为26</span></span><br><span class="line">        <span class="keyword">int</span>[] lastIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];  <span class="comment">// 存储字符串中字母出现的最后一个位置</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];    <span class="comment">// 存储a-z这26个字母是否已经存在于栈中</span></span><br><span class="line">        <span class="comment">// 这个循环结束后，lastIndex数组即成功存储到a-z(0-25)的字母在字符串s中出现的最后位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            lastIndex[charArray[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 准备工作都已完毕，接下来就可以开始遍历字符串s了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[charArray[i]-<span class="string">'a'</span>])&#123; <span class="comment">// 字母已经存在与栈中，直接continue</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意while循环中还要加上stack不为空</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; charArray[i]&lt;stack.peekLast() &amp;&amp; i&lt;lastIndex[stack.peekLast()-<span class="string">'a'</span>])&#123;</span><br><span class="line">                Character top = stack.removeLast();</span><br><span class="line">                visited[top-<span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(charArray[i]);</span><br><span class="line">            visited[charArray[i]-<span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历结束后，栈中结果即字典序最小</span></span><br><span class="line">        <span class="comment">// 因为我们使用ArrayDeque来模拟栈，所以当然可以直接遍历ArrayDeque</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Character character : stack) &#123;</span><br><span class="line">            stringBuilder.append(character);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>时间复杂度：O(n)，n为字符串s的长度</li>
<li>空间复杂度：O(n)，栈的最大深度</li>
</ul>
</blockquote>
<h1 id="341-扁平化嵌套列表迭代器"><a class="markdownIt-Anchor" href="#341-扁平化嵌套列表迭代器"></a> 341. 扁平化嵌套列表迭代器</h1>
<p><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">LeetCode 341. 扁平化嵌套列表迭代器</a></p>
<h2 id="深度优先搜索dfs-6"><a class="markdownIt-Anchor" href="#深度优先搜索dfs-6"></a> 深度优先搜索（DFS）</h2>
<p><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/bian-ping-hua-qian-tao-lie-biao-die-dai-ipjzq/" target="_blank" rel="noopener">官方题解</a></p>
<p>关键要看懂题目给定的接口<code>NestedInteger</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment">// You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedInteger</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line">    <span class="comment">// Return null if this NestedInteger holds a nested list</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line">     <span class="comment">// Return empty list if this NestedInteger holds a single integer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定了三个方法：</p>
<ul>
<li><code>public boolean isInteger()</code>：如果是single integer，返回true；否则返回false</li>
<li><code>public Integer getInteger()</code>：返回当前integer</li>
<li><code>public List&lt;NestedInteger&gt; getList()</code>：返回当前list</li>
</ul>
<p>搞清楚了这三个方法的作用，题解就很好写了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; values;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Integer&gt; cur;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        values = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        dfs(nestedList);</span><br><span class="line">        cur = values.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger nestedInteger : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nestedInteger.isInteger())&#123;</span><br><span class="line">                values.add(nestedInteger.getInteger());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(nestedInteger.getList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur.hasNext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>时间复杂度：<code>dfs()</code>为O(n)，<code>next()</code>和<code>hasNext()</code>为O(1)。其中n是嵌套的整形列表中的元素个数。</li>
<li>空间复杂度：O(n)。需要一个数组存储嵌套的整形列表中的所有元素。</li>
</ul>
</blockquote>
<h1 id="349-两个数组的交集"><a class="markdownIt-Anchor" href="#349-两个数组的交集"></a> 349. 两个数组的交集</h1>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">LeetCode 349. 两个数组的交集</a></p>
<h2 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h2>
<p>用两个HashSet就能解决这个问题。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;<span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            set2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size1 = set1.size();</span><br><span class="line">        <span class="keyword">int</span> size2 = set2.size();</span><br><span class="line">        <span class="keyword">if</span> (size1&gt;size2)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer integer : set1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set2.contains(integer))&#123;</span><br><span class="line">                    list.add(integer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer integer : set2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set1.contains(integer))&#123;</span><br><span class="line">                    list.add(integer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="350-两个数组的交集-ii"><a class="markdownIt-Anchor" href="#350-两个数组的交集-ii"></a> 350. 两个数组的交集 II</h1>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">LeetCode 350. 两个数组的交集 II</a></p>
<h2 id="hashmap-3"><a class="markdownIt-Anchor" href="#hashmap-3"></a> HashMap</h2>
<p>使用两个HashMap解决。思路也比较清晰，<code>key</code>表示数组中的元素，<code>value</code>表示该元素在数组中出现的次数。可能代码看起来比较麻烦。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map1.containsKey(num))&#123;</span><br><span class="line">                map1.put(num,map1.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map1.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map2.containsKey(num))&#123;</span><br><span class="line">                map2.put(num,map2.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map2.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size1 = map1.size();</span><br><span class="line">        <span class="keyword">int</span> size2 = map2.size();</span><br><span class="line">        <span class="keyword">if</span> (size1&gt;size2)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map1.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map2.containsKey(entry.getKey()))&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(entry.getValue(), map2.get(entry.getKey())); i++) &#123;</span><br><span class="line">                        list.add(entry.getKey());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map2.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map1.containsKey(entry.getKey()))&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(entry.getValue(), map1.get(entry.getKey())); i++) &#123;</span><br><span class="line">                        list.add(entry.getKey());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我自己写的比较繁琐，下面看一下<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a>。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153300.gif" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans[index] = num;</span><br><span class="line">                index++;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(num, count);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：<code>O(m+n)</code>，其中 <code>m</code>和 <code>n</code> 分别是两个数组的长度。需要遍历两个数组并对哈希表进行操作，哈希表操作的时间复杂度是 O(1)，因此总时间复杂度与两个数组的长度和呈线性关系。</li>
<li>空间复杂度：空间复杂度：<code>O(min(m,n))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个数组的长度。对较短的数组进行哈希表的操作，哈希表的大小不会超过较短的数组的长度。为返回值创建一个数组 ans，其长度为较短的数组的长度。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="排序双指针"><a class="markdownIt-Anchor" href="#排序双指针"></a> 排序+双指针</h2>
<blockquote>
<p>对应进阶提问中：如果给定的数组已经排好序呢？你将如何优化你的算法？</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p>
<p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</p>
<p>初始时，两个指针分别指向两个数组的头部，每次比较两个指针指向的两个数组中的数字：</p>
<ul>
<li><strong>如果两个数字不相等，则将指向较小数字的指针右移一位</strong></li>
<li><strong>如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位</strong></li>
<li><strong>当至少有一个指针超出数组范围时，遍历结束</strong></li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;nums1.length &amp;&amp; j&lt;nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i]==nums2[j])&#123;</span><br><span class="line">                list.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; ans.length; index++) &#123;</span><br><span class="line">            ans[index] = list.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(mlogm+nlogn)。其中 m 和 n 分别是两个数组的长度。对两个数组进行排序的时间复杂度是 O(mlogm+nlogn)，遍历两个数组的时间复杂度是 )O(m+n)，因此总时间复杂度是 O(mlogm+nlogn)。</li>
<li>空间复杂度：O(min(m,n))。其中 m 和 n 分别是两个数组的长度。</li>
</ul>
</blockquote>
<h1 id="383-赎金信"><a class="markdownIt-Anchor" href="#383-赎金信"></a> 383. 赎金信</h1>
<p><a href="https://leetcode-cn.com/problems/ransom-note/" target="_blank" rel="noopener">LeetCode 383. 赎金信</a></p>
<h2 id="数组-4"><a class="markdownIt-Anchor" href="#数组-4"></a> 数组</h2>
<p>题目已经说明了字符均为小写字母，巧妙地使用<strong>ASCII码</strong>即可。这种方法也已经非常熟悉了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr_ran = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] arr_mag = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            arr_ran[ransomNote.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            arr_mag[magazine.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr_ran[i]&gt;arr_mag[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="387-字符串中的第一个唯一字符"><a class="markdownIt-Anchor" href="#387-字符串中的第一个唯一字符"></a> 387. 字符串中的第一个唯一字符</h1>
<p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">LeetCode 387. 字符串中的第一个唯一字符</a></p>
<h2 id="linkedhashmap"><a class="markdownIt-Anchor" href="#linkedhashmap"></a> LinkedHashMap</h2>
<p>这里之所以用LinkedHashMap，是因为LinkedHashMap是有序的，方便找出第一个不重复的字符的索引。</p>
<p>原理很简单看代码就能搞懂，注意一下我们的LinkedHashMap，<strong>key为字符，value为字符在字符串中的索引</strong>即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key存储字符，value存储字符在字符串中的索引</span></span><br><span class="line">        <span class="comment">// 我们需要Map有序所以使用了LinkedHashMap</span></span><br><span class="line">        LinkedHashMap&lt;Character, Integer&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (linkedHashMap.containsKey(ch))&#123;   <span class="comment">// key已经有该字符了，说明是重复的</span></span><br><span class="line">                linkedHashMap.put(ch,-<span class="number">1</span>); <span class="comment">// 将其value置为-1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 不重复</span></span><br><span class="line">                linkedHashMap.put(ch,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// LinkedHashMap是有序的，所以我们遇到了第一个value不为-1的即为第一个不重复字符所在的索引</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : linkedHashMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue()!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组计数高效率"><a class="markdownIt-Anchor" href="#数组计数高效率"></a> 数组计数（高效率）</h2>
<p>来自<a href="https://leetcode-cn.com/u/wang-xue-lei-2/" target="_blank" rel="noopener">汪雪雷</a>大佬提供的题解。</p>
<p>题目已经说明了字符均为小写字母，我们可以巧妙地使用<strong>ASCII码</strong>。</p>
<p>具体思路只要看一眼代码就能搞懂。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// arr用来存储a，b，c等26个字母出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];    <span class="comment">// 因为只有26个小写字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            arr[s.charAt(i)-<span class="string">'a'</span>]++; <span class="comment">// 举个例子，若字符为c，则为arr[2]++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// arr数组存储完毕后，就可以开始遍历s了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[s.charAt(i)-<span class="string">'a'</span>]==<span class="number">1</span>)&#123;   <span class="comment">// 为0表示没有出现，为1则为只出现一次</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的LinkedHashMap用时22 ms，而此方法用时仅5 ms。</p>
<h1 id="392-判断子序列"><a class="markdownIt-Anchor" href="#392-判断子序列"></a> 392. 判断子序列</h1>
<p><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">LeetCode 392. 判断子序列</a></p>
<h2 id="双指针-7"><a class="markdownIt-Anchor" href="#双指针-7"></a> 双指针</h2>
<p>首先搞清楚子序列的定义，接下来代码就比较好写了。</p>
<p>草稿如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153354.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length_s = s.length();</span><br><span class="line">        <span class="keyword">int</span> length_t = t.length();</span><br><span class="line">        <span class="comment">// 特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (length_s&gt;length_t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (length_s==length_t)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.equals(t);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (length_s==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双指针，i指向t的开头，j指向s开头</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;length_t)&#123;</span><br><span class="line">            <span class="keyword">if</span> (t.charAt(i)==s.charAt(j))&#123;  <span class="comment">// j继续向下遍历的条件</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j==length_s)&#123; <span class="comment">// 如果j走遍了字符串s，说明s是t的子序列</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="393-utf-8-编码验证"><a class="markdownIt-Anchor" href="#393-utf-8-编码验证"></a> 393. UTF-8 编码验证</h1>
<p><a href="https://leetcode-cn.com/problems/utf-8-validation/" target="_blank" rel="noopener">LeetCode 393. UTF-8 编码验证</a></p>
<h2 id="模拟遍历位运算"><a class="markdownIt-Anchor" href="#模拟遍历位运算"></a> 模拟（遍历+位运算）</h2>
<p>这是一道模拟题，主要要搞懂UTF-8编码具体是如何验证的，可以参考这个<a href="https://www.bilibili.com/video/BV1nR4y1V7Yy" target="_blank" rel="noopener">视频</a>来理解。</p>
<p>首先我们<strong>要搞清楚如何判断是哪种验证方法</strong>。题目给了如下四种验证方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Char. number range  |        UTF-8 octet sequence</span><br><span class="line">      (hexadecimal)    |              (binary)</span><br><span class="line">   --------------------+---------------------------------------------</span><br><span class="line">   0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">   0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>
<p>通过观察可以发现：</p>
<ul>
<li><strong>第一个0在第1位，第一种验证方法</strong></li>
<li><strong>第一个0在第3位，第二种验证方法</strong></li>
<li><strong>第一个0在第4位，第三种验证方法</strong></li>
<li><strong>第一个0在第5位，第四种验证方法</strong></li>
</ul>
<p>如何验证第一个0在第几位，需要使用到<strong>位运算</strong>（位与 <code>&amp;</code>）。举个例子，判断数字<code>num</code>：</p>
<ul>
<li><code>num &amp; 128 = 0</code>，第一个0在第1位</li>
<li><code>num &amp; 64 = 0</code>，  第一个0在第2位</li>
<li><code>num &amp; 32 = 0</code>，  第一个0在第3位</li>
<li><code>num &amp; 16 = 0</code>，  第一个0在第4位</li>
<li><code>num &amp; 8 = 0</code>，    第一个0在第5位</li>
</ul>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153422.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">128</span>,<span class="number">64</span>,<span class="number">32</span>,<span class="number">16</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validUtf8</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = get0Index(data[i]); <span class="comment">// 获取当前数第一个0在第几位(注意返回的是masks数组下标，即返回0表示第一个0在第1位)</span></span><br><span class="line">            <span class="keyword">if</span> (index==<span class="number">0</span>)&#123;  <span class="comment">// 第一个0在第1位，肯定是合法的，直接continue</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index&gt;<span class="number">1</span> &amp;&amp; i+index&lt;=data.length)&#123;    <span class="comment">// 第一个0在3,4,5位</span></span><br><span class="line">                <span class="comment">// 举个例子，index==3，第一个0在第4位，那么需要判断data[i]其后2个数是否合法（是否是10开头）</span></span><br><span class="line">                <span class="keyword">while</span> (index&gt;<span class="number">1</span>)&#123;    <span class="comment">// 以index==3为例，i后两个data判断</span></span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span> (get0Index(data[i])!=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    index--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 其他情况即为不合法情况，return false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断给定数的第一个0在第几位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 指定数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回第一个0在第几位（如1011即返回2）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">get0Index</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; masks.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num&amp;masks[i])==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="415-字符串相加"><a class="markdownIt-Anchor" href="#415-字符串相加"></a> 415. 字符串相加</h1>
<p><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">LeetCode 415. 字符串相加</a></p>
<h2 id="模拟双指针"><a class="markdownIt-Anchor" href="#模拟双指针"></a> 模拟+双指针</h2>
<p>这题主要是来模拟两个整数之间的<strong>竖式加法</strong>。一开始我以为要分好多种情况来区分num1和num2长度的不同，但其实<strong>只需要在高位进行补0操作即可</strong>。这里我们使用两个指针，初始分别指向num1和num2的末尾，然后从右到左来计算出num1和num2的值即可。</p>
<p>注意下代码中的三元表达式，意思其实就是高位补0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用三元表达式更加简洁</span></span><br><span class="line"><span class="keyword">int</span> x = i&gt;=<span class="number">0</span>? (num1.charAt(i)-<span class="string">'0'</span>):<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> y = j&gt;=<span class="number">0</span>? (num2.charAt(j)-<span class="string">'0'</span>):<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">            StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="comment">// 两个指针，初始分别指向num1和num2的末尾</span></span><br><span class="line">            <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j = num2.length() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;   <span class="comment">// 是否进位标志</span></span><br><span class="line">            <span class="keyword">while</span> (i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || flag!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 这里使用三元表达式更加简洁</span></span><br><span class="line">                <span class="keyword">int</span> x = i&gt;=<span class="number">0</span>? (num1.charAt(i)-<span class="string">'0'</span>):<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> y = j&gt;=<span class="number">0</span>? (num2.charAt(j)-<span class="string">'0'</span>):<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> n = x + y + flag;</span><br><span class="line">                result.append(n%<span class="number">10</span>);</span><br><span class="line">                flag = n/<span class="number">10</span>;    <span class="comment">// n&lt;10，flag为0；n&gt;10，flag为1</span></span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            result.reverse();   <span class="comment">// 别忘了结果要先反转</span></span><br><span class="line">            <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="455-分发饼干"><a class="markdownIt-Anchor" href="#455-分发饼干"></a> 455. 分发饼干</h1>
<p><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">LeetCode 455. 分发饼干</a></p>
<h2 id="贪心算法-6"><a class="markdownIt-Anchor" href="#贪心算法-6"></a> 贪心算法</h2>
<p>分析：这题的贪心思想比较简单。先将g数组和s数组按升序排列后，再依次比较，判断 <code>s[j] &gt;= g[i]</code>是否成立。<strong>成立则分配饼干给孩子吃，且孩子下标i和饼干下标j都+1</strong>；<strong>若不成立则仅将饼干下标j+1</strong>（因为已经将g数组和s数组排序过了。）</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153444.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g); <span class="comment">// 将g数组即孩子胃口数组从小到大排序</span></span><br><span class="line">        Arrays.sort(s); <span class="comment">// 将s数组即饼干尺寸数组从小到大排序</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;    <span class="comment">// 后续遍历用</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;g.length&amp;&amp;j&lt;s.length)&#123;</span><br><span class="line">            <span class="comment">// 只是饼干下标增加，继续匹配</span></span><br><span class="line">            <span class="keyword">if</span> (s[j]&gt;=g[i])&#123;    <span class="comment">// 可以吃</span></span><br><span class="line">                sum++;</span><br><span class="line">                i++;    <span class="comment">// 孩子吃完饼干后，下标+1开始寻找下一个孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">            j++;    <span class="comment">// 不管能不能吃到饼干，饼干下标都要+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：刚开始做这题的时候，贪心思想是对的，但是我之前经常用for循环，一时间没有想到使用while循环就直接怼for循环了。最开始写的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g); <span class="comment">// 将g数组即孩子胃口数组从小到大排序</span></span><br><span class="line">        Arrays.sort(s); <span class="comment">// 将s数组即饼干尺寸数组从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j]&gt;=g[i])&#123;    <span class="comment">// 可以吃饼干</span></span><br><span class="line">                    sum++;</span><br><span class="line">                    s[j]=<span class="number">0</span>; <span class="comment">// 被吃掉的饼干尺寸置为0</span></span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 吃完即退出内层循环，开始为下一个孩子找饼干</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码嵌套了两层循环（其实完全没有必要，用while循环就能搞定），最终运行结果为：解答成功:<code>执行耗时:93 ms,击败了5.02% 的Java用户，内存消耗:39.1 MB,击败了57.48% 的Java用户</code>。然后我将该代码改善成上述代码，结果为：<code>解答成功:执行耗时:7 ms,击败了99.78% 的Java用户，内存消耗:39.2 MB,击败了43.24% 的Java用户。</code></p>
<p>以后就应该吸取经验，不能一上手就无脑for循环。</p>
</blockquote>
<h1 id="495-提莫攻击"><a class="markdownIt-Anchor" href="#495-提莫攻击"></a> 495. 提莫攻击</h1>
<p><a href="https://leetcode-cn.com/problems/teemo-attacking/" target="_blank" rel="noopener">LeetCode 495. 提莫攻击</a></p>
<h2 id="模拟-3"><a class="markdownIt-Anchor" href="#模拟-3"></a> 模拟</h2>
<p>这是一道简单的模拟题，只要搞清楚题意，就大致知道思路了。</p>
<p>结合一下代码再画个草图，就可以解出此题了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeSeries.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> duration;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; timeSeries.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeSeries[i+<span class="number">1</span>]-timeSeries[i]&lt;=duration)&#123;</span><br><span class="line">                result = result+timeSeries[i+<span class="number">1</span>]-timeSeries[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result = result+duration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result + duration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="504-七进制数"><a class="markdownIt-Anchor" href="#504-七进制数"></a> 504. 七进制数</h1>
<p><a href="https://leetcode-cn.com/problems/base-7/" target="_blank" rel="noopener">LeetCode 504. 七进制数</a></p>
<h2 id="数学-4"><a class="markdownIt-Anchor" href="#数学-4"></a> 数学</h2>
<p>思路很简单，就是简单的数学运算。以100为例：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153507.png" alt="" /></p>
<p>代码实现也很简单，注意一下负数的处理即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (num&lt;<span class="number">7</span> &amp;&amp; num &gt;-<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num&lt;<span class="number">0</span>)&#123; <span class="comment">// 对负数的处理</span></span><br><span class="line">            ans.append(<span class="string">"-"</span>);</span><br><span class="line">            num = -num;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">// 数学处理</span></span><br><span class="line">        <span class="keyword">while</span> (num!=<span class="number">0</span>)&#123;</span><br><span class="line">            stack.addLast(num%<span class="number">7</span>);</span><br><span class="line">            num = num/<span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            ans.append(stack.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="521-最长特殊序列-i"><a class="markdownIt-Anchor" href="#521-最长特殊序列-i"></a> 521. 最长特殊序列 Ⅰ</h1>
<p><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/" target="_blank" rel="noopener">LeetCode 521. 最长特殊序列 Ⅰ</a></p>
<h2 id="脑筋急转弯"><a class="markdownIt-Anchor" href="#脑筋急转弯"></a> 脑筋急转弯</h2>
<p>这题是一道简单题，一开始我一直在寻找测试用例，试图来寻找规律。但是我发现不管怎么样，<strong>只要两个字符串不一样，结果就是两个字符串中长度较长的那个</strong>。正当我疑惑时，参考<a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/solution/gong-shui-san-xie-nao-jin-ji-zhuan-wan-z-nj3w/" target="_blank" rel="noopener">三叶</a>大佬题解发现，原来还真只有这一个规律。</p>
<blockquote>
<p><strong>当两字符串不同时，我们总能选择长度最大的字符串作为答案，而当两字符串相同时，我们无法找到特殊序列。</strong></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.equals(b)? -<span class="number">1</span>: Math.max(a.length(),b.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="522-最长特殊序列-ii"><a class="markdownIt-Anchor" href="#522-最长特殊序列-ii"></a> 522. 最长特殊序列 II</h1>
<p><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/" target="_blank" rel="noopener">LeetCode 522. 最长特殊序列 II</a></p>
<h2 id="暴力算法-3"><a class="markdownIt-Anchor" href="#暴力算法-3"></a> 暴力算法</h2>
<p>这题我怎么就看不太懂呢。。看了下评论才大致看懂。题解思路大致为：先将数组<code>strs</code>按照字符创长度<strong>降序排序</strong>，然后依次遍历，<strong>如果strs数组中任意一个字符串（除了遍历到的strs[i]）都不是遍历到的当前字符串strs[i]的子序列的话，那么就返回这个字符串strs[i]的长度</strong>；如果遍历到最后还没有合法的值，那么就返回-1。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(strs, (o1, o2) -&gt; o2.length()-o1.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// strs[j].length()&lt;strs[i].length(),说明strs[j]一定不是strs[i]的子序列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strs.length &amp;&amp; strs[j].length()&gt;=strs[i].length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSubSeq(strs[j],strs[i]))&#123; <span class="comment">// strs[j]是strs[i]的子序列，更新flag的值</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;      <span class="comment">// flag为true才是合法值</span></span><br><span class="line">                <span class="keyword">return</span> strs[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断字符串b是否为字符串a的子序列（a.length &gt;= b.length）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是子序列返回true；否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubSeq</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.equals(a))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双指针，i指向a的开头，j指向b开头</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.charAt(i)==b.charAt(j))&#123;  <span class="comment">// j继续向下遍历的条件</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j==b.length())&#123; <span class="comment">// 如果j走遍了字符串b，说明b是a的子序列</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Arrays.sort(strs, (o1, o2) -&gt; o2.length()-o1.length());</code>是Lambda表达式，其原始形式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strs, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> o2.length()-o1.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(strs, (o1, o2) -&gt; o2.length()-o1.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;    <span class="comment">// 不是子序列，即strs[i]为合法值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[j].length()&lt;strs[i].length())&#123; <span class="comment">// 说明strs[j]一定不是strs[i]的子序列</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSubSeq(strs[i],strs[j]))&#123; <span class="comment">// strs[j]是strs[i]的子序列，更新flag的值</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;      <span class="comment">// flag为true才是合法值</span></span><br><span class="line">                <span class="keyword">return</span> strs[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断字符串b是否为字符串a的子序列（a.length &gt;= b.length）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是子序列返回true；否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubSeq</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.equals(a))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双指针，i指向a的开头，j指向b开头</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.charAt(i)==b.charAt(j))&#123;  <span class="comment">// j继续向下遍历的条件</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j==b.length())&#123; <span class="comment">// 如果j走遍了字符串b，说明b是a的子序列</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="537-复数乘法"><a class="markdownIt-Anchor" href="#537-复数乘法"></a> 537. 复数乘法</h1>
<p><a href="https://leetcode-cn.com/problems/complex-number-multiplication/" target="_blank" rel="noopener">LeetCode 537. 复数乘法</a></p>
<h2 id="模拟-4"><a class="markdownIt-Anchor" href="#模拟-4"></a> 模拟</h2>
<p>这题是一道模拟题。我们只需要先将复数的乘法运算模拟一下，就很好求解了。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153530.png" alt="" /></p>
<p>所以关键只需要求出<code>a1</code>，<code>a2</code>，<code>b1</code>，<code>b2</code>即可。像这种类似在字符串中找出有效item，之前已经实现过了，简单的双指针即可实现。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">complexNumberMultiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取a1，b1</span></span><br><span class="line">        <span class="keyword">int</span> a1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num1.charAt(j)!=<span class="string">'+'</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取到a1了</span></span><br><span class="line">        a1 = Integer.parseInt(num1.substring(i,j));</span><br><span class="line">        i = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num1.charAt(j)!=<span class="string">'i'</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取到b1了</span></span><br><span class="line">        b1 = Integer.parseInt(num1.substring(i,j));</span><br><span class="line">        <span class="comment">// 读取a2，b2</span></span><br><span class="line">        <span class="keyword">int</span> a2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b2=<span class="number">0</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num2.charAt(j)!=<span class="string">'+'</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        a2 = Integer.parseInt(num2.substring(i,j));</span><br><span class="line">        i = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num2.charAt(j)!=<span class="string">'i'</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        b2 = Integer.parseInt(num2.substring(i,j));</span><br><span class="line">        <span class="keyword">int</span> x = a1*a2-b1*b2;</span><br><span class="line">        <span class="keyword">int</span> y = a1*b2+a2*b1;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ans.append(x).append(<span class="string">"+"</span>).append(y).append(<span class="string">"i"</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/472238482" target="_blank" rel="noopener">宫水三叶</a>大佬的题解简洁的多，因为使用了Java String类的<code>split</code>方法，按照给定的<strong>正则表达式</strong>来进行切割。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">complexNumberMultiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接用Java String类的split方法，按照给定的正则表达式来进行切割</span></span><br><span class="line">        String[] ss1 = num1.split(<span class="string">"\\+|i"</span>), ss2 = num2.split(<span class="string">"\\+|i"</span>);</span><br><span class="line">        <span class="keyword">int</span> a = Integer.parseInt(ss1[<span class="number">0</span>]), b = Integer.parseInt(ss1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> c = Integer.parseInt(ss2[<span class="number">0</span>]), d = Integer.parseInt(ss2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> x = a * c - b * d, y = b * c + a * d;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ans.append(x).append(<span class="string">"+"</span>).append(y).append(<span class="string">"i"</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="553-最优除法"><a class="markdownIt-Anchor" href="#553-最优除法"></a> 553. 最优除法</h1>
<p><a href="https://leetcode-cn.com/problems/optimal-division/" target="_blank" rel="noopener">LeetCode 553. 最优除法</a></p>
<h2 id="模拟-5"><a class="markdownIt-Anchor" href="#模拟-5"></a> 模拟</h2>
<p>这题，emm只需要简单的数学模拟就可以知道，<strong>分子固定是第一个数，分母就是后面的数依次除下去。</strong></p>
<p>分子固定第一个数，分母越小越好，怎样才会越小越好，因为题目限制了数字诠释正整数，肯定越除越小，那就把从第二个数开始到结尾的所有数全部作为分母，这样的时候最小。</p>
<p>虽然是道中等题，但是数学分析之后又觉得太简单了。题目说可以在任意位置添加任意数目的括号，但是经过数学分析后可以知道：<strong>只需要添加一个括号即可</strong>！</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">optimalDivision</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 首先先将数组中的数以此添加/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                ans.append(<span class="string">"/"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接下来添加括号</span></span><br><span class="line">        <span class="keyword">if</span> (length&gt;<span class="number">2</span>)&#123;  <span class="comment">// length&gt;2才需要添加括号</span></span><br><span class="line">            <span class="comment">// 在第一个/后面添加(，在最末尾添加)</span></span><br><span class="line">            ans.insert(ans.indexOf(<span class="string">"/"</span>)+<span class="number">1</span>, <span class="string">"("</span> );</span><br><span class="line">            ans.append(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="564-寻找最近的回文数"><a class="markdownIt-Anchor" href="#564-寻找最近的回文数"></a> 564. 寻找最近的回文数</h1>
<p><a href="https://leetcode-cn.com/problems/find-the-closest-palindrome/" target="_blank" rel="noopener">LeetCode 564. 寻找最近的回文数</a></p>
<h2 id="模拟-6"><a class="markdownIt-Anchor" href="#模拟-6"></a> 模拟</h2>
<p><a href="https://leetcode-cn.com/problems/find-the-closest-palindrome/solution/xun-zhao-zui-jin-de-hui-wen-shu-by-leetc-biyt/" target="_blank" rel="noopener">官方题解</a></p>
<p>构造回文整数有一个直观的方法：<strong><mark>用原数的较高位的数字替换其对应的较低位</mark></strong>。例如，对于数 12345，我们可以用 1 替换 5，用 2 替换 4，这样原数即变为回文整数 12321。</p>
<p>在这种方案中，我们修改的都是较低位的数字，因此构造出的新的整数与原数较为接近。大部分情况下，这种方案是最优解，但<strong>还有部分情况我们没有考虑到</strong>：</p>
<ol>
<li><strong>构造的回文整数大于原数时，我们可以减小该回文整数的中间部分来缩小回文整数和原数的差距</strong>。例如，对于数 99321，我们将构造出回文整数 99399，实际上 99299 更接近原数。
<ul>
<li><strong>当我们减小构造的回文整数时，可能导致回文整数的位数变化</strong>。例如，对于数 100，我们将构造出回文整数 101，减小其中间部分将导致位数减少。得到的回文整数形如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>999</mn><mo>…</mo><mn>999</mn></mrow><annotation encoding="application/x-tex">999 \ldots 999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span></span></span></span> ( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mtext>len </mtext></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">10^{\text {len }}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">len </span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> )。</li>
</ul>
</li>
<li><strong>构造的回文整数小于原数时，我们可以增大该回文整数的中间部分来缩小回文整数和原数的差距</strong>。例如，对于数 12399，我们将构造出回文整数 12321，实际上 12421 更接近原数。
<ul>
<li><strong>当我们增大构造的回文整数时，可能导致回文整数的位数变化</strong>。例如，对于数 998 ，我们将构 造出回文整数 999 ，增大其中间部分将导致位数增加。得到的回文整数形如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mo>…</mo><mn>001</mn></mrow><annotation encoding="application/x-tex">100 \ldots 001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span> ( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">10^{l e n}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）。</li>
</ul>
</li>
<li>构造的回文整数等于原数时，由于题目约定，我们需要排除该回文整数，在其他的可能情况中寻找最近的回文整数。</li>
</ol>
<p>考虑到以上所有的可能，我们可以给出最终的方案。<strong>分别计算出以下每一种可能的方案对应的回文整数，在其中找到与原数最近且不等于原数的数即为答案：</strong></p>
<ol>
<li><strong>用原数的前半部分替换后半部分得到的回文整数</strong></li>
<li><strong>用原数的前半部分加一后的结果替换后半部分得到的回文整数</strong></li>
<li><strong>用原数的前半部分减一后的结果替换后半部分得到的回文整数</strong></li>
<li>为防止位数变化导致构造的回文整数错误，因此<strong>直接构造</strong>  999…999 和  100…001 作为备选答案（以12399为例，直接构造9999和10001）</li>
</ol>
<p>举个例子：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153618.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">nearestPalindromic</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> number = Long.parseLong(n);</span><br><span class="line">        Long ans = -<span class="number">1L</span>;</span><br><span class="line">        List&lt;Long&gt; candidates = getCandidates(n);   <span class="comment">// 获取候选的几个数</span></span><br><span class="line">        <span class="comment">// 找到与原数最近且不等于原数的数即为答案</span></span><br><span class="line">        <span class="keyword">for</span> (Long candidate : candidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate != number) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans == -<span class="number">1</span>) &#123;   <span class="comment">// 先给ans赋一个候选值</span></span><br><span class="line">                    ans = candidate;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(candidate - number) &lt; Math.abs(ans - number)) &#123;  <span class="comment">// 取最近的</span></span><br><span class="line">                    ans = candidate;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(candidate - number) == Math.abs(ans - number) &amp;&amp; candidate &lt; ans) &#123; <span class="comment">// 一样近，取最小的</span></span><br><span class="line">                    ans = candidate;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据我们分析出的条件，返回一个候选结果列表</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> List&lt;Long&gt; <span class="title">getCandidates</span> <span class="params">(String n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> length = n.length();</span><br><span class="line">            List&lt;Long&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">long</span> prefix = Long.parseLong(n.substring(<span class="number">0</span>, (length + <span class="number">1</span>) / <span class="number">2</span>));   <span class="comment">// 前一半数字(前缀)</span></span><br><span class="line">            <span class="comment">// 前三种情况，即前缀-1，前缀，前缀+1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = prefix - <span class="number">1</span>; i &lt;= prefix + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String prefix_str = String.valueOf(i);  <span class="comment">// 前缀</span></span><br><span class="line">                StringBuilder suffix_str = <span class="keyword">new</span> StringBuilder(prefix_str).reverse(); <span class="comment">// 后缀</span></span><br><span class="line">                <span class="keyword">if</span> (length % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 注意添加后缀时，不要重复了中间的数字</span></span><br><span class="line">                    sb.append(prefix_str).append(suffix_str.substring(<span class="number">0</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sb.append(prefix_str).append(suffix_str.substring(<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                String candidate = sb.toString();</span><br><span class="line">                list.add(Long.parseLong(candidate));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第四种情况</span></span><br><span class="line">            list.add((<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, length - <span class="number">1</span>) - <span class="number">1</span>);  <span class="comment">// 99...99</span></span><br><span class="line">            list.add((<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, length) + <span class="number">1</span>);    <span class="comment">// 100..001</span></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="566-重塑矩阵"><a class="markdownIt-Anchor" href="#566-重塑矩阵"></a> 566. 重塑矩阵</h1>
<p><a href="https://leetcode-cn.com/problems/reshape-the-matrix/" target="_blank" rel="noopener">LeetCode 566. 重塑矩阵</a></p>
<h2 id="数组-5"><a class="markdownIt-Anchor" href="#数组-5"></a> 数组</h2>
<p>思路比较简单，直接看代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.length;</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (m*n != r*c)&#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : mat) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                deque.addLast(anInt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">                arr[i][j] = deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维数组的一维表示-2"><a class="markdownIt-Anchor" href="#二维数组的一维表示-2"></a> 二维数组的一维表示</h2>
<p><a href="https://leetcode-cn.com/problems/reshape-the-matrix/solution/zhong-su-ju-zhen-by-leetcode-solution-gt0g/" target="_blank" rel="noopener">官方题解</a></p>
<p>对于一个行数为 m，<strong>列数为 n</strong>，行列下标都从 0 开始编号的二维数组，我们可以通过下面的方式，将其中的每个元素 <code>(i, j)</code> 映射到整数域内，并且它们按照<strong>行优先</strong>的顺序一一对应着 <code>[0, m*n)</code>中的每一个整数。形象化地来说，我们把这个二维数组<strong>排扁</strong>成了一个一维数组。</p>
<p>这样的映射即为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>→</mo><mi>i</mi><mo>×</mo><mi>n</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">(i, j) \rightarrow i \times n+j
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span></p>
<p>同样地，我们可以将<strong>整数 x 映射回其在矩阵中的下标</strong>，即：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>=</mo><mi>x</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>j</mi><mo>=</mo><mi>x</mi><mi mathvariant="normal">%</mi><mi>n</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{array}{l}
i=x / n \\
j=x \% n
\end{array}\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault">n</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mord">%</span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这个搞清楚了，这题就很好解了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.length;</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (m*n != r*c)&#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m * n; x++) &#123;</span><br><span class="line">            arr[x/c][x%c] = mat[x/n][x%n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="589-n-叉树的前序遍历"><a class="markdownIt-Anchor" href="#589-n-叉树的前序遍历"></a> 589. N 叉树的前序遍历</h1>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">LeetCode 589. N 叉树的前序遍历</a></p>
<h2 id="深度优先搜索bfs"><a class="markdownIt-Anchor" href="#深度优先搜索bfs"></a> 深度优先搜索（BFS）</h2>
<p>跟二叉树的前序遍历类似。前序遍历即<code>根-左-右</code>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">for</span> (Node node : root.children) &#123;</span><br><span class="line">                preorder(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写的更像<code>dfs</code>一点的话，代码可以如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node, ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">for</span> (Node child : node.children) &#123;</span><br><span class="line">                dfs(child,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="590-n-叉树的后序遍历"><a class="markdownIt-Anchor" href="#590-n-叉树的后序遍历"></a> 590. N 叉树的后序遍历</h1>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">LeetCode 590. N 叉树的后序遍历</a></p>
<h2 id="深度优先搜索bfs-2"><a class="markdownIt-Anchor" href="#深度优先搜索bfs-2"></a> 深度优先搜索（BFS）</h2>
<p>跟二叉树的后序遍历类似。后序遍历即<code>左-右-根</code>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node child : node.children) &#123;</span><br><span class="line">            dfs(child);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="599-两个列表的最小索引总和"><a class="markdownIt-Anchor" href="#599-两个列表的最小索引总和"></a> 599. 两个列表的最小索引总和</h1>
<p><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">LeetCode 599. 两个列表的最小索引总和</a></p>
<h2 id="模拟哈希表"><a class="markdownIt-Anchor" href="#模拟哈希表"></a> 模拟+哈希表</h2>
<p>这是一道简单模拟题。理解题意后使用Hash表就能实现。思路比较清晰看代码就能搞懂。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findRestaurant(String[] list1, String[] list2) &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;    <span class="comment">// 记录后面遍历过程中的最小索引和</span></span><br><span class="line">        <span class="comment">// key存储list1的字符串，value存储该字符串在list1中的索引</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.length; i++) &#123;</span><br><span class="line">            map.put(list1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接下来遍历list2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(list2[i]))&#123;</span><br><span class="line">                <span class="comment">// 判断是否是最小索引和</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(list2[i])+i&lt;min)&#123;   <span class="comment">// 新的最小索引和</span></span><br><span class="line">                    list.clear();</span><br><span class="line">                    list.add(list2[i]);</span><br><span class="line">                    min = map.get(list2[i])+i;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.get(list2[i])+i==min)&#123;</span><br><span class="line">                    list.add(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] ans = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="605-种花问题"><a class="markdownIt-Anchor" href="#605-种花问题"></a> 605. 种花问题</h1>
<p><a href="https://leetcode-cn.com/problems/can-place-flowers/" target="_blank" rel="noopener">LeetCode 605. 种花问题</a></p>
<h2 id="双指针-8"><a class="markdownIt-Anchor" href="#双指针-8"></a> 双指针</h2>
<p>这题我用双指针来解决。首先定义result为我们能最多插入的花。分析如下：</p>
<ul>
<li>首先来看一般情况，<strong>中间的两个1之间，如果有x个0，那么最多就可以插入（x-1）/2枝花</strong>（简单的数学问题，画下图就能看懂）</li>
<li>接下来来看两个特特殊况：
<ul>
<li>开头前两个均为0：处理方式为另开头的0为1，result++</li>
<li>倒数两个均为0：处理方式为另倒数第一个的0为1，result++</li>
</ul>
</li>
</ul>
<p>在对上述两种特殊情况处理完毕后，接下来的问题就<strong>是如何计算两个1之间0的值x</strong>了，这里我采用了双指针的方法，设置两个指针a，b，初始时分别指向0和1：</p>
<ul>
<li>b每次都向右移动一位，当b移动到1时，计算a和b之间0的个数，很明显可以看出是<strong>b-a-1</strong>，即x=b-a-1</li>
<li>计算出x后，我们再根据x来求出最多能插入的花的数目，（x-1）/2通过数学合并即为(b-a-2)/2，         <code>result = result + (b-a-2)/2;</code>即可</li>
<li>result相加后，使a指针指向b的位置：<code>a = b;</code>，然后b再次向右移动重复上述循环，<strong>直到b走到了数组的最后一位</strong></li>
</ul>
<p>最后的最后，别忘了对flowerbed长度为1的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flowerbed.length==<span class="number">1</span>)&#123;   <span class="comment">// flowerbed长度为1</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flowerbed[<span class="number">0</span>]==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算出result剩下的就很好做了，直接<code>return result&gt;=n;</code>即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flowerbed.length==<span class="number">1</span>)&#123;   <span class="comment">// flowerbed长度为1</span></span><br><span class="line">            <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flowerbed[<span class="number">0</span>]==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">// 能插入的最大花数</span></span><br><span class="line">        <span class="keyword">if</span> (flowerbed[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;flowerbed[<span class="number">1</span>]==<span class="number">0</span>)&#123;   <span class="comment">// 特殊情况之开头前两个均为0</span></span><br><span class="line">            flowerbed[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flowerbed[flowerbed.length-<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;flowerbed[flowerbed.length-<span class="number">2</span>]==<span class="number">0</span>)&#123;   <span class="comment">// 特殊情况之倒数两个均为0</span></span><br><span class="line">            flowerbed[flowerbed.length-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义两个指针a，b，便于计算两个1之间0的个数</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b&lt;flowerbed.length)&#123;</span><br><span class="line">            <span class="comment">// b指针指到了1，先计算a，b之间0的个数，然后将a指针移动到b指针</span></span><br><span class="line">            <span class="keyword">if</span> (flowerbed[b]==<span class="number">1</span>)&#123;</span><br><span class="line">                result  = result + (b-a-<span class="number">2</span>)/<span class="number">2</span>;   <span class="comment">// 数学合并处理</span></span><br><span class="line">                a = b;</span><br><span class="line">            &#125;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result&gt;=n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：<code>解答成功:执行耗时:1 ms,击败了89.55% 的Java用户，内存消耗:39.9 MB,击败了53.91% 的Java用户</code></p>
<h2 id="贪心算法-7"><a class="markdownIt-Anchor" href="#贪心算法-7"></a> 贪心算法</h2>
<p>上面的双指针的思想，可能还是步骤较多，运行时间为1ms。接下来我们使用贪心算法，我们只需要<strong>定义一个指针i=0</strong>，就可以直接开始遍历。遍历规则的关键点就一个：<strong>1的左右两个都不能插花</strong></p>
<p>在遍历的过程中，贪心思想（遍历规则）如下：</p>
<ul>
<li>第一种情况：如果<strong>第i个元素为1</strong>，说明第i和第i+1的位置都不能插花，直接<code>i = i + 2</code></li>
<li>第二种情况：可以插花，这里需要区分两种情况：
<ul>
<li><strong>i还在数组的中间位置</strong>，如果<strong>第i个元素和第i+1个元素都为0</strong>，说明可以在i处置1，<code>n--</code>，然后<code>i = i+2</code></li>
<li><strong>i已经到了数组的最后一个位置</strong>，根据我们的遍历规则（1的左右两个都不能插花），i既然跳转到了最后一个位置，说明i的前一个位置必为0！所以可以插花，<code>n--</code></li>
</ul>
</li>
<li>第三种情况：不能插花，i指向0而i+1指向1，<code>i = i+3</code></li>
</ul>
<blockquote>
<p>说的更清楚点，就是（下面的例子中<code>i</code>都指向第一个数字）：</p>
<ul>
<li>10的情况：不能插花，<code>i = i+2</code></li>
<li>00的情况：可以插花，<code>n--</code>之后，<code>i = i+2</code></li>
<li>01的情况：不能插花，<code>i = i+3</code></li>
</ul>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;  <span class="comment">// n为0，直接return true;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.length;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i]==<span class="number">1</span>)&#123;   <span class="comment">// 10的情况</span></span><br><span class="line">                i = i + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i==flowerbed.length-<span class="number">1</span>)||(i&lt;flowerbed.length-<span class="number">1</span>)&amp;&amp;flowerbed[i+<span class="number">1</span>]==<span class="number">0</span>) &#123;    <span class="comment">// 00的情况</span></span><br><span class="line">                n--;</span><br><span class="line">                <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;  <span class="comment">// n到0了就直接return true;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i = i + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 01的情况</span></span><br><span class="line">                i = i + <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：<code>解答成功:执行耗时:0 ms,击败了100.00% 的Java用户，内存消耗:39.9 MB,击败了50.49% 的Java用户</code></p>
<h1 id="653-两数之和-iv-输入-bst"><a class="markdownIt-Anchor" href="#653-两数之和-iv-输入-bst"></a> 653. 两数之和 IV - 输入 BST</h1>
<p><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">LeetCode 653. 两数之和 IV - 输入 BST</a></p>
<h2 id="树的搜索哈希表"><a class="markdownIt-Anchor" href="#树的搜索哈希表"></a> 树的搜索+哈希表</h2>
<p><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/liang-shu-zhi-he-iv-shu-ru-bst-by-leetco-b4nl/" target="_blank" rel="noopener">官方题解</a></p>
<p><a href="https://pdai.tech/md/algorithm/alg-basic-tree-search.html#%E6%A0%91---%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91bst" target="_blank" rel="noopener">二叉搜索树(BST)</a></p>
<p><strong>二叉搜索树的中序遍历是升序排列的。</strong>（所以也可以采用中序遍历+双指针来解决）</p>
<p>使用DFS或BFS遍历数的每个节点，同时结合哈希表即可完成此题。在遍历二叉搜索树时，我们使用HashSet来存储<code>k-node.val</code>；如果下次遇到的节点值存在于HashSet，即返回true。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(root.val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(k- root.val);</span><br><span class="line">        <span class="keyword">return</span> findTarget(root.left,k) || findTarget(root.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="670-最大交换"><a class="markdownIt-Anchor" href="#670-最大交换"></a> 670. 最大交换</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-swap/" target="_blank" rel="noopener">LeetCode 670. 最大交换</a></p>
<h2 id="双指针-9"><a class="markdownIt-Anchor" href="#双指针-9"></a> 双指针</h2>
<p>这题因为给定数字的范围是 [0, 10^8]。所以数字长度不是特别大，使用双指针再嵌套一个<code>for</code>循环就可以<code>0ms 100%</code>了。</p>
<p>思路很简单，题目要求<strong>至多</strong>可以交换一次数字中的任意两位，那么为了得到最大数，只需要<strong>将数字中的最大数移到最高位</strong>即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(num);</span><br><span class="line">        <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length-<span class="number">1</span>; i++) &#123;    <span class="comment">// i只需要遍历到倒数第二位即可</span></span><br><span class="line">            <span class="comment">// 首先找到j之后的最大值max的索引</span></span><br><span class="line">            <span class="keyword">int</span> max = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                max = arr[max]&gt;arr[j]? max:j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 之后判断arr[max]和arr[i]的关系</span></span><br><span class="line">            <span class="keyword">if</span> (arr[max]&gt;arr[i])&#123;</span><br><span class="line">                <span class="keyword">char</span> temp = arr[max];</span><br><span class="line">                arr[max] = arr[i];</span><br><span class="line">                arr[i] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = <span class="keyword">new</span> String(arr);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="704-二分查找"><a class="markdownIt-Anchor" href="#704-二分查找"></a> 704. 二分查找</h1>
<p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">LeetCode 704. 二分查找</a></p>
<h2 id="二分查找-2"><a class="markdownIt-Anchor" href="#二分查找-2"></a> 二分查找</h2>
<p>因为题目所给数组是已经排序好的，所以这就是一个二分查找的典型例子。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">1</span>)&#123; <span class="comment">// 特殊情况处理</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]==target? <span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;   <span class="comment">// 结果小了</span></span><br><span class="line">                left = mid+<span class="number">1</span>;   <span class="comment">// 更新搜索区间为[mid+1, right]</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;   <span class="comment">// 结果大了</span></span><br><span class="line">                right = mid;    <span class="comment">// 更新搜索区间为[left, mid]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left]==target? left:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="707-设计链表"><a class="markdownIt-Anchor" href="#707-设计链表"></a> 707. 设计链表</h1>
<p><a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">LeetCode 707. 设计链表</a></p>
<h2 id="单链表-5"><a class="markdownIt-Anchor" href="#单链表-5"></a> 单链表</h2>
<p>单链表的实现在之前的数据结构学习<a href="https://www.qingbo1011.top/2021/08/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#linkedlist%E7%9A%84%E5%AE%9E%E7%8E%B0">笔记</a>中就已经写过了。在写代码的过程中只要心里清楚<strong>头节点和首元节点</strong>的区别即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode dummyNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dummyNode = <span class="keyword">new</span> ListNode();    <span class="comment">// 头结点用于区分首元结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode temp = dummyNode.next; <span class="comment">// temp节点从首元节点开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        newNode.next = dummyNode.next;</span><br><span class="line">        dummyNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        ListNode temp = dummyNode;  <span class="comment">// temp从头节点开始</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;    <span class="comment">// 循环结束后temp即为链表的最后一个节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index&lt;<span class="number">0</span>)&#123;   <span class="comment">// 如果index小于0，则在头部插入节点</span></span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        ListNode temp = dummyNode;  <span class="comment">// temp从头节点开始</span></span><br><span class="line">        <span class="comment">// 循环结束后，temp节点为index节点的前一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="keyword">null</span>)&#123; <span class="comment">// 如果index大于链表长度，则不会插入节点</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp==<span class="keyword">null</span>)&#123; <span class="comment">// 如果index大于链表长度，则不会插入节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.next = temp.next;</span><br><span class="line">        temp.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode temp = dummyNode;  <span class="comment">// temp从头节点开始</span></span><br><span class="line">        <span class="comment">// 循环结束后，temp节点为index节点的前一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="keyword">null</span>||temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp==<span class="keyword">null</span>||temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = temp.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="709-转换成小写字母"><a class="markdownIt-Anchor" href="#709-转换成小写字母"></a> 709. 转换成小写字母</h1>
<p><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">LeetCode 709. 转换成小写字母</a></p>
<h2 id="ascii码应用"><a class="markdownIt-Anchor" href="#ascii码应用"></a> ASCII码应用</h2>
<p>注意清楚如何根据ASCII码转换字母大小写即可。在本题中通过<code>arr[i] = (char) (arr[i]+32);</code>将大写字母转换成小写字母。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'A'</span>&lt;=arr[i] &amp;&amp; arr[i]&lt;=<span class="string">'Z'</span> )&#123;</span><br><span class="line">                arr[i] = (<span class="keyword">char</span>) (arr[i]+<span class="number">32</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="739-每日温度"><a class="markdownIt-Anchor" href="#739-每日温度"></a> 739. 每日温度</h1>
<p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">LeetCode 739. 每日温度</a></p>
<h2 id="单调栈-5"><a class="markdownIt-Anchor" href="#单调栈-5"></a> 单调栈</h2>
<p>这题是单调栈的典型题目：即求<strong>下一个大于 x</strong>或者<strong>下一个小于 xx</strong>这类题目。</p>
<p>我们创建一个单调栈，保证<strong>栈中从栈顶到栈底温度是单调递增的</strong>。同时，为了方便后续操作，我们在<strong>栈中存储的不是温度本身，而是温度在temperatures数组中的索引</strong>。</p>
<p>这里我们准备一个arr数组作为返回的结果数组。</p>
<p>遍历temperatures数组，依次将其push到单调栈中，当出现<strong>遍历的当前温度current大于栈顶元素top</strong>时，执行以下操作：(这种情况即说明pop出的温度在若干天后(<code>current - top</code>)出现了比它高的温度)</p>
<ul>
<li><strong>需要pop出若干元素</strong>，保证栈是单调栈</li>
<li><code>arr[current] = current - top</code></li>
</ul>
<p>遍历结束后，还在栈中的元素，即说明这些温度在之后的时间中再也没有出现比它高的温度了，结果为0。当然我们在初始化的时候值已经是0了，所以无需再进行操作。</p>
<p>文字结合以下草稿，应该就比较清晰了：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153640.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];    <span class="comment">// 结果数组</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">// 单调栈</span></span><br><span class="line">        stack.addLast(<span class="number">0</span>); <span class="comment">// 先将数组的第一个元素push到栈中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 保证是单调栈</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i]&gt;temperatures[stack.getLast()])&#123;</span><br><span class="line">                arr[stack.getLast()] = i - stack.getLast();</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="781-森林中的兔子"><a class="markdownIt-Anchor" href="#781-森林中的兔子"></a> 781. 森林中的兔子</h1>
<p><a href="https://leetcode-cn.com/problems/rabbits-in-forest/" target="_blank" rel="noopener">LeetCode 781. 森林中的兔子</a></p>
<h2 id="模拟贪心"><a class="markdownIt-Anchor" href="#模拟贪心"></a> 模拟+贪心</h2>
<p>参考<a href="https://leetcode-cn.com/problems/rabbits-in-forest/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-v17p5/" target="_blank" rel="noopener">宫水三叶</a>大佬题解。</p>
<p><a href="https://leetcode-cn.com/problems/rabbits-in-forest/solution/sen-lin-zhong-de-tu-zi-by-leetcode-solut-kvla/" target="_blank" rel="noopener">官方题解</a></p>
<p>首先我们根据题意可得出以下推论：<strong>两只相同颜色的兔子看到的其他同色兔子数必然是相同的</strong>。其逆反命题为：<strong>若两只兔子看到的其他同色兔子数不同，那么这两只兔子颜色也不同</strong>。</p>
<p>提取结论如下：</p>
<ul>
<li><strong>同一颜色的兔子回答的数值必然是一样的</strong></li>
<li><strong>但回答同样数值的，不一定就是同颜色兔子</strong></li>
</ul>
<p>设有某种颜色的兔子 <code>m</code> 只，它们回答的答案数值为 <code>cnt</code>，显然有： <code>m=cnt+1</code>。</p>
<p>但如果是在 <code>answers</code>数组里，回答 <code>cnt</code> 的数量为 <code>t</code> 的话呢？这时候我们需要分情况讨论：</p>
<ul>
<li><code>t&lt;=cnt+1</code> : 为达到最少的兔子数量，我们可以假定这<code>t</code>只兔子为同一颜色，这样能够满足题意，同时不会导致额外兔子数量增加（<strong>同一颜色的兔子回答的数值必然是一样的</strong>）</li>
<li><code>t&gt;cnt+1</code> : 我们知道回答 <code>cnt</code> 的兔子应该有 <code>cnt+1</code> 只。这时候<strong>说明有数量相同的不同颜色的兔子回答了同样的数值</strong>。为达到最少的兔子数量，我们应当将 <code>t</code> 分为若干种颜色，并尽可能让某一种颜色的兔子为 <code>cnt+1</code> 只，这样能够满足题意，同时不会导致额外兔子数量增加（<strong>但回答同样数值的，不一定就是同颜色兔子</strong>）。</li>
</ul>
<p>贪心思想的核心在于：<strong>我们应该让同一颜色的兔子数量尽量多，从而实现总的兔子数量最少。</strong></p>
<p>通过数学处理，我们可以得到以下<mark>结论</mark>：一般地，如果有 <code>x</code> 只兔子都回答 <code>y</code>，则至少有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌈</mo><mfrac><mi>x</mi><mrow><mi>y</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo fence="true">⌉</mo></mrow><annotation encoding="application/x-tex">\left\lceil\frac{x}{y+1}\right\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌈</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌉</span></span></span></span></span></span>种不同的颜色，且每种颜色有 <code>y+1</code>只兔子，因此兔子数至少为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">⌈</mo><mfrac><mi>x</mi><mrow><mi>y</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo fence="true">⌉</mo></mrow><mo>⋅</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\left\lceil\frac{x}{y+1}\right\rceil \cdot(y+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">⌈</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">⌉</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>有了这个结论，接下来就很好做了。我们可以用HashMap来存储，其中<code>key</code>为回答的结果<code>y</code>，<code>valeu</code>为回答为y的兔子数量<code>x</code>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRabbits</span><span class="params">(<span class="keyword">int</span>[] answers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> answer : answers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(answer)) &#123;</span><br><span class="line">                map.put(answer, map.get(answer) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(answer, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// x/(y+1)的结果向上取整，可以写成(x+y)/(y+1)向下取整</span></span><br><span class="line">            <span class="keyword">int</span> x = entry.getValue();</span><br><span class="line">            <span class="keyword">int</span> y = entry.getKey();</span><br><span class="line">            result = result + ((x + y)/(y +<span class="number">1</span>))*(y +<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在代码上，<code>x/(y+1)</code>的结果<strong>向上取整</strong>，可以写成<code>(x+y)/(y+1)</code>向下取整！</p>
<h1 id="876-链表的中间结点"><a class="markdownIt-Anchor" href="#876-链表的中间结点"></a> 876. 链表的中间结点</h1>
<p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">LeetCode 876. 链表的中间结点</a></p>
<h2 id="单链表-6"><a class="markdownIt-Anchor" href="#单链表-6"></a> 单链表</h2>
<p>求链表的中间结点，在之前数据结构的学习<a href="https://www.qingbo1011.top/2021/08/02/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/#linkedlist%E7%9A%84%E5%AE%9E%E7%8E%B0">笔记</a>中就已经实现过了。</p>
<p>这里再简单说一下思路：在<strong>未知链表长度</strong>的情况下，要找出链表的中间节点，可以<strong>设置两个指针p1，p2，都从首元节点开始</strong>， <strong>p1节点走一步，p2节点走两步，当p2节点为终点时，p1为中间节点</strong>。</p>
<p>注意事项：</p>
<ul>
<li>我们的条件设置为<code>p2!=null &amp;&amp; p2.next!=null &amp;&amp; p2.next.next!=null</code></li>
<li><strong>当节点数为奇数时</strong>，p2能够走到最后一个节点，此时p1为链表的中间节点</li>
<li><strong>当节点数为偶数时</strong>，p2只能走到倒数第2个节点，所以p1为链表中间偏左的节点</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置两个指针p1，p2</span></span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (p2!=<span class="keyword">null</span>&amp;&amp;p2.next!=<span class="keyword">null</span>&amp;&amp;p2.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// p1走一步，p2走两步</span></span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p2.next==<span class="keyword">null</span>)&#123; <span class="comment">// 说明p2走到了链表的最后一个节点，链表长度为奇数</span></span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.next; <span class="comment">// 节点数为偶数，p1为链表中间偏左的节点，而题目要返回中间偏右的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="917-仅仅反转字母"><a class="markdownIt-Anchor" href="#917-仅仅反转字母"></a> 917. 仅仅反转字母</h1>
<h2 id="栈顺序表"><a class="markdownIt-Anchor" href="#栈顺序表"></a> 栈+顺序表</h2>
<p>这题我刚开始的思路就是：遍历字符串s，用栈来存储字母方便反转，用顺序表来存储非字母方便后续插入。</p>
<p>意思很好理解，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseOnlyLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();    <span class="comment">// 栈，来反转字母</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">// 存储字符串中非字母字符所在的索引</span></span><br><span class="line">        <span class="keyword">char</span>[] s_arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s_arr[i]&gt;=<span class="string">'A'</span>&amp;&amp;s_arr[i]&lt;=<span class="string">'Z'</span>) || (s_arr[i]&gt;=<span class="string">'a'</span>&amp;&amp;s_arr[i]&lt;=<span class="string">'z'</span>) )&#123; <span class="comment">// 字母</span></span><br><span class="line">                stack.push(s_arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;     <span class="comment">// 非字母</span></span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先将字母反转</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            ans.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后插入非字母的字符</span></span><br><span class="line">        <span class="keyword">for</span> (Integer index : list) &#123;</span><br><span class="line">            ans.insert(index, String.valueOf(s_arr[index]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:2 ms,击败了9.63% 的Java用户，内存消耗:39.7 MB,击败了5.02% 的Java用户</code>。</p>
</blockquote>
<h2 id="双指针模拟"><a class="markdownIt-Anchor" href="#双指针模拟"></a> 双指针+模拟</h2>
<p>上面的方法效率还是太低了，这里参考一下<a href="https://leetcode-cn.com/problems/reverse-only-letters/solution/gong-shui-san-xie-jian-dan-shuang-zhi-zh-xrpt/" target="_blank" rel="noopener">宫水三叶</a>大佬的题解。</p>
<p>反转典型的<strong>双指针</strong>，我们分别在字符串开头和末尾定义两个指针，然后分别向中间移动，若遇到了非字母，则该指针继续移动即可。（思路很清晰打下草稿就能搞懂）</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseOnlyLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isLetter(arr[l]))&#123;</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isLetter(arr[r]))&#123;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果为：<code>解答成功:执行耗时:0 ms,击败了100.00% 的Java用户，内存消耗:39.2 MB,击败了18.96% 的Java用户</code></p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：调用 <code>toCharArray</code> 和构造新字符串均需要与字符串长度等同的空间。复杂度为 O(n)</li>
</ul>
</blockquote>
<h1 id="932-漂亮数组"><a class="markdownIt-Anchor" href="#932-漂亮数组"></a> 932. 漂亮数组</h1>
<p><a href="https://leetcode-cn.com/problems/beautiful-array/" target="_blank" rel="noopener">LeetCode 932. 漂亮数组</a></p>
<h1 id="1081-不同字符的最小子序列"><a class="markdownIt-Anchor" href="#1081-不同字符的最小子序列"></a> 1081. 不同字符的最小子序列</h1>
<p><a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/" target="_blank" rel="noopener">LeetCode 1081. 不同字符的最小子序列</a></p>
<blockquote>
<p>注意：该题与<a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母</a></p>
</blockquote>
<h2 id="单调栈-6"><a class="markdownIt-Anchor" href="#单调栈-6"></a> 单调栈</h2>
<p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/" target="_blank" rel="noopener"><strong>官方题解（含视频）</strong></a></p>
<p>这题感觉如果没有正确的方向的话是挺难的。官方提供的题解已经说的很好了，这里我用自己的语言分析一下。</p>
<p>要解决这个问题，需要用到：</p>
<ul>
<li>一个<strong>单调栈</strong>：<strong>为什么要用单调栈呢，因为要保证栈中的结果永远都是字典序最小</strong></li>
<li>两个数组：<strong>lastIndex数组存储字符串s中各个字母出现的最后一个位置</strong>，<strong>visited数组存储各个字符是否已经存在于栈中</strong></li>
</ul>
<p>接下来就可以遍历字符串s，分析一下单调栈的存储过程：</p>
<ul>
<li>
<p>首先，<strong>先判断当前字符是否已经存在于栈中</strong>，如果已经存在，什么都不做开始遍历下一个字符（<code>continue</code>）</p>
</li>
<li>
<p>如果该字符不存在与栈中（这里用<code>while</code>）：</p>
<ul>
<li>
<p>那么就先<strong>判断遍历的字符是否大于栈顶元素top</strong>，如果遍历的字符大于栈顶字符top，那么就无需执行下面的操作，直接跳出while循环</p>
</li>
<li>
<p>如果字符小于栈顶元素top，那么就<strong>先判断栈的栈顶元素top是否还会再次出现</strong>（<code>i&lt;lastIndex[top-'a']</code>），如果top字符在字符串s后面的遍历中还会出现的话，那么就pop出该栈顶元素，同时在visited数组中设置该字符不存在于栈中（<code>visited[top-'a']=false</code>）</p>
<p>。接着继续拿遍历的字符跟<strong>新的栈顶元素</strong>进行上述比较（同样要<strong>先判断遍历的字符是否大于栈顶元素top</strong>，<strong>再判断栈的栈顶元素top是否还会再次出现</strong>）（这么做是为了<strong>保证栈中的结果永远都是字典序最小</strong>，所以要用<code>while</code>）</p>
</li>
<li>
<p><strong>while循环结束后</strong>，将该字符push到栈中，同时在visited数组中设置该字符已经存在于栈中</p>
<p>（<code>visited[charArray[i]-'a']=true</code>）</p>
</li>
</ul>
</li>
<li>
<p>字符串s遍历之后，栈中从栈底到栈顶的顺序即为我们的结果</p>
</li>
</ul>
<p>光看文字描述可能很迷糊，但光看代码也会很迷糊，文字结合代码一起看应该就比较清晰了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 一个单调栈，两个数组</span></span><br><span class="line">        ArrayDeque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">// 题目已经说了都是小写，所以长度为26</span></span><br><span class="line">        <span class="keyword">int</span>[] lastIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];  <span class="comment">// 存储字符串中字母出现的最后一个位置</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];    <span class="comment">// 存储a-z这26个字母是否已经存在于栈中</span></span><br><span class="line">        <span class="comment">// 这个循环结束后，lastIndex数组即成功存储到a-z(0-25)的字母在字符串s中出现的最后位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            lastIndex[charArray[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 准备工作都已完毕，接下来就可以开始遍历字符串s了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[charArray[i]-<span class="string">'a'</span>])&#123; <span class="comment">// 字母已经存在与栈中，直接continue</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意while循环中还要加上stack不为空</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; charArray[i]&lt;stack.peekLast() &amp;&amp; i&lt;lastIndex[stack.peekLast()-<span class="string">'a'</span>])&#123;</span><br><span class="line">                Character top = stack.removeLast();</span><br><span class="line">                visited[top-<span class="string">'a'</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(charArray[i]);</span><br><span class="line">            visited[charArray[i]-<span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历结束后，栈中结果即字典序最小</span></span><br><span class="line">        <span class="comment">// 因为我们使用ArrayDeque来模拟栈，所以当然可以直接遍历ArrayDeque</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Character character : stack) &#123;</span><br><span class="line">            stringBuilder.append(character);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>时间复杂度：O(n)，n为字符串s的长度</li>
<li>空间复杂度：O(n)，栈的最大深度</li>
</ul>
</blockquote>
<h1 id="1189-气球-的最大数量"><a class="markdownIt-Anchor" href="#1189-气球-的最大数量"></a> 1189. “气球” 的最大数量</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons/" target="_blank" rel="noopener">LeetCode 1189. “气球” 的最大数量</a></p>
<h2 id="模拟-7"><a class="markdownIt-Anchor" href="#模拟-7"></a> 模拟</h2>
<p>这是一道模拟的简单题，只要读懂题意就很容易写出来。</p>
<p>首先定义一个长度为5的<code>int</code>数组words，因为单词<strong>balloon</strong>的单词种类有5种。然后读取<code>text</code>字符串中这五种单词的个数，注意<em>一个balloon单词需要2个l和2个o即可</em>。最后取words数组中的最小值即为最终结果。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNumberOfBalloons</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] array = text.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] words = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'a'</span>) &#123;</span><br><span class="line">                words[<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'b'</span>) &#123;</span><br><span class="line">                words[<span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'l'</span>) &#123;</span><br><span class="line">                words[<span class="number">2</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'n'</span>) &#123;</span><br><span class="line">                words[<span class="number">3</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'o'</span>) &#123;</span><br><span class="line">                words[<span class="number">4</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个balloon单词需要2个l和2个o</span></span><br><span class="line">        words[<span class="number">2</span>] = words[<span class="number">2</span>]/<span class="number">2</span>;</span><br><span class="line">        words[<span class="number">4</span>] = words[<span class="number">4</span>]/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = words[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count : words) &#123;</span><br><span class="line">            res = Math.min(res,count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1601-最多可达成的换楼请求数目"><a class="markdownIt-Anchor" href="#1601-最多可达成的换楼请求数目"></a> 1601. 最多可达成的换楼请求数目</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/" target="_blank" rel="noopener">LeetCode 1601. 最多可达成的换楼请求数目</a></p>
<h2 id="二进制枚举"><a class="markdownIt-Anchor" href="#二进制枚举"></a> 二进制枚举</h2>
<p>参考<a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/solution/gong-shui-san-xie-er-jin-zhi-mei-ju-by-a-enef/" target="_blank" rel="noopener">宫水三叶</a>大佬的题解。</p>
<p>为了方便，我们令数组 <code>requests</code>的长度为 <code>m</code>。数据范围很小，<code>n</code>的范围为 <code>20</code>，而 <code>m</code>的范围为 <code>16</code>。</p>
<p>根据每个 <code>requests[i]</code> 是否选择与否，共有 <code>2^m</code>种状态（不超过 70000种状态）。我们可以采用<strong>二进制枚举</strong>的思路来求解，使用<strong>二进制数</strong>  <code>state</code> 来表示对 <code>requests[i]</code>的选择情况，当 <code>state</code> 的第 <code>k</code> 位为 <code>1</code>，代表 <code>requests[k]</code> 被选择。</p>
<p>我们枚举所有的 <code>state</code> 并<strong>进行合法性检查</strong>，从中<strong>选择出包含请求数的最多</strong>（二进制表示中包含 <code>1</code> 个数最多）的合法 state，其包含的请求数量即是答案。</p>
<blockquote>
<p>其中<strong>统计state中1的个数</strong>可以使用 <code>lowbit</code>，复杂度为 O(m)，<strong>判断合法性</strong>则直接<strong>模拟</strong>即可（<strong>统计每座建筑的进出数量，最后判定进出数不相等的建筑数量是为 0</strong>），复杂度为 O(m)，整体计算量为不超过 <code>2*10^6</code>，可以过。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] rs; <span class="comment">// 定义全局变量，方便后续生成的两个函数对requests的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumRequests</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] requests)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        rs = requests;</span><br><span class="line">        <span class="keyword">int</span> m = rs.length;  <span class="comment">// m个请求</span></span><br><span class="line">        <span class="comment">// 二进制枚举，需要一个m位的二进制数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getCurrent(i);</span><br><span class="line">            <span class="keyword">if</span> (ans&gt;current)&#123;   <span class="comment">// 没有比ans大，无需判断合法性</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check(i))&#123;  <span class="comment">// 判断合法性</span></span><br><span class="line">                ans = current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合法性判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 十进制要转成二进制，其中第k位为1，代表requests[k]被选择</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 合法返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];    <span class="comment">// 最多20栋楼</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;  <span class="comment">// 根据题意，num转二进制最多16位（最多16个请求）</span></span><br><span class="line">            <span class="keyword">if</span> (((num&gt;&gt;i)&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;   <span class="comment">// 位运算。其实就是第i位是1</span></span><br><span class="line">                <span class="keyword">int</span> from = rs[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> to = rs[i][<span class="number">1</span>];</span><br><span class="line">                arr[from]--;</span><br><span class="line">                arr[to]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>)&#123;  <span class="comment">// 只要有一个不为0，就要返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个十进制数转换成二进制数后，其中1的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 给定的十进制数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回该十进制数转换成二进制数后，其中1的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCurrent</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i != <span class="number">0</span>; i = i-(i&amp;-i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：令 <code>m</code> 为 <code>requests</code> 长度，共有 <code>2^m</code>种选择状态，计算每个状态的所包含的问题数量复杂度为 O(m)，计算某个状态是否合法复杂度为 O(m)；整体复杂度为 O(<code>2^m * m</code>)。</li>
<li>空间复杂度：O(n)</li>
</ul>
</blockquote>
<p>这题进行了大量的位运算，对于对应代码再进行一些解释：</p>
<p>左移运算<code>&lt;&lt;</code>和右移运算<code>&gt;&gt;</code>就不多说了。（<a href="https://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener">Java 运算符</a>）</p>
<p>首先是<code>getCurrent</code>方法。它的作用就是返回<strong>一个十进制数num，转换为二进制数后二进制中1的个数</strong>。在实现时，用到了<code>lowbit</code> 运算。具体体现在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num; i != <span class="number">0</span>; i = i-(i&amp;-i)) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lowbit</code>还有另一种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num; i != <span class="number">0</span>; i = i&amp;(i-<span class="number">1</span>)) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/lesileqin/article/details/102418143" target="_blank" rel="noopener">【位运算】深入理解并证明 lowbit 运算</a></p>
<p>接下来是<code>check</code>方法。这是我们用来判断合法性的方法。其中<code>if (((num&gt;&gt;i)&amp;1) == 1)</code>的意思其实就是二进制数中第<code>i</code>位为1。</p>
<p><code>check</code>方法的实现逻辑，可以画个草图如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153717.png" alt="" /></p>
<h1 id="1705-吃苹果的最大数目"><a class="markdownIt-Anchor" href="#1705-吃苹果的最大数目"></a> 1705. 吃苹果的最大数目</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/" target="_blank" rel="noopener">LeetCode 1705. 吃苹果的最大数目</a></p>
<h2 id="小根堆贪心"><a class="markdownIt-Anchor" href="#小根堆贪心"></a> 小根堆+贪心</h2>
<p>这题根据题目意思，很容易就知道可以使用小根堆+算法来解决。我们向小根堆里存苹果最早腐败的天数，即<code>i+days[i]</code>。贪心思想就是：每次都poll出<code>i+days[i]</code>最小的苹果，这样就可以保证能吃到最多的苹果。</p>
<p>因为<code>0 &lt;= apples[i], days[i] &lt;= 2 * 104</code>，所以我们<strong>不可能将苹果一个一个的add到小根堆中</strong>。这里我的处理是<strong>新建一个Apple类</strong>，其中有两个成员变量：date和count，分别表示第date天就不能吃了和苹果的数量。然后让其实现Comparable接口，是Apple类按照date的值进行升序排序。Apple类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Apple</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> date;   <span class="comment">// 第date天开始就不能吃了，即date=i + days[i]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;  <span class="comment">// 苹果的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">int</span> date, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Apple o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.date - o.date;  <span class="comment">// 根据apple的date进行升序排列（自然排列）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的逻辑就比较好理解了，poll一个apple对象，比较其<code>date</code>和<code>i</code>的关系，若<code>poll.date&gt;i</code>，则说明可以吃这个苹果；n天结束后还要继续进行while循环，直到小根堆为空。这里的逻辑非常好理解，稍微打下草稿就能搞懂。</p>
<p>这里就直接给出代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Apple</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> date;   <span class="comment">// 第date天开始就不能吃了，即date=i + days[i]</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> count;  <span class="comment">// 苹果的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">int</span> date, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.date = date;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Apple o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.date - o.date;  <span class="comment">// 根据apple的date进行升序排列（自然排列）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eatenApples</span><span class="params">(<span class="keyword">int</span>[] apples, <span class="keyword">int</span>[] days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = apples.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 已经重写Apple类的compareTo方法了，优先队列会根据apple的date进行升序排列</span></span><br><span class="line">        PriorityQueue&lt;Apple&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 第一个for循环，是n天之前的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (apples[i]&gt;<span class="number">0</span>)&#123;   <span class="comment">// apples[i]=0，没有必要将其add到小根堆中</span></span><br><span class="line">                priorityQueue.add(<span class="keyword">new</span> Apple(i+days[i],apples[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始吃苹果</span></span><br><span class="line">            <span class="keyword">while</span> (!priorityQueue.isEmpty())&#123;</span><br><span class="line">                Apple poll = priorityQueue.poll();</span><br><span class="line">                <span class="keyword">if</span> (poll.date&gt;i)&#123;    <span class="comment">// 可以吃</span></span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="comment">// 吃完苹果count--，如果不为0还要add到小根堆中</span></span><br><span class="line">                    poll.count--;</span><br><span class="line">                    <span class="keyword">if</span> (poll.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        priorityQueue.add(poll);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 一天只能吃一个，吃了就退出while循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for循环结束后，在这n天之后可以继续吃苹果</span></span><br><span class="line">        <span class="keyword">int</span> day = n;</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty())&#123;</span><br><span class="line">            Apple poll = priorityQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll.date&gt;day)&#123;    <span class="comment">// 可以吃</span></span><br><span class="line">                ans++;</span><br><span class="line">                <span class="comment">// 吃完苹果count--，如果不为0还要add到小根堆中</span></span><br><span class="line">                poll.count--;</span><br><span class="line">                <span class="keyword">if</span> (poll.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    priorityQueue.add(poll);</span><br><span class="line">                &#125;</span><br><span class="line">                day++;  <span class="comment">// 一天只能吃一个，吃完就day++</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>时间复杂度：n为数组长度，最多有n组苹果入堆/出堆。复杂度为O(nlogn)（<strong>因为小根堆的add和poll操作时间复杂度均为O(log n)</strong>）</li>
<li>空间复杂度：O(n)</li>
</ul>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/449350268" target="_blank" rel="noopener">宫水三叶</a>大佬在这题中的解决思路跟我差不多，但是在代码上是直接往小根堆中存储二维数组的。</p>
<p>大佬代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eatenApples</span><span class="params">(<span class="keyword">int</span>[] apples, <span class="keyword">int</span>[] days)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = apples.length, time = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (time &lt; n || !q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &lt; n &amp;&amp; apples[time] &gt; <span class="number">0</span>) q.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;time + days[time] - <span class="number">1</span>, apples[time]&#125;);</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; q.peek()[<span class="number">0</span>] &lt; time) q.poll();</span><br><span class="line">            <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (--cur[<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; cur[<span class="number">0</span>] &gt; time) q.add(cur);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            time++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="1706-球会落何处"><a class="markdownIt-Anchor" href="#1706-球会落何处"></a> 1706. 球会落何处</h1>
<p><a href="https://leetcode-cn.com/problems/where-will-the-ball-fall/" target="_blank" rel="noopener">LeetCode 1706. 球会落何处</a></p>
<h2 id="模拟-8"><a class="markdownIt-Anchor" href="#模拟-8"></a> 模拟</h2>
<p>参考<a href="https://leetcode-cn.com/problems/where-will-the-ball-fall/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-jz6f/" target="_blank" rel="noopener">宫水三叶</a>大佬题解</p>
<p>本题的关键是要通过模拟将小球的运动在代码上体现出来，即<strong>要记录小球坐标的变化</strong>。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153754.png" alt="" /></p>
<p>我们使用 <code>r</code> 和 <code>c</code> 表示小球当前所处的位置，受重力影响，在不被卡住的情况下，<code>r</code> 会<strong>持续自增</strong>，直到到达底部；而 <code>c</code> 的变化，则是取决于当前挡板 <code>grid[r][c]</code> 的方向：</p>
<ul>
<li>若 <code>grid[r][c]</code> 为 1，则小球的下一个位置为<code>(r+1,c+1)</code>；</li>
<li>若 <code>grid[r][c]</code> 为−1，则下一位置为<code>(r+1,c−1)</code>。</li>
</ul>
<p>即可以统一表示为<code>(r+1,c+grid[r][c])</code>。</p>
<p><strong>当且仅当小球在本次移动过程中没被卡住，才能继续移动</strong>。没有被卡住的情况有：</p>
<ul>
<li><code>c+grid[r][c]</code> 没有超过矩阵的左右边界（没有被边界卡住）；</li>
<li>并且 <code>grid[r][c]</code> 和 <code>grid[r][c+grid[r][c]]</code> 同向（不形成夹角）。</li>
</ul>
<p>将以上信息理清楚了，代码就很好写了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  m*n的二维网格grid</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findBall(<span class="keyword">int</span>[][] grid) &#123;</span><br><span class="line">        <span class="comment">//  m*n的二维网格grid</span></span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;   <span class="comment">// 开始遍历每个小球</span></span><br><span class="line">            ans[i] = getValue(i, grid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算小球落下的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 小球初始所在位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid 题目所给的二维网格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 小球不能落下则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = x;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;m)&#123;    <span class="comment">// r&lt;m,则说明小球还没有落地</span></span><br><span class="line">            <span class="keyword">int</span> next = c+grid[r][c];    <span class="comment">// 小球下一个到的横坐标位置</span></span><br><span class="line">            <span class="keyword">if</span> (next&lt;<span class="number">0</span> || next &gt; n-<span class="number">1</span>)&#123;    <span class="comment">// 超过网格边界，被网格卡住（注意是next &gt; n-1）</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c]!=grid[r][next])&#123; <span class="comment">// 楼梯不同向，被卡住</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有被卡住的情况,更新小球的坐标即可</span></span><br><span class="line">            r++;</span><br><span class="line">            c = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 能够跑完完整的while循环，说明小球落地了</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(m*n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</blockquote>
<h1 id="1725-可以形成最大正方形的矩形数目"><a class="markdownIt-Anchor" href="#1725-可以形成最大正方形的矩形数目"></a> 1725. 可以形成最大正方形的矩形数目</h1>
<p><a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/" target="_blank" rel="noopener">LeetCode 1725. 可以形成最大正方形的矩形数目</a></p>
<h2 id="模拟-9"><a class="markdownIt-Anchor" href="#模拟-9"></a> 模拟</h2>
<p>这是一道简单模拟题，只要读懂题意就很容易写出题解。</p>
<p>我们只需要先求出各个矩形中能得出的最大正方形边长，将其存放于于side数组中，最后求出side数组中最大值的个数即为结果。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countGoodRectangles</span><span class="params">(<span class="keyword">int</span>[][] rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] side = <span class="keyword">new</span> <span class="keyword">int</span>[rectangles.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rectangles.length; i++) &#123;</span><br><span class="line">            side[i] = Math.min(rectangles[i][<span class="number">0</span>], rectangles[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(side);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = side.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (side[i]!=side[side.length-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实代码可以写的更优雅一点，根据三叶大佬的<a href="https://zhuanlan.zhihu.com/p/463884836" target="_blank" rel="noopener">题解</a>，可以得出代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countGoodRectangles</span><span class="params">(<span class="keyword">int</span>[][] rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rectangle : rectangles) &#123;</span><br><span class="line">            current = Math.min(rectangle[<span class="number">0</span>], rectangle[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (current==max)&#123;  <span class="comment">// 当前边长为最大值，结果+1</span></span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current&gt;max)&#123;   <span class="comment">// 出现了新的最大值，result归1</span></span><br><span class="line">                max = current;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省去了上面对side数组排序的过程（<code>Arrays.sort(side);</code>）</p>
</blockquote>
<h1 id="1996-游戏中弱角色的数量"><a class="markdownIt-Anchor" href="#1996-游戏中弱角色的数量"></a> 1996. 游戏中弱角色的数量</h1>
<p><a href="https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/" target="_blank" rel="noopener">LeetCode 1996. 游戏中弱角色的数量</a></p>
<h2 id="排序-2"><a class="markdownIt-Anchor" href="#排序-2"></a> 排序</h2>
<p><a href="https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/solution/you-xi-zhong-ruo-jiao-se-de-shu-liang-by-3d2g/" target="_blank" rel="noopener">官方题解</a></p>
<p>在读懂题意后，可以<strong>巧妙地进行排序</strong>，然后就可以一次for循环解决问题了。</p>
<p>我们自定义的排序规则为：</p>
<ul>
<li><strong>攻击力atk降序排序</strong>；</li>
<li>atk相等的看作同一组，在atk相等的情况下，即<strong>同一组内，按def升序排序。</strong></li>
</ul>
<p>以下是我当时简单画的草稿，主要稍微理解题意，打下草稿，就能看懂题解代码了。</p>
<blockquote>
<p>由于我们在同一组内，def按升序排序，所以只要出现<code>property[1]&lt;maxDefense</code>的情况，一定是遍历到下一组了；而由于atk按降序排序，下一组的atk一定小于上一组，所以此时遍历到的即为弱角色。</p>
</blockquote>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153820.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfWeakCharacters</span><span class="params">(<span class="keyword">int</span>[][] properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(properties, (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1[<span class="number">0</span>]!=o2[<span class="number">0</span>])&#123;  <span class="comment">// 攻击力不一样，按攻击力降序排序</span></span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">0</span>]-o1[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 攻击力一样，按防御力升序排序</span></span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> maxDefense = properties[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] property : properties) &#123;</span><br><span class="line">            <span class="keyword">if</span> (property[<span class="number">1</span>]&lt;maxDefense)&#123;    <span class="comment">// 同一个组内，def降序，所以出现这种情况说明一定遍历到下一组了</span></span><br><span class="line">                result++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                maxDefense = property[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(nlogn)，其中 n为数组的长度。<strong>排序的时间复杂度为 O(nlogn)</strong>，遍历数组的时间为 O(n)，总的时间复杂度为O(nlogn+n)=O(nlogn)。</li>
<li>空间复杂度：O(logn)，其中 n为数组的长度。<strong>排序时使用的栈空间为O(logn)。</strong></li>
</ul>
</blockquote>
<p>注意一下上述代码的Lambda表达式，其原始形式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(properties, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1[<span class="number">0</span>]!=o2[<span class="number">0</span>])&#123;  <span class="comment">// 攻击力不一样，按攻击力降序排序</span></span><br><span class="line">            <span class="keyword">return</span> o2[<span class="number">0</span>]-o1[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 攻击力一样，按防御力升序排序</span></span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="2000-反转单词前缀"><a class="markdownIt-Anchor" href="#2000-反转单词前缀"></a> 2000. 反转单词前缀</h1>
<p><a href="https://leetcode-cn.com/problems/reverse-prefix-of-word/" target="_blank" rel="noopener">LeetCode 2000. 反转单词前缀</a></p>
<h2 id="模拟双指针-2"><a class="markdownIt-Anchor" href="#模拟双指针-2"></a> 模拟+双指针</h2>
<p>这是一道模拟简单题，读懂题意差不多就可以解出来了。首先要找到字符<code>ch</code>所在的索引index，其次<strong>稍微麻烦一点的就是要逆转0到index的字符串</strong>，这里使用<strong>双指针</strong>来完成。双指针部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后利用双指针反转从0到index的字符</span></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = index;</span><br><span class="line"><span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = chars[l];</span><br><span class="line">    chars[l] = chars[r];</span><br><span class="line">    chars[r] = temp;</span><br><span class="line">    l++;</span><br><span class="line">    r--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reversePrefix</span><span class="params">(String word, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 首先找到ch的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i]==ch)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后利用双指针反转从0到index的字符</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = index;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[l];</span><br><span class="line">            chars[l] = chars[r];</span><br><span class="line">            chars[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);   <span class="comment">// 字符数组转字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2016-增量元素之间的最大差值"><a class="markdownIt-Anchor" href="#2016-增量元素之间的最大差值"></a> 2016. 增量元素之间的最大差值</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/" target="_blank" rel="noopener">LeetCode 2016. 增量元素之间的最大差值</a></p>
<h2 id="暴力算法-4"><a class="markdownIt-Anchor" href="#暴力算法-4"></a> 暴力算法</h2>
<p>根据题意，套一个双循环依次遍历即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumDifference</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]&lt;nums[j])&#123;</span><br><span class="line">                    ans = Math.max(ans, nums[j]-nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心算法-8"><a class="markdownIt-Anchor" href="#贪心算法-8"></a> 贪心算法</h2>
<p><a href="https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/solution/zeng-liang-yuan-su-zhi-jian-de-zui-da-ch-i0wk/" target="_blank" rel="noopener">官方题解</a></p>
<p>上面的暴力算法，套了两层for循环，时间复杂度为O(n^2)。但是其实i指针没有必要依次遍历每个数组。</p>
<p>贪心思想：当我们固定 <code>j</code> 时，选择的下标 <code>i</code> 一定是满足<code>0&lt;=i&lt;j&lt;n</code> 并且 <code>nums[i]</code> 最小的那个 <code>i</code>。</p>
<p>所以我们要记录一下前缀最小值<code>min</code>，在遍历<code>i</code>的时候，有以下两种情况：</p>
<ul>
<li><code>nums[i]&gt;min</code>：更新ans为<code>Math.max(ans, nums[i]-min);</code></li>
<li><code>nums[i]&lt;=min</code>：更新<code>min</code>为<code>nums[i]</code></li>
</ul>
<p>举个例子：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220713181222.png" alt="" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumDifference</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;min)&#123;</span><br><span class="line">                ans = Math.max(ans, nums[i]-min);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2100-适合打劫银行的日子"><a class="markdownIt-Anchor" href="#2100-适合打劫银行的日子"></a> 2100. 适合打劫银行的日子</h1>
<p><a href="https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/" target="_blank" rel="noopener">LeetCode 2100. 适合打劫银行的日子</a></p>
<h2 id="暴力算法tle-2"><a class="markdownIt-Anchor" href="#暴力算法tle-2"></a> 暴力算法（TLE）</h2>
<p>最开始写的暴力算法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">goodDaysToRobBank</span><span class="params">(<span class="keyword">int</span>[] security, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = security.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = time; i&lt;=length-<span class="number">1</span>-time; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check(i,security,time))&#123;    <span class="comment">// 检测合法性</span></span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据题意检测index的合法性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> security</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] security, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向左检测i的合法性</span></span><br><span class="line">        <span class="keyword">int</span> l = i-time;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (security[l]&lt;security[l+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向右检测i的合法性</span></span><br><span class="line">        <span class="keyword">int</span> r = i;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;i+time)&#123;</span><br><span class="line">            <span class="keyword">if</span> (security[r]&gt;security[r+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是会报<code>Time Limit Exceeded</code>。</p>
<h2 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h2>
<p>参考三叶大佬题解。</p>
<h1 id="2104-子数组范围和"><a class="markdownIt-Anchor" href="#2104-子数组范围和"></a> 2104. 子数组范围和</h1>
<p><a href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/" target="_blank" rel="noopener">LeetCode 2104. 子数组范围和</a></p>
<h2 id="暴力算法-5"><a class="markdownIt-Anchor" href="#暴力算法-5"></a> 暴力算法</h2>
<p>暴力算法思路很清晰，就是遍历每一个区间（每一个子数组），记录当前子区间的最大值<code>max</code>和最小值<code>min</code>即可。直接看代码就明白了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">subArrayRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = nums[i];</span><br><span class="line">            <span class="keyword">int</span> min = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;   <span class="comment">// 因为子数组只有一个的话范围为0，所以j可以从i+1开始</span></span><br><span class="line">                max = Math.max(max, nums[j]);</span><br><span class="line">                min = Math.min(min, nums[j]);</span><br><span class="line">                res = res + (max-min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈on"><a class="markdownIt-Anchor" href="#单调栈on"></a> 单调栈（O(N)）</h2>
<p>参考<a href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/solution/gong-shui-san-xie-yi-ti-san-jie-qu-jian-wn84z/" target="_blank" rel="noopener">宫水三叶</a>大佬题解。</p>
<p>在上述暴力算法的基础上，我们进行如下思考：</p>
<p>假设有 <code>m</code> 个区间，最终的表达式为 <code>m</code> 个 <code>max−min</code> 之和。</p>
<p>若某个 <code>nums[i]</code> ，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个区间中充当最大值，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">k_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个区间中充当最小值，则在最终等式中以 <code>max</code>的形式出现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 次，在最终等式中以 <code>min</code>形式出现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">k_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 次。</p>
<p>因此我们可以统计每个 <code>nums[i]</code> 成为区间最大值的次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和成为区间最小值的次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">k_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，							   ( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">k_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ) <code>*nums[i]</code>即为 <code>nums[i]</code> 对于最终答案的贡献。</p>
<p>这样就把问题转换为统计每一个nums[i]成为区间最大值的次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和成为区间最小值的次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">k_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 了。</p>
<p>考虑如何统计每个 <code>nums[i]</code>  成为区间最值的次数：</p>
<ul>
<li><code>nums[i]</code>  <strong>作为区间最大值的次数</strong>：找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">n u m s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 左右<strong>最近一个大于</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">n u m s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的位置， 记其为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 。此时区间左端点共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">i-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 个选择，区间右端点共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">r-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个选择，根据乘法原理， 区间个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>l</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-l) *(r-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 个；</li>
<li><code>nums[i]</code>  <strong>作为区间最小值的次数</strong>：同理，找到 nums <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 左右<strong>最近一个小于</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">n u m s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的 位置，记其为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> ，区间个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>l</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i-l) *(r-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 个。</li>
</ul>
<p>以上两种，如果走到尽头还没有找到符合条件的，那么就继续再走一步结束。即:</p>
<ul>
<li><strong>向左没有找到最近一个满足xxx的值，记为-1</strong></li>
<li><strong>向右没有找到最近一个满足xxx的值，记为length</strong></li>
</ul>
<p>看起来可能比较麻烦，但是画个草图就很容易搞懂了：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153847.png" alt="" /></p>
<p>即问题切换为：使用<strong>单调栈</strong>找到某个<code>nums[i]</code>的左边/右边的最近一个符合某种性质的位置，从而知道 <code>nums[i]</code>作为区间最值时，左右端点的可选择个数，再结合乘法原理知道<code>nums[i]</code>能够作为区间最值的区间个数，从而知道<code>nums[i]</code>对答案的贡献。</p>
<p><strong>值得注意的是</strong>，由于 <code>nums[i]</code>  <strong>存在相同元素</strong>，因此上述两边均取等号的做法会导致某些区间被重复计算，因此我们可以**<mark>令最近右端点的部分不取等号</mark>，确保区间统计不重不漏。**</p>
<p>举个例子：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502153905.png" alt="" /></p>
<p>代码体现在：</p>
<ul>
<li>
<p>我们在统计<code>nums[i]</code>时，记录向左能扩展的距离：单调栈满足条件如下：<code>nums[stack.peekLast()]&gt;=nums[i]</code></p>
</li>
<li>
<p>我们在统计<code>nums[i]</code>时，记录向右能扩展的距离：单调栈满足条件如下：<code>nums[stack.peekLast()]&gt;nums[i]</code></p>
<p>（以上两种都以<code>nums[i]</code>作为min为例）</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">subArrayRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        length = nums.length;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// min[i]为nums[i]作为区间最小值的次数；max[i]为nums[i]作为区间最大值的次数</span></span><br><span class="line">        <span class="keyword">long</span>[] min = getCnt(nums, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">long</span>[] max = getCnt(nums, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            res = res + (max[i]-min[i])*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个nums[]数组，返回一个min[]数组或max[]数组（单调栈实现）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 给定nums数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag flag为true返回min[]数组；为false返回max[]数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] getCnt(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span> flag) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];  <span class="comment">// 向左最近一个……</span></span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[length];  <span class="comment">// 向右最近一个……</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();  <span class="comment">// 因为单调栈要求的是最近一个xxx的索引，所以存储的也是索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里用三元表达式，根据flag的不同来决定是返回min[]还是max[]</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; (flag? nums[stack.peekLast()]&gt;=nums[i]:nums[stack.peekLast()]&lt;=nums[i]))&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] = stack.isEmpty()? -<span class="number">1</span>:stack.peekLast();</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; (flag? nums[stack.peekLast()]&gt;nums[i]:nums[stack.peekLast()]&lt;nums[i]))&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            b[i] = stack.isEmpty()? length: stack.peekLast();</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span>[] ans = <span class="keyword">new</span> <span class="keyword">long</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            ans[i] = (<span class="keyword">long</span>) (i-a[i])*(b[i]-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n)，其中 n 为数组的大小。使用单调栈预处理出四个数组需要 O(n)，计算最大值之和与最小值之和需要 O(n)。</li>
<li>空间复杂度：O(n)。保存四个数组需要 O(n)；单调栈最多保存 n 个元素，需要 O(n))。</li>
</ul>
</blockquote>
<p>关于单调栈的具体实现画一下草图就能搞懂，这里就不再画一遍了。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:qingbo1011@163.com">qingbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.qingbo1011.top/2021/11/26/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">http://www.qingbo1011.top/2021/11/26/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.qingbo1011.top" target="_blank">Qing's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20231003161115.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/04/23/Golang%E5%9F%BA%E7%A1%8001/"><img class="prev_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Golang基础（一）</div></div></a></div><div class="next-post pull_right"><a href="/2021/10/27/%E4%B8%83%E7%89%9B%E4%BA%91%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6/"><img class="next_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212727.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何续七牛云免费证书</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/03/25/JDBC（一）/" title="JDBC（一）"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220508214453.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-25</div><div class="relatedPosts_title">JDBC（一）</div></div></a></div><div class="relatedPosts_item"><a href="/2021/03/28/JDBC（二）/" title="JDBC（二）"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220508214453.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-28</div><div class="relatedPosts_title">JDBC（二）</div></div></a></div><div class="relatedPosts_item"><a href="/2021/04/27/Java@Test注解问题/" title="Java@Test注解问题"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502155231.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-04-27</div><div class="relatedPosts_title">Java@Test注解问题</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/04/Java数据结构之图/" title="Java数据结构之图"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-04</div><div class="relatedPosts_title">Java数据结构之图</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/01/Java数据结构之基础知识/" title="Java数据结构之基础知识"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-01</div><div class="relatedPosts_title">Java数据结构之基础知识</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/05/Java数据结构之堆、散列、并查集/" title="Java数据结构之堆（优先队列）、散列（哈希表）和并查集"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503132929.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-05</div><div class="relatedPosts_title">Java数据结构之堆（优先队列）、散列（哈希表）和并查集</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'oNS5Emx1qUL3wN5yvPLKol0W-gzGzoHsz',
  appKey: 'ytbw0ho3DMX0FeoAOWa37lf9',
  notify: false,
  verify: false,
  placeholder: 'Stay hungry,stay foolish~',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: 'https://',
  emojiMaps: {"欢呼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100836.gif","笑眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100849.gif","花心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100907.gif","吐舌":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100937.gif","疑问":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100951.gif","滑稽":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101004.gif","太开心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101017.gif","酷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101029.gif","怒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101044.gif","阴险":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101100.gif","委屈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101116.gif","乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101129.gif","你懂的":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101204.gif","小乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101215.gif","突然兴奋":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101228.gif","喷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101241.gif","哈哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101255.gif","喝酒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101305.gif","汗":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101323.gif","笑尿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102004.gif","嘿嘿嘿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102018.gif","真棒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102047.gif","托腮":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102108.gif","微笑":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","礼貌":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","笑哭":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","无奈":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","爱你":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","吃瓜":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_thumb.png","doge":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","dog":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","cat":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_thumb.png","星星眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102225.png","酸了":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102240.png","大哭":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102254.png","傲娇":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102314.png","给心心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102328.png","嘿哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102345.png","custom0":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101410.gif","custom1":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101424.webp","狗头":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101710.png","搬砖中":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101744.png","忙到飞起":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102411.png","裂开":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102426.png","叹气":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102439.png","让我看看":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102456.png","panda0":"https://bbs.res.meizu.com/static/image/smiley/panda/_000.png","panda1":"https://bbs.res.meizu.com/static/image/smiley/panda/_001.png","panda2":"https://bbs.res.meizu.com/static/image/smiley/panda/_002.png","panda3":"https://bbs.res.meizu.com/static/image/smiley/panda/_003.png","panda4":"https://bbs.res.meizu.com/static/image/smiley/panda/_004.png","panda5":"https://bbs.res.meizu.com/static/image/smiley/panda/_005.png","panda6":"https://bbs.res.meizu.com/static/image/smiley/panda/_006.png","panda7":"https://bbs.res.meizu.com/static/image/smiley/panda/_007.png","panda8":"https://bbs.res.meizu.com/static/image/smiley/panda/_008.png","panda9":"https://bbs.res.meizu.com/static/image/smiley/panda/_009.png","panda10":"https://bbs.res.meizu.com/static/image/smiley/panda/_010.png","panda11":"https://bbs.res.meizu.com/static/image/smiley/panda/_011.png","panda12":"https://bbs.res.meizu.com/static/image/smiley/panda/_012.png","panda13":"https://bbs.res.meizu.com/static/image/smiley/panda/_013.png","panda14":"https://bbs.res.meizu.com/static/image/smiley/panda/_014.png","panda15":"https://bbs.res.meizu.com/static/image/smiley/panda/_015.png","panda16":"https://bbs.res.meizu.com/static/image/smiley/panda/_016.png","panda17":"https://bbs.res.meizu.com/static/image/smiley/panda/_017.png","panda18":"https://bbs.res.meizu.com/static/image/smiley/panda/_018.png","panda19":"https://bbs.res.meizu.com/static/image/smiley/panda/_019.png","panda20":"https://bbs.res.meizu.com/static/image/smiley/panda/_020.png","panda21":"https://bbs.res.meizu.com/static/image/smiley/panda/_021.png","panda22":"https://bbs.res.meizu.com/static/image/smiley/panda/_022.png","panda23":"https://bbs.res.meizu.com/static/image/smiley/panda/_023.png","panda24":"https://bbs.res.meizu.com/static/image/smiley/panda/_024.png","panda25":"https://bbs.res.meizu.com/static/image/smiley/panda/_025.png","panda26":"https://bbs.res.meizu.com/static/image/smiley/panda/_026.png","panda27":"https://bbs.res.meizu.com/static/image/smiley/panda/_027.png","panda28":"https://bbs.res.meizu.com/static/image/smiley/panda/_028.png","panda29":"https://bbs.res.meizu.com/static/image/smiley/panda/_029.png"},
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220806220141.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By qingbo</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">宇宙很大，生活更大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script></body></html>
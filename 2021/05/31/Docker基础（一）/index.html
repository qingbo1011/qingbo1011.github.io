<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Docker基础（一） | Qing's Blog</title><meta name="description" content="Docker基础（一） Docker——从入门到实践（本笔记重点参考文章，强烈推荐看原文） Docker中文文档（强烈推荐作为补充文章观看） Docker官网 docker中文 Play with Docker（A simple, interactive and fun playground to learn Docker） 首先在学习Docker之前，我们要先学习一下Linux基础，特别注意一"><meta name="keywords" content="Docker基础（一）笔记"><meta name="author" content="qingbo,qingbo1011@163.com"><meta name="copyright" content="qingbo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Docker基础（一）"><meta name="twitter:description" content="Docker基础（一） Docker——从入门到实践（本笔记重点参考文章，强烈推荐看原文） Docker中文文档（强烈推荐作为补充文章观看） Docker官网 docker中文 Play with Docker（A simple, interactive and fun playground to learn Docker） 首先在学习Docker之前，我们要先学习一下Linux基础，特别注意一"><meta name="twitter:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503161842.png"><meta property="og:type" content="article"><meta property="og:title" content="Docker基础（一）"><meta property="og:url" content="http://www.qingbo1011.top/2021/05/31/Docker%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"><meta property="og:site_name" content="Qing's Blog"><meta property="og:description" content="Docker基础（一） Docker——从入门到实践（本笔记重点参考文章，强烈推荐看原文） Docker中文文档（强烈推荐作为补充文章观看） Docker官网 docker中文 Play with Docker（A simple, interactive and fun playground to learn Docker） 首先在学习Docker之前，我们要先学习一下Linux基础，特别注意一"><meta property="og:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503161842.png"><meta property="article:published_time" content="2021-05-31T00:47:03.000Z"><meta property="article:modified_time" content="2023-10-03T08:16:11.745Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://www.qingbo1011.top/2021/05/31/Docker%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"><link rel="prev" title="Docker基础（二）" href="http://www.qingbo1011.top/2021/05/31/Docker%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"><link rel="next" title="Spring（二）" href="http://www.qingbo1011.top/2021/05/17/Spring02/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230440.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">87</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">81</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#docker基础一"><span class="toc-number">1.</span> <span class="toc-text"> Docker基础（一）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker简介"><span class="toc-number">2.</span> <span class="toc-text"> Docker简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是docker"><span class="toc-number">2.1.</span> <span class="toc-text"> 什么是Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要用-docker"><span class="toc-number">2.2.</span> <span class="toc-text"> 为什么要用 Docker</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker基本概念"><span class="toc-number">3.</span> <span class="toc-text"> Docker基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#镜像image"><span class="toc-number">3.1.</span> <span class="toc-text"> 镜像（Image）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分层存储"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 分层存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器container"><span class="toc-number">3.2.</span> <span class="toc-text"> 容器（Container）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#仓库repository"><span class="toc-number">3.3.</span> <span class="toc-text"> 仓库（Repository）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-registry-公开服务"><span class="toc-number">3.3.1.</span> <span class="toc-text"> Docker Registry 公开服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#私有-docker-registry"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 私有 Docker Registry</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker安装"><span class="toc-number">4.</span> <span class="toc-text"> Docker安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装docker"><span class="toc-number">4.1.</span> <span class="toc-text"> 安装Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#卸载旧版本"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 卸载旧版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装新docker"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 安装新docker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动docker"><span class="toc-number">4.2.</span> <span class="toc-text"> 启动Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建立docker用户组"><span class="toc-number">4.3.</span> <span class="toc-text"> 建立docker用户组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试docker是否安装正确"><span class="toc-number">4.4.</span> <span class="toc-text"> 测试Docker是否安装正确</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置镜像加速"><span class="toc-number">4.5.</span> <span class="toc-text"> 配置镜像加速</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker常用命令"><span class="toc-number">5.</span> <span class="toc-text"> Docker常用命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用镜像"><span class="toc-number">6.</span> <span class="toc-text"> 使用镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#管理本地主机上的镜像"><span class="toc-number">6.1.</span> <span class="toc-text"> 管理本地主机上的镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#列出镜像"><span class="toc-number">6.1.1.</span> <span class="toc-text"> 列出镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#镜像体积"><span class="toc-number">6.1.1.1.</span> <span class="toc-text"> 镜像体积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚悬镜像"><span class="toc-number">6.1.1.2.</span> <span class="toc-text"> 虚悬镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中间层镜像"><span class="toc-number">6.1.1.3.</span> <span class="toc-text"> 中间层镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除镜像"><span class="toc-number">6.1.2.</span> <span class="toc-text"> 删除镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从仓库获取镜像"><span class="toc-number">6.2.</span> <span class="toc-text"> 从仓库获取镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作容器"><span class="toc-number">7.</span> <span class="toc-text"> 操作容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器启动-停止和重启"><span class="toc-number">7.1.</span> <span class="toc-text"> 容器启动、停止和重启</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#新建并启动"><span class="toc-number">7.1.1.</span> <span class="toc-text"> 新建并启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动已终止容器"><span class="toc-number">7.1.2.</span> <span class="toc-text"> 启动已终止容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列出当前容器"><span class="toc-number">7.2.</span> <span class="toc-text"> 列出当前容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除容器"><span class="toc-number">7.3.</span> <span class="toc-text"> 删除容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#守护态运行"><span class="toc-number">7.4.</span> <span class="toc-text"> 守护态运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进入容器"><span class="toc-number">7.5.</span> <span class="toc-text"> 进入容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#attach命令"><span class="toc-number">7.5.1.</span> <span class="toc-text"> attach命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec命令推荐"><span class="toc-number">7.5.2.</span> <span class="toc-text"> exec命令（推荐）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查看容器日志和内部相关信息"><span class="toc-number">7.6.</span> <span class="toc-text"> 查看容器日志和内部相关信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看容器日志"><span class="toc-number">7.6.1.</span> <span class="toc-text"> 查看容器日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看容器内运行的进程"><span class="toc-number">7.6.2.</span> <span class="toc-text"> 查看容器内运行的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看容器内部细节"><span class="toc-number">7.6.3.</span> <span class="toc-text"> 查看容器内部细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器导出和导入"><span class="toc-number">7.7.</span> <span class="toc-text"> 容器导出和导入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#导出容器"><span class="toc-number">7.7.1.</span> <span class="toc-text"> 导出容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导入容器快照"><span class="toc-number">7.7.2.</span> <span class="toc-text"> 导入容器快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从容器内拷贝文件到主机上"><span class="toc-number">7.7.3.</span> <span class="toc-text"> 从容器内拷贝文件到主机上</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#访问仓库"><span class="toc-number">8.</span> <span class="toc-text"> 访问仓库</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503161842.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Qing's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Docker基础（一）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-05-31 08:47:03"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-05-31</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-10-03 16:16:11"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2023-10-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">10k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 32 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/05/31/Docker%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/05/31/Docker%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="docker基础一"><a class="markdownIt-Anchor" href="#docker基础一"></a> Docker基础（一）</h1>
<p><a href="https://yeasy.gitbook.io/docker_practice/introduction" target="_blank" rel="noopener"><strong>Docker——从入门到实践</strong></a>（本笔记重点参考文章，<strong><mark>强烈推荐看原文</mark></strong>）</p>
<p><strong><a href="http://www.dockerinfo.net/document" target="_blank" rel="noopener">Docker中文文档</a></strong>（强烈推荐作为补充文章观看）</p>
<p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker官网</a></p>
<p><strong><a href="https://www.docker.org.cn/index.html" target="_blank" rel="noopener">docker中文</a></strong></p>
<p><a href="https://labs.play-with-docker.com/" target="_blank" rel="noopener"><strong>Play with Docker</strong></a>（A simple, interactive and fun playground to learn Docker）</p>
<p>首先在学习Docker之前，我们要先学习一下Linux基础，特别注意一下Linux的**<code>ps</code>命令<strong>和</strong><code>top</code>命令**。在之前的Linux笔记中，我们已经稍微提到过<a href="https://www.qingbo1011.top/2021/04/26/Linux/#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">系统管理命令</a>了（参考文章：<a href="http://c.biancheng.net/linux_tutorial/14/" target="_blank" rel="noopener"><strong>Linux系统管理（进程管理、工作管理和系统定时任务）</strong></a>）</p>
<h1 id="docker简介"><a class="markdownIt-Anchor" href="#docker简介"></a> Docker简介</h1>
<ul>
<li>什么是Docker</li>
<li>为什么要用Docker</li>
</ul>
<h2 id="什么是docker"><a class="markdownIt-Anchor" href="#什么是docker"></a> 什么是Docker</h2>
<p>一句话：解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的<strong>容器虚拟化技术</strong></p>
<p><strong>Docker 是一个开源项目</strong>，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 <strong>Go 语言实现</strong>。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a href="https://github.com/docker/docker" target="_blank" rel="noopener">GitHub</a> 上进行维护。Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p>
<p>Docker基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，<strong>对进程进行封装隔离，属于操作系统层面的虚拟化技术</strong>。由于<strong>隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器</strong>。最初实现是基于<strong>Linux 容器</strong>(Linux Containers,缩为<strong>LXC</strong>)，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为使用 runC 和 containerd。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503161918.png" alt="Docker架构" /></p>
<blockquote>
<ul>
<li><strong><code>runc</code></strong> 是一个 Linux 命令行工具，<strong>用于根据 OCI容器运行时规范 创建和运行容器</strong></li>
<li><strong><code>containerd</code></strong> 是一个守护程序，它<strong>管理容器生命周期</strong>，<strong>提供了在一个节点上执行容器和管理镜像的最小功能集</strong></li>
</ul>
</blockquote>
<p><strong>Docker在容器的基础上，进行了进一步的封装</strong>，<strong>从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护</strong>。<strong>使得 Docker 技术比虚拟机技术更为轻便、快捷</strong>。</p>
<p>在 LXC 的基础上 <strong>Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</strong></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503161937.png" alt="传统虚拟化" /></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162009.png" alt="Docker" /></p>
<h2 id="为什么要用-docker"><a class="markdownIt-Anchor" href="#为什么要用-docker"></a> 为什么要用 Docker</h2>
<blockquote>
<p>一款产品从开发到上线，从<strong>操作系统</strong>，到<strong>运行环境</strong>，再到<strong>应用配置</strong>，作为开发+运维之间的协作我们需要关心很多东西，环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，<strong>把原始环境一模一样地复制过来</strong>。<strong>开发人员利用Docker可以消除协作编码时<code>在我的机器上可正常工作</code>的问题</strong>。</p>
</blockquote>
<p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势：</p>
<ul>
<li>
<p><strong>更高效的利用系统资源</strong>：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用</p>
</li>
<li>
<p><strong>更快速的启动时间</strong>：传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间</p>
</li>
<li>
<p><strong><mark>一致的运行环境</mark></strong>：开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <strong>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性</strong>，从而不会再出现<code>这段代码在我机器上没问题啊</code>这类问题</p>
</li>
<li>
<p><strong><mark>持续交付和部署</mark></strong>：对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行（<strong>一次构建，随处运行</strong>）</p>
<p>​		<strong>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署</strong>。开发人员可以<strong>通过 Dockerfile 来进行镜像构建</strong>，并结合持续集成(Continuous Integration) 系统进行集成测试，而<strong>运维人员则可以直接在生产环境中快速部署该镜像</strong>，甚至结合持续部署(Continuous Delivery/Deployment) 系统进行自动部署。<br />
​		而且<strong>使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像</strong></p>
</li>
<li>
<p><strong>更轻松的迁移</strong>：由于<strong>Docker确保了执行环境的一致性，使得应用的迁移更加容易</strong>。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况</p>
</li>
<li>
<p><strong>更轻松的维护和扩展</strong>：<strong>Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单</strong>。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本</p>
</li>
</ul>
<p>Docker容器对比传统虚拟机总结：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Docker容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 <code>MB</code></td>
<td>一般为 <code>GB</code></td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="docker基本概念"><a class="markdownIt-Anchor" href="#docker基本概念"></a> Docker基本概念</h1>
<p><strong>Docker包括三个基本概念</strong></p>
<ul>
<li><strong>镜像</strong>（<code>Image</code>）</li>
<li><strong>容器</strong>（<code>Container</code>）</li>
<li><strong>仓库</strong>（<code>Repository</code>）</li>
</ul>
<p>理解了这三个概念，就理解了Docker的整个生命周期</p>
<p>这里可以先看一下Docker的架构图：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162218.png" alt="Docker架构图" /></p>
<h2 id="镜像image"><a class="markdownIt-Anchor" href="#镜像image"></a> 镜像（Image）</h2>
<p><a href="http://www.dockerinfo.net/image%e9%95%9c%e5%83%8f" target="_blank" rel="noopener"><strong>Image镜像</strong></a></p>
<blockquote>
<p>Docker镜像(lmage)：一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建很多容器（因为<strong>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 类和实例 一样</strong>）</p>
</blockquote>
<p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统</strong>。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像</strong>是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。<strong>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</strong></p>
<blockquote>
<p>镜像命名：<strong>我们可以通过  <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像</strong>。<strong>如果不给出标签，将以 <code>latest</code> 作为默认标签。</strong></p>
</blockquote>
<h3 id="分层存储"><a class="markdownIt-Anchor" href="#分层存储"></a> 分层存储</h3>
<p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，<strong>镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成</strong>，或者说，由多层文件系统联合组成。</p>
<p><strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层</strong>。比如，<strong>删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除</strong>。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，<strong>在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</strong></p>
<p>分层存储的特征使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<p>关于镜像构建，我们后面会提到。</p>
<h2 id="容器container"><a class="markdownIt-Anchor" href="#容器container"></a> 容器（Container）</h2>
<blockquote>
<p><strong>Docker利用容器(Container) 独立运行的一个或一组应用</strong>，<strong>容器是用镜像创建的运行实例。</strong> 它可以被启动、开始、停止、删除。<strong>每个容器都是相互隔离的、保证安全的平台</strong>。 <strong>可以把容器看做是一个简 易版的Linux环境</strong>(包括root用户权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序。 容器的定义和镜像几乎一模一样，也是一堆层的统一视角， 唯一区别在于容器的最上面那一层是可读可写的。</p>
</blockquote>
<p><strong>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 类和实例 一样</strong>，<strong>镜像是静态的定义，容器是镜像运行时的实体</strong>。<strong>容器可以被创建、启动、停止、删除、暂停等</strong>。</p>
<p><strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间</strong>。因此<strong>容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间</strong>。**容器内的进程是运行在一个<mark>隔离的环境</mark>里，使用起来，就好像是在一个独立于宿主的系统下操作一样。**这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过<strong>镜像使用的是分层存储，容器也是如此</strong>。<strong>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层</strong>，我们可以称这个<strong>为容器运行时读写而准备的存储层</strong>为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，<strong>任何保存于容器存储层的信息都会随容器删除而丢失。</strong></p>
<p>按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化</strong>。<strong>所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</strong></p>
<p><strong>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡</strong>。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h2 id="仓库repository"><a class="markdownIt-Anchor" href="#仓库repository"></a> 仓库（Repository）</h2>
<blockquote>
<p>仓库(<strong>Repository</strong>) 是<strong>集中存放镜像</strong>文件的场所。 仓库(<strong>Repository</strong>)和仓库注册服务器(<strong>Registry</strong>) 是有区别的：<strong>仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多镜像， 每个镜像有不同的标签(tag) 。</strong></p>
<p>仓库分为公开仓库(<strong>Public</strong>) 和私有仓库(<strong>Private</strong>) 两种形式。 <strong>最大的公开仓库是[Docker Hub](<a href="https://hub" target="_blank" rel="noopener">https://hub</a>. <a href="http://docker.com/" target="_blank" rel="noopener">docker.com/</a>)</strong> 存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云、网易云等</p>
</blockquote>
<p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，<strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</strong></p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像（<code>Image</code>）。</p>
<p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过  <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像</strong>。<strong>如果不给出标签，将以 <code>latest</code> 作为默认标签。</strong></p>
<blockquote>
<p>以 Ubuntu 镜像 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
</blockquote>
<p>仓库名经常以 <em><strong>两段式路径</strong></em> 形式出现，比如 <strong><code>jwilder/nginx-proxy</code></strong>，<strong>前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名</strong>。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h3 id="docker-registry-公开服务"><a class="markdownIt-Anchor" href="#docker-registry-公开服务"></a> Docker Registry 公开服务</h3>
<p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>。除此以外，还有 Red Hat 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的镜像使用的就是这个服务；代码托管平台 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 推出的 <a href="https://docs.github.com/cn/packages/guides/about-github-container-registry" target="_blank" rel="noopener">ghcr.io</a>。</p>
<p>由于某些原因，在国内访问这些服务可能会比较慢。<strong>国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>）</strong>，这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在<a href="https://yeasy.gitbook.io/docker_practice/install" target="_blank" rel="noopener">安装docker</a>的内容中我们会再具体提到。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p>
<h3 id="私有-docker-registry"><a class="markdownIt-Anchor" href="#私有-docker-registry"></a> 私有 Docker Registry</h3>
<p><strong>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry</strong>。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://yeasy.gitbook.io/docker_practice/repository/registry" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">Harbor</a> 和 <a href="">Sonatype Nexus</a>。</p>
<hr />
<h1 id="docker安装"><a class="markdownIt-Anchor" href="#docker安装"></a> Docker安装</h1>
<p>Docker安装即配置镜像加速参考文章：<strong><a href="https://yeasy.gitbook.io/docker_practice/install" target="_blank" rel="noopener">安装 Docker</a></strong></p>
<p>这里我们学习Docker就在Centos7上安装docker了，其他平台的安装和配置镜像加速在上面的推荐文章或者网上都有很多教程的。</p>
<p><a href="https://yeasy.gitbook.io/docker_practice/install/centos" target="_blank" rel="noopener">CentOS上安装Docker</a></p>
<p><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">Docker 官方 CentOS 安装文档</a></p>
<blockquote>
<p><strong><mark>警告</mark></strong>：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker</p>
</blockquote>
<h2 id="安装docker"><a class="markdownIt-Anchor" href="#安装docker"></a> 安装Docker</h2>
<p>系统要求：Docker 支持 64 位版本 CentOS 7/8，并且<strong>要求内核版本不低于 3.10</strong>。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。</p>
<p>查看内核版本命令：<code>uname -r</code></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162233.png" alt="" /></p>
<h3 id="卸载旧版本"><a class="markdownIt-Anchor" href="#卸载旧版本"></a> 卸载旧版本</h3>
<p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<h3 id="安装新docker"><a class="markdownIt-Anchor" href="#安装新docker"></a> 安装新docker</h3>
<p>在官网中提供了三种安装方式：</p>
<blockquote>
<ul>
<li>Most users <a href="https://docs.docker.com/engine/install/centos/#install-using-the-repository" target="_blank" rel="noopener">set up Docker’s repositories</a> and install from them, for ease of installation and upgrade tasks. This is the recommended approach.</li>
<li>Some users download the RPM package and <a href="https://docs.docker.com/engine/install/centos/#install-from-a-package" target="_blank" rel="noopener">install it manually</a> and manage upgrades completely manually. This is useful in situations such as installing Docker on air-gapped systems with no access to the internet.</li>
<li>In testing and development environments, some users choose to use automated <a href="https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script" target="_blank" rel="noopener">convenience scripts</a> to install Docker.</li>
</ul>
</blockquote>
<p>官网上也推荐我们使用第一种安装方式： <a href="https://docs.docker.com/engine/install/centos/#install-using-the-repository" target="_blank" rel="noopener">set up Docker’s repositories</a>，便于安装和升级</p>
<p>在新主机上第一次安装Docker引擎之前，需要设置Docker存储库。之后，您可以从存储库中安装和更新Docker。（Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.）</p>
<p>执行以下命令安装依赖包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>
<p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p>
<p>（<a href="https://www.jianshu.com/p/5b49c3862630" target="_blank" rel="noopener">linux yum介绍</a>）</p>
<p>执行下面的命令添加 <code>yum</code> 软件源：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo sed -i 's/download.docker.com/mirrors.aliyun.com\/docker-ce/g' /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 官方源</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     --add-repo \</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要安装测试版本的 Docker 请执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --enable docker-ce-test</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后我们就可以安装docker了。更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<h2 id="启动docker"><a class="markdownIt-Anchor" href="#启动docker"></a> 启动Docker</h2>
<p>输入以下命令启动Docker：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162250.png" alt="" /></p>
<h2 id="建立docker用户组"><a class="markdownIt-Anchor" href="#建立docker用户组"></a> 建立docker用户组</h2>
<p>默认情况下，<code>docker</code> 命令会使用 <a href="https://www.jianshu.com/p/d4bb6d4f8e4c" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。<strong>而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket</strong>。<strong>出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户</strong>。因此，<strong>更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组</strong>。</p>
<p>建立 <code>docker</code> 组：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>
<p>将当前用户加入 <code>docker</code> 组：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<p>完成后就可以先退出当前终端并重新登录，测试一下docker是否成功安装。</p>
<blockquote>
<p>由于这里我们以学习为主，所以就直接以root用户登陆Linux了（不用再额外配置docker用户组）</p>
</blockquote>
<h2 id="测试docker是否安装正确"><a class="markdownIt-Anchor" href="#测试docker是否安装正确"></a> 测试Docker是否安装正确</h2>
<p>我们可以通过<code>docker ps -a</code>（查看所有容器，包括停止的）来测试docker是否安装成功：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162606.png" alt="" /></p>
<p>也可以创建Docker的helloword容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm hello-world</span><br></pre></td></tr></table></figure>
<p>输出以下内容则说明Docker安装成功：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162620.png" alt="" /></p>
<blockquote>
<p>由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。</p>
</blockquote>
<p>**<code>docker run</code>**之后做了什么：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162635.png" alt="" /></p>
<h2 id="配置镜像加速"><a class="markdownIt-Anchor" href="#配置镜像加速"></a> 配置镜像加速</h2>
<p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <a href="https://yeasy.gitbook.io/docker_practice/install/mirror" target="_blank" rel="noopener">国内镜像加速</a>。</p>
<p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：</p>
<ul>
<li><a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云加速器</a>：登陆 -&gt; 控制台 -&gt; 产品与服务 -&gt; 搜索<code>容器镜像服务</code> -&gt; 镜像工具 -&gt; 镜像加速器</li>
<li><a href="https://www.163yun.com/help/documents/56918246390157312" target="_blank" rel="noopener">网易云加速器</a></li>
<li><a href="https://cloud.baidu.com/doc/CCE/s/Yjxppt74z#%E4%BD%BF%E7%94%A8dockerhub%E5%8A%A0%E9%80%9F%E5%99%A8" target="_blank" rel="noopener">百度云加速器 </a></li>
</ul>
<blockquote>
<p><strong>由于镜像服务可能出现宕机，建议同时配置多个镜像。各个镜像站测试结果请到</strong> <a href="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions" target="_blank" rel="noopener"><strong>docker-practice/docker-registry-cn-mirror-test</strong></a> **查看。**国内各大云服务商（腾讯云、阿里云、百度云）均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务</p>
</blockquote>
<p>我们这里以阿里云加速为例，输入以下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://这里要看你自己的.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>下面再详细说一些：</p>
<p>目前主流 Linux 发行版均已使用 systemd 进行服务管理，这里介绍如何在使用 systemd 的 Linux 发行版中配置镜像加速器。</p>
<p>请首先执行以下命令，查看是否在 <code>docker.service</code> 文件中配置过镜像地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl cat docker | grep '\-\-registry\-mirror'</span><br></pre></td></tr></table></figure>
<p>如果该命令有输出，那么请执行 <code>$ systemctl cat docker</code> 查看 <code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉 <code>--registry-mirror</code> 参数及其值，并按接下来的步骤进行配置。</p>
<p>如果以上命令没有任何输出：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162655.png" alt="" /></p>
<p>那么就可以在 <code>/etc/docker/daemon.json</code> 中写入如下内容（<strong>如果文件不存在请新建该文件</strong>）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://hub-mirror.c.163.com"</span>,</span><br><span class="line">    <span class="string">"https://mirror.baidubce.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><mark>注意</mark></strong>，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p>
</blockquote>
<p>之后重新启动服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="docker常用命令"><a class="markdownIt-Anchor" href="#docker常用命令"></a> Docker常用命令</h1>
<p><strong>菜鸟教程</strong>：<strong><a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">Docker 命令大全</a></strong></p>
<p><strong>官网</strong>：<strong><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">Docker命令</a></strong></p>
<ul>
<li><code>docker version</code>：查看当前docker版本</li>
<li><code>docker info</code>：查看当前docker的</li>
<li><strong><code>docker --help</code>：帮助命令</strong></li>
</ul>
<p>还有一些常用命令会在下面具体的章节中提到，关于Docker命令大全可以参考上面的推荐文章</p>
<h1 id="使用镜像"><a class="markdownIt-Anchor" href="#使用镜像"></a> 使用镜像</h1>
<p><strong><a href="https://yeasy.gitbook.io/docker_practice/image" target="_blank" rel="noopener">使用镜像</a></strong></p>
<p>在上面的介绍中，我们知道镜像（Image）是 Docker 的三大组件之一。</p>
<p><strong>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</strong></p>
<p>这里我们将学习更多关于镜像的内容：</p>
<ul>
<li>管理本地主机上的镜像</li>
<li>从仓库获取镜像</li>
<li>运行镜像（见<a href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8">容器的启动部分</a>）</li>
</ul>
<h2 id="管理本地主机上的镜像"><a class="markdownIt-Anchor" href="#管理本地主机上的镜像"></a> 管理本地主机上的镜像</h2>
<ul>
<li>列出镜像</li>
<li>删除镜像</li>
</ul>
<h3 id="列出镜像"><a class="markdownIt-Anchor" href="#列出镜像"></a> 列出镜像</h3>
<p>要想列出已经下载下来的镜像，可以使用 <code>docker images</code> 命令。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162710.png" alt="" /></p>
<p>查询结果包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>其中仓库名、标签在上面已经介绍过了。<strong>镜像 ID 则是镜像的唯一标识</strong>，<strong>一个镜像可以对应多个 标签</strong>。比如说，如果我们拉取了ubuntu的两个版本，那么我们就可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162725.png" alt="" /></p>
<p><code>docker images</code> 的常用OPTIONS：</p>
<ul>
<li><strong><code>-a</code>：列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）</strong></li>
<li><strong><code>-q</code> ：只显示镜像ID</strong></li>
<li><code>--digests</code>：显示镜像的摘要信息</li>
<li><code>--no-trunc</code>：显示完整的镜像信息</li>
</ul>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162746.png" alt="" /></p>
<h4 id="镜像体积"><a class="markdownIt-Anchor" href="#镜像体积"></a> 镜像体积</h4>
<p>具体可以看上面的推荐文章，总结一下就是：</p>
<ul>
<li><strong><code>docker images</code> 查询出的镜像所占空间比Docker Hub上显示的要大</strong>，这是因为Docker Hub中显示的体积是压缩后的体积，在镜像下载和上传过程中镜像是保持着压缩状态的</li>
<li><strong><code>docker images</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗</strong>。由于 Docker 镜像是多层存储结构，并且可以继承、复用，<strong>因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。</strong></li>
</ul>
<h4 id="虚悬镜像"><a class="markdownIt-Anchor" href="#虚悬镜像"></a> 虚悬镜像</h4>
<p>有时我们使用<code>docker images</code>查看镜像列表，可以看到一个特殊的镜像，<strong>这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code></strong>：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162801.png" alt="" /></p>
<p>虚悬镜像造成原因如下：</p>
<blockquote>
<p><strong>这个镜像原本是有镜像名和标签的</strong>，比如原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。<strong>除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象</strong>。<strong>由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。</strong></p>
</blockquote>
<p>这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -f dangling=true</span><br></pre></td></tr></table></figure>
<p>一般来说，<strong>虚悬镜像已经失去了存在的价值，是可以随意删除的</strong>，可以用下面的命令删除：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<p>（<code>docker rmi</code>：删除本地一个或多个镜像）</p>
<h4 id="中间层镜像"><a class="markdownIt-Anchor" href="#中间层镜像"></a> 中间层镜像</h4>
<p>为了加速镜像构建、重复利用资源，<strong>Docker 会利用 中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker images</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker imags -a</span></span><br></pre></td></tr></table></figure>
<p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。**这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。**实际上，<strong>这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</strong></p>
<h3 id="删除镜像"><a class="markdownIt-Anchor" href="#删除镜像"></a> 删除镜像</h3>
<p>如果要删除本地的镜像，可以使用 <code>docker image rmi</code> 命令，其格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明：</p>
<ul>
<li><strong><code>-f</code>：强制删除</strong></li>
<li><code>--no-prune</code>：不移除该镜像的过程镜像，默认移除</li>
</ul>
<blockquote>
<p><strong><code>docker prune</code> 命令</strong>：prune 命令用来删除不再使用的 docker 对象(具体见菜鸟教程<a href="https://www.runoob.com/docker/docker-rmi-command.html" target="_blank" rel="noopener">Docker rmi命令</a>)</p>
</blockquote>
<p>以删除wordpress镜像为例，输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f hello-world</span><br></pre></td></tr></table></figure>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162815.png" alt="" /></p>
<p>补充：</p>
<ul>
<li>删除多个镜像：<code>docker rm -f 镜像名1[:TAG] 镜像名2[:TAG]</code></li>
<li>删除全部镜像：<code>docker rmi -f $(docker images -qa)</code></li>
</ul>
<h2 id="从仓库获取镜像"><a class="markdownIt-Anchor" href="#从仓库获取镜像"></a> 从仓库获取镜像</h2>
<p>之前提到过，<a href="https://hub.docker.com/search?q=&amp;type=image" target="_blank" rel="noopener">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<p><strong>从Docker镜像仓库获取镜像的命令是 <code>docker pull</code></strong>，其命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure>
<p>我们以拉取tomcat镜像为例，输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为没有指定tag，所以默认为latest</p>
</blockquote>
<p>结果如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162829.png" alt="如果配置了阿里云镜像加速的话速度会快很多" /></p>
<p>具体的OPTIONS说明可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式：</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<blockquote>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>tomcat:latest</code>，因此将会获取官方镜像 <code>library/tomcat</code> 仓库中标签为 <code>latest</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/tomcat:latest</code>。</p>
</blockquote>
<p>下载完毕后本地镜像就有了tomcat了：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162842.png" alt="" /></p>
<hr />
<h1 id="操作容器"><a class="markdownIt-Anchor" href="#操作容器"></a> <mark>操作容器</mark></h1>
<p><strong><a href="https://yeasy.gitbook.io/docker_practice/container" target="_blank" rel="noopener">操作容器</a></strong></p>
<p>容器（Container）是 Docker 三大重要概念之一。</p>
<p>简单的说，<strong>容器是独立运行的一个或一组应用，以及它们的运行态环境</strong>。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>接下来我们将学习如何来管理一个容器，包括创建、启动和停止等</p>
<ul>
<li>容器启动、停止和重启</li>
<li>列出当前容器</li>
<li>删除容器</li>
<li><strong>守护态运行</strong></li>
<li><strong>进入容器</strong></li>
<li><strong>查看容器日志和内部相关信息</strong></li>
<li><strong>容器导出和导入</strong></li>
</ul>
<h2 id="容器启动-停止和重启"><a class="markdownIt-Anchor" href="#容器启动-停止和重启"></a> 容器启动、停止和重启</h2>
<p>启动容器有两种方式：</p>
<ol>
<li><strong>基于镜像新建一个容器并启动</strong></li>
<li><strong>将在终止状态（<code>exited</code>）的容器重新启动</strong></li>
</ol>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h3 id="新建并启动"><a class="markdownIt-Anchor" href="#新建并启动"></a> 新建并启动</h3>
<p>现在我们还没有一个容器：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162855.png" alt="" /></p>
<p>使用命令<code>docker run</code>新建并启动一个容器：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162906.png" alt="" /></p>
<p>**<code>docker run</code> ：**创建一个新的容器并运行一个命令。语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>
<p>常用OPTIONS说明：</p>
<ul>
<li><strong><code>--name 容器新名字</code>：容器指定一个名称</strong></li>
<li><strong><code>-d</code>：后台运行容器，并返回容器ID， 也即启动守护式容器</strong></li>
<li><code>-i</code>：以交互模式运行容器，通常与<code>-t</code>同时使用</li>
<li><code>-t</code>：为容器重新分配一个伪输入终端，通常与<code>-i</code>同时使用</li>
<li><code>--volume</code> , <strong><code>-v</code>：绑定一个卷</strong></li>
<li><code>-e username=&quot;ritchie&quot;</code>：设置环境变量</li>
<li><strong><code>-P</code>：随机端口映射</strong></li>
<li><strong><code>-p</code>：指定端口映射，有以下四种格式</strong>
<ul>
<li>ip:hostPort:containerPort</li>
<li>ip::containerPort</li>
<li><strong><mark>hostPort:containerPort</mark></strong>（前面的是自己指定本机端口，后面是容器端口是不能随意指定的）</li>
<li>containerPort</li>
</ul>
</li>
</ul>
<p>详细可见：<a href="https://www.runoob.com/docker/docker-run-command.html" target="_blank" rel="noopener">Docker run 命令</a></p>
<blockquote>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 registry 下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li><strong>从地址池配置一个 ip 地址给容器</strong></li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
</blockquote>
<h3 id="启动已终止容器"><a class="markdownIt-Anchor" href="#启动已终止容器"></a> 启动已终止容器</h3>
<ul>
<li><code>docker start</code>：启动一个或多个已经被停止的容器</li>
<li><code>docker stop</code>：停止一个运行中的容器</li>
<li><code>docker restart</code>：重启容器</li>
<li><code>docker kill</code>：杀掉一个运行中的容器（强制停止容器）</li>
</ul>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p>例子：我们要重启关闭的odoo镜像，输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start odoo</span><br></pre></td></tr></table></figure>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162920.png" alt="" /></p>
<p>停止和重启容器是一样的，命令也已经给出了</p>
<h2 id="列出当前容器"><a class="markdownIt-Anchor" href="#列出当前容器"></a> 列出当前容器</h2>
<p><code>docker ps</code>：列出容器</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>
<p>常用OPTIONS：</p>
<ul>
<li><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的</li>
<li><code>-|</code>：显示最近创建的容器</li>
<li><code>-n a</code>：显示最近a个创建的容器（a为具体数字）</li>
<li><code>-q</code>：静默模式，只显示容器编号</li>
<li><code>--no-trunc</code>：不截断输出</li>
</ul>
<p><a href="https://www.runoob.com/docker/docker-ps-command.html" target="_blank" rel="noopener">Docker ps 命令</a></p>
<p>比如我们要查看全部容器，输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162931.png" alt="" /></p>
<h2 id="删除容器"><a class="markdownIt-Anchor" href="#删除容器"></a> 删除容器</h2>
<p><code>docker rm</code> ：删除一个或多个容器</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明：</p>
<ul>
<li><code>-f</code>：通过 SIGKILL 信号强制删除一个运行中的容器。</li>
<li><code>-l</code>：移除容器间的网络连接，而非容器本身。</li>
<li><code>-v</code>：删除与容器关联的卷。</li>
</ul>
<p><a href="https://blog.csdn.net/lanshen110119/article/details/90201412" target="_blank" rel="noopener">docker删除所有的镜像</a></p>
<h2 id="守护态运行"><a class="markdownIt-Anchor" href="#守护态运行"></a> <mark>守护态运行</mark></h2>
<p>更多的时候，<strong>需要让 Docker 在后台运行</strong>而不是直接把执行命令的结果输出在当前宿主机下。此时，在运行<code>docker run</code>时可以通过添加 <strong><code>-d</code></strong> 参数来实现。（上面的<a href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8">新建并启动</a>一节中也已经提到过相关参数了：<code>-d</code>：后台运行容器，并返回容器ID， 也即启动守护式容器）</p>
<blockquote>
<p>举个例子：</p>
<p>如果不使用 <code>-d</code> 参数运行容器：<code>docker run ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503162947.png" alt="容器会把输出的结果 (STDOUT) 打印到宿主机上面" /></p>
<p>如果使用了 <code>-d</code> 参数运行容器：<code>docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503163000.png" alt="" /></p>
<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
</blockquote>
<p><strong><mark>注意</mark>：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p><strong>使用 <code>-d</code> 参数启动后会返回一个唯一的 id</strong>，要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<p><strong>注意一下Docker的机制：</strong></p>
<blockquote>
<p><strong>Docker容器后台运行，就必须有一个前台进程</strong>。<strong>容器运行的命令如果不是那些一直挂起的命令 (比如运行top，tail) ，就是会自动退出的</strong>，这个是docker的机制问题。比如你的web容器，我们以nginx为例，正常情况下，我们配置启动服务只需要启动响应的service即可，即 <code>service nginx start</code> 。但是，这样做nginx为后台进程模式运行,就导致docker前台没有运行的应用，这样的容器后台启动后就会立即自杀因为他觉得他没事可做了。所以，最佳的解决方案是将你要运行的程序以前台进程的形式运行。</p>
<p><a href="https://blog.csdn.net/raoxiaoya/article/details/109194514" target="_blank" rel="noopener">docker容器中的前台程序和后台程序，为什么一定要前台运行</a></p>
<p>（<a href="https://www.bilibili.com/video/BV1Ls411n7mx?p=15" target="_blank" rel="noopener">视频讲解</a>）</p>
</blockquote>
<h2 id="进入容器"><a class="markdownIt-Anchor" href="#进入容器"></a> <mark>进入容器</mark></h2>
<p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。<strong>某些时候需要进入容器进行操作</strong>，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，<strong>推荐大家使用 <code>docker exec</code> 命令</strong>，原因会在下面说明。</p>
<h3 id="attach命令"><a class="markdownIt-Anchor" href="#attach命令"></a> attach命令</h3>
<p><a href="https://www.runoob.com/docker/docker-attach-command.html" target="_blank" rel="noopener">Docker attach 命令</a></p>
<p><code>docker attach</code>：连接到正在运行中的容器</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p>
<p>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过其他人的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p>
</blockquote>
<p><strong><mark>注意</mark></strong>：<strong>如果从这个stdin中 exit，会导致容器的停止</strong></p>
<h3 id="exec命令推荐"><a class="markdownIt-Anchor" href="#exec命令推荐"></a> exec命令（推荐）</h3>
<p><a href="https://www.runoob.com/docker/docker-exec-command.html" target="_blank" rel="noopener">Docker exec 命令</a></p>
<p><code>docker exec</code> ：在运行的容器中执行命令</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明：</p>
<ul>
<li><code>-d</code>：分离模式: 在后台运行</li>
<li><strong><code>-i</code>：即使没有附加也保持STDIN 打开</strong></li>
<li><strong><code>-t</code>：分配一个伪终端</strong></li>
</ul>
<blockquote>
<p>这里主要说明 <code>-i</code> <code>-t</code> 参数：</p>
<ul>
<li>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回</li>
<li>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符</li>
</ul>
</blockquote>
<p><strong><mark>注意</mark></strong>：<strong>如果从这个stdin中 exit，不会导致容器的停止</strong>。这也是为什么推荐大家使用 <code>docker exec</code> 的原因</p>
<p>例子：<code>docker exec -it mysql8 bash</code></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503163013.png" alt="" /></p>
<blockquote>
<p>一般常用的进入容器命令：</p>
<ul>
<li><code>docker exec -it [容器id或name] /bin/bash</code></li>
<li><code>docker exec -it [容器id或name] /bin/sh</code>（镜像是使用alpine制作的）</li>
</ul>
</blockquote>
<h2 id="查看容器日志和内部相关信息"><a class="markdownIt-Anchor" href="#查看容器日志和内部相关信息"></a> <mark>查看容器日志和内部相关信息</mark></h2>
<ul>
<li>查看容器日志</li>
<li>查看容器内运行的进程</li>
<li>查看容器内部细节</li>
</ul>
<h3 id="查看容器日志"><a class="markdownIt-Anchor" href="#查看容器日志"></a> 查看容器日志</h3>
<p><a href="https://www.runoob.com/docker/docker-logs-command.html" target="_blank" rel="noopener">Docker logs 命令</a></p>
<p><code>docker logs</code>：获取容器的日志</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明：</p>
<ul>
<li><strong><code>-f</code>：跟踪日志输出</strong></li>
<li><strong><code>--since</code>：显示某个开始时间的所有日志</strong></li>
<li><strong><code>-t</code>：显示时间戳</strong></li>
<li><strong><code>--tail</code>：仅列出最新N条容器日志</strong></li>
</ul>
<p>例子：<code>docker logs -t hello</code></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503163026.png" alt="" /></p>
<h3 id="查看容器内运行的进程"><a class="markdownIt-Anchor" href="#查看容器内运行的进程"></a> 查看容器内运行的进程</h3>
<p><a href="https://www.runoob.com/docker/docker-top-command.html" target="_blank" rel="noopener">Docker top 命令</a></p>
<p><code>docker top</code>：查看容器中运行的进程信息，支持 ps 命令参数</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p>
</blockquote>
<p>例子：<code>docker top mysql8</code></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503163037.png" alt="" /></p>
<h3 id="查看容器内部细节"><a class="markdownIt-Anchor" href="#查看容器内部细节"></a> 查看容器内部细节</h3>
<p><a href="https://www.runoob.com/docker/docker-inspect-command.html" target="_blank" rel="noopener">Docker inspect 命令</a></p>
<p><code>docker inspect</code>：获取容器/镜像的元数据</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明：</p>
<ul>
<li><code>-f</code>：指定返回值的模板文件</li>
<li><code>-s</code>：显示总的文件大小</li>
<li><code>--type</code>：为指定类型返回JSON</li>
</ul>
<p>例子：<code>docker inspect hello</code></p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503163052.png" alt="" /></p>
<h2 id="容器导出和导入"><a class="markdownIt-Anchor" href="#容器导出和导入"></a> <mark>容器导出和导入</mark></h2>
<ul>
<li>导出容器</li>
<li>导入容器快照</li>
<li>从容器内拷贝文件到主机上</li>
</ul>
<p><strong><a href="https://yeasy.gitbook.io/docker_practice/container/import_export" target="_blank" rel="noopener">导出和导入</a></strong></p>
<h3 id="导出容器"><a class="markdownIt-Anchor" href="#导出容器"></a> 导出容器</h3>
<p><a href="https://www.runoob.com/docker/docker-export-command.html" target="_blank" rel="noopener">Docker export 命令</a></p>
<blockquote>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令将导出容器快照到本地文件</p>
</blockquote>
<p><code>docker export</code>：将文件系统作为一个tar归档文件导出到STDOUT</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明：</p>
<ul>
<li><code>-o</code>：将输入内容写到文件（通过docker export --help查看：<code>-o</code>, <code>--output</code> string   Write to a file, instead of STDOUT）</li>
</ul>
<h3 id="导入容器快照"><a class="markdownIt-Anchor" href="#导入容器快照"></a> 导入容器快照</h3>
<p><a href="https://www.runoob.com/docker/docker-import-command.html" target="_blank" rel="noopener">Docker import 命令</a></p>
<blockquote>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，也可以通过指定 URL 或者某个目录来导入</p>
</blockquote>
<p><code>docker import</code> : 从归档文件中创建镜像</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明：</p>
<ul>
<li><code>-c</code>：应用docker 指令创建镜像</li>
<li><code>-m</code>：提交时的说明文字</li>
</ul>
<blockquote>
<p><mark><strong>注意</strong></mark>：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于<strong>容器快照文件将丢弃所有的历史记录和元数据信息，即仅保存容器当时的快照状态（<code>docker import</code>方式）</strong>，而<strong>镜像存储文件将保存完整记录，体积也要大（<code>docker load</code>方式）</strong>。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
</blockquote>
<h3 id="从容器内拷贝文件到主机上"><a class="markdownIt-Anchor" href="#从容器内拷贝文件到主机上"></a> 从容器内拷贝文件到主机上</h3>
<p><a href="https://www.runoob.com/docker/docker-cp-command.html" target="_blank" rel="noopener">Docker cp 命令</a></p>
<p><code>docker cp</code>：用于容器与主机之间的数据拷贝</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line"></span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明：</p>
<ul>
<li>-L：保持源目标中的链接</li>
</ul>
<p>例子：<code>docker cp odoo: /tmp/yum.log /root</code>（表示将odoo容器内的/tmp/yum.log文件拷贝到宿主机的/root目录下）</p>
<p>（<a href="https://www.bilibili.com/video/BV1Ls411n7mx?p=15" target="_blank" rel="noopener">视频讲解</a>，25:54）</p>
<hr />
<h1 id="访问仓库"><a class="markdownIt-Anchor" href="#访问仓库"></a> 访问仓库</h1>
<ul>
<li>Docker Hub</li>
<li>私有仓库
<ul>
<li>私有仓库高级配置</li>
</ul>
</li>
<li>Nexus3</li>
</ul>
<p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际<strong>上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像</strong>。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如<strong>对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</strong></p>
<p>更详细的内容就去看原文吧：<strong><a href="https://yeasy.gitbook.io/docker_practice/repository" target="_blank" rel="noopener">访问仓库</a></strong></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:qingbo1011@163.com">qingbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.qingbo1011.top/2021/05/31/Docker%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/">http://www.qingbo1011.top/2021/05/31/Docker%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.qingbo1011.top" target="_blank">Qing's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></div><div class="post_share"><div class="social-share" data-image="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20231003161115.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/05/31/Docker%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"><img class="prev_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503161842.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker基础（二）</div></div></a></div><div class="next-post pull_right"><a href="/2021/05/17/Spring02/"><img class="next_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220504095341.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring（二）</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/05/31/Docker基础（二）/" title="Docker基础（二）"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503161842.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-05-31</div><div class="relatedPosts_title">Docker基础（二）</div></div></a></div><div class="relatedPosts_item"><a href="/2021/05/31/Docker安装常用软件/" title="Docker安装常用软件"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503161842.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-05-31</div><div class="relatedPosts_title">Docker安装常用软件</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'oNS5Emx1qUL3wN5yvPLKol0W-gzGzoHsz',
  appKey: 'ytbw0ho3DMX0FeoAOWa37lf9',
  notify: false,
  verify: false,
  placeholder: 'Stay hungry,stay foolish~',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: 'https://',
  emojiMaps: {"欢呼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100836.gif","笑眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100849.gif","花心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100907.gif","吐舌":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100937.gif","疑问":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100951.gif","滑稽":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101004.gif","太开心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101017.gif","酷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101029.gif","怒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101044.gif","阴险":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101100.gif","委屈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101116.gif","乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101129.gif","你懂的":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101204.gif","小乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101215.gif","突然兴奋":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101228.gif","喷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101241.gif","哈哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101255.gif","喝酒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101305.gif","汗":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101323.gif","笑尿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102004.gif","嘿嘿嘿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102018.gif","真棒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102047.gif","托腮":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102108.gif","微笑":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","礼貌":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","笑哭":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","无奈":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","爱你":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","吃瓜":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_thumb.png","doge":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","dog":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","cat":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_thumb.png","星星眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102225.png","酸了":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102240.png","大哭":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102254.png","傲娇":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102314.png","给心心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102328.png","嘿哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102345.png","custom0":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101410.gif","custom1":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101424.webp","狗头":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101710.png","搬砖中":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101744.png","忙到飞起":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102411.png","裂开":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102426.png","叹气":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102439.png","让我看看":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102456.png","panda0":"https://bbs.res.meizu.com/static/image/smiley/panda/_000.png","panda1":"https://bbs.res.meizu.com/static/image/smiley/panda/_001.png","panda2":"https://bbs.res.meizu.com/static/image/smiley/panda/_002.png","panda3":"https://bbs.res.meizu.com/static/image/smiley/panda/_003.png","panda4":"https://bbs.res.meizu.com/static/image/smiley/panda/_004.png","panda5":"https://bbs.res.meizu.com/static/image/smiley/panda/_005.png","panda6":"https://bbs.res.meizu.com/static/image/smiley/panda/_006.png","panda7":"https://bbs.res.meizu.com/static/image/smiley/panda/_007.png","panda8":"https://bbs.res.meizu.com/static/image/smiley/panda/_008.png","panda9":"https://bbs.res.meizu.com/static/image/smiley/panda/_009.png","panda10":"https://bbs.res.meizu.com/static/image/smiley/panda/_010.png","panda11":"https://bbs.res.meizu.com/static/image/smiley/panda/_011.png","panda12":"https://bbs.res.meizu.com/static/image/smiley/panda/_012.png","panda13":"https://bbs.res.meizu.com/static/image/smiley/panda/_013.png","panda14":"https://bbs.res.meizu.com/static/image/smiley/panda/_014.png","panda15":"https://bbs.res.meizu.com/static/image/smiley/panda/_015.png","panda16":"https://bbs.res.meizu.com/static/image/smiley/panda/_016.png","panda17":"https://bbs.res.meizu.com/static/image/smiley/panda/_017.png","panda18":"https://bbs.res.meizu.com/static/image/smiley/panda/_018.png","panda19":"https://bbs.res.meizu.com/static/image/smiley/panda/_019.png","panda20":"https://bbs.res.meizu.com/static/image/smiley/panda/_020.png","panda21":"https://bbs.res.meizu.com/static/image/smiley/panda/_021.png","panda22":"https://bbs.res.meizu.com/static/image/smiley/panda/_022.png","panda23":"https://bbs.res.meizu.com/static/image/smiley/panda/_023.png","panda24":"https://bbs.res.meizu.com/static/image/smiley/panda/_024.png","panda25":"https://bbs.res.meizu.com/static/image/smiley/panda/_025.png","panda26":"https://bbs.res.meizu.com/static/image/smiley/panda/_026.png","panda27":"https://bbs.res.meizu.com/static/image/smiley/panda/_027.png","panda28":"https://bbs.res.meizu.com/static/image/smiley/panda/_028.png","panda29":"https://bbs.res.meizu.com/static/image/smiley/panda/_029.png"},
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220503161842.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By qingbo</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">宇宙很大，生活更大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Golang基础（二） | Qing's Blog</title><meta name="description" content="Golang基础（二）  Go语言中文文档   函数  函数定义 函数定义  函数特点 支持：  无需声明原型 支持不定变参 支持多返回值 支持命名返回参数 支持匿名函数和闭包 函数也是一种类型，一个函数可以赋值给变量  不支持：  不支持嵌套 (nested)： 一个包不能有两个名字一样的函数 不支持重载 (overload) 不支持默认参数 (default parameter)   函数声"><meta name="keywords" content="Golang基础（二）"><meta name="author" content="qingbo,qingbo1011@163.com"><meta name="copyright" content="qingbo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Golang基础（二）"><meta name="twitter:description" content="Golang基础（二）  Go语言中文文档   函数  函数定义 函数定义  函数特点 支持：  无需声明原型 支持不定变参 支持多返回值 支持命名返回参数 支持匿名函数和闭包 函数也是一种类型，一个函数可以赋值给变量  不支持：  不支持嵌套 (nested)： 一个包不能有两个名字一样的函数 不支持重载 (overload) 不支持默认参数 (default parameter)   函数声"><meta name="twitter:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png"><meta property="og:type" content="article"><meta property="og:title" content="Golang基础（二）"><meta property="og:url" content="http://www.qingbo1011.top/2022/04/24/Golang%E5%9F%BA%E7%A1%8002/"><meta property="og:site_name" content="Qing's Blog"><meta property="og:description" content="Golang基础（二）  Go语言中文文档   函数  函数定义 函数定义  函数特点 支持：  无需声明原型 支持不定变参 支持多返回值 支持命名返回参数 支持匿名函数和闭包 函数也是一种类型，一个函数可以赋值给变量  不支持：  不支持嵌套 (nested)： 一个包不能有两个名字一样的函数 不支持重载 (overload) 不支持默认参数 (default parameter)   函数声"><meta property="og:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png"><meta property="article:published_time" content="2022-04-24T00:47:03.000Z"><meta property="article:modified_time" content="2023-10-03T08:16:11.761Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://www.qingbo1011.top/2022/04/24/Golang%E5%9F%BA%E7%A1%8002/"><link rel="prev" title="Golang进阶——网络编程" href="http://www.qingbo1011.top/2022/04/25/Golang%E8%BF%9B%E9%98%B601%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><link rel="next" title="Golang基础（一）" href="http://www.qingbo1011.top/2022/04/23/Golang%E5%9F%BA%E7%A1%8001/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230440.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">87</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">81</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#golang基础二"><span class="toc-number">1.</span> <span class="toc-text"> Golang基础（二）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">2.</span> <span class="toc-text"> 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数定义"><span class="toc-number">2.1.</span> <span class="toc-text"> 函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数特点"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 函数特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数声明"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 函数声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的参数"><span class="toc-number">2.2.</span> <span class="toc-text"> 函数的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不定参数"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 不定参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的返回值"><span class="toc-number">2.3.</span> <span class="toc-text"> 函数的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命名返回参数"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 命名返回参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个返回值"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 多个返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数"><span class="toc-number">2.4.</span> <span class="toc-text"> 匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">2.5.</span> <span class="toc-text"> 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包概念"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 闭包概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go的闭包"><span class="toc-number">2.5.2.</span> <span class="toc-text"> Go的闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-number">2.6.</span> <span class="toc-text"> 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阶乘"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 阶乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 斐波那契数列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#延迟调用defer"><span class="toc-number">2.7.</span> <span class="toc-text"> 延迟调用（defer）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#golang延迟调用"><span class="toc-number">2.7.1.</span> <span class="toc-text"> Golang延迟调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#defer-碰上闭包"><span class="toc-number">2.7.1.1.</span> <span class="toc-text"> defer 碰上闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer陷阱"><span class="toc-number">2.7.2.</span> <span class="toc-text"> defer陷阱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常处理"><span class="toc-number">2.8.</span> <span class="toc-text"> 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#panicrecover"><span class="toc-number">2.8.1.</span> <span class="toc-text"> panic&amp;recover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error"><span class="toc-number">2.8.2.</span> <span class="toc-text"> error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#panic-or-error"><span class="toc-number">2.8.3.</span> <span class="toc-text"> panic or error?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单元测试"><span class="toc-number">2.9.</span> <span class="toc-text"> 单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go-test工具"><span class="toc-number">2.9.1.</span> <span class="toc-text"> go test工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#go-test参数解读"><span class="toc-number">2.9.1.1.</span> <span class="toc-text"> go test参数解读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试函数"><span class="toc-number">2.9.2.</span> <span class="toc-text"> 测试函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#测试函数的格式"><span class="toc-number">2.9.2.1.</span> <span class="toc-text"> 测试函数的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试函数示例"><span class="toc-number">2.9.2.2.</span> <span class="toc-text"> 测试函数示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试组"><span class="toc-number">2.9.3.</span> <span class="toc-text"> 测试组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子测试"><span class="toc-number">2.9.4.</span> <span class="toc-text"> 子测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试覆盖率"><span class="toc-number">2.9.5.</span> <span class="toc-text"> 测试覆盖率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基准测试"><span class="toc-number">2.9.6.</span> <span class="toc-text"> 基准测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基准测试函数格式"><span class="toc-number">2.9.6.1.</span> <span class="toc-text"> 基准测试函数格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基准测试示例"><span class="toc-number">2.9.6.2.</span> <span class="toc-text"> 基准测试示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能比较函数"><span class="toc-number">2.9.6.3.</span> <span class="toc-text"> 性能比较函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重置时间"><span class="toc-number">2.9.6.4.</span> <span class="toc-text"> 重置时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行测试"><span class="toc-number">2.9.6.5.</span> <span class="toc-text"> 并行测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup与teardown"><span class="toc-number">2.9.7.</span> <span class="toc-text"> Setup与TearDown</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#testmain"><span class="toc-number">2.9.7.1.</span> <span class="toc-text"> TestMain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#子测试的setup与teardown"><span class="toc-number">2.9.7.2.</span> <span class="toc-text"> 子测试的Setup与Teardown</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例函数"><span class="toc-number">2.9.8.</span> <span class="toc-text"> 示例函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#示例函数的格式"><span class="toc-number">2.9.8.1.</span> <span class="toc-text"> 示例函数的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#示例函数示例"><span class="toc-number">2.9.8.2.</span> <span class="toc-text"> 示例函数示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压力测试"><span class="toc-number">2.10.</span> <span class="toc-text"> 压力测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go怎么写测试用例"><span class="toc-number">2.10.1.</span> <span class="toc-text"> Go怎么写测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何编写测试用例"><span class="toc-number">2.10.2.</span> <span class="toc-text"> 如何编写测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何编写压力测试"><span class="toc-number">2.10.3.</span> <span class="toc-text"> 如何编写压力测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法"><span class="toc-number">3.</span> <span class="toc-text"> 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方法定义"><span class="toc-number">3.1.</span> <span class="toc-text"> 方法定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法定义和示例"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 方法定义和示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通函数与方法的区别"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 普通函数与方法的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名字段"><span class="toc-number">3.2.</span> <span class="toc-text"> 匿名字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法集"><span class="toc-number">3.3.</span> <span class="toc-text"> 方法集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表达式"><span class="toc-number">3.4.</span> <span class="toc-text"> 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义error"><span class="toc-number">3.5.</span> <span class="toc-text"> 自定义error</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#panicrecover-2"><span class="toc-number">3.5.1.</span> <span class="toc-text"> panic&amp;recover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#return-error"><span class="toc-number">3.5.2.</span> <span class="toc-text"> return error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义error-2"><span class="toc-number">3.5.3.</span> <span class="toc-text"> 自定义error</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口"><span class="toc-number">4.</span> <span class="toc-text"> 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口类型"><span class="toc-number">4.1.</span> <span class="toc-text"> 接口类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要使用接口"><span class="toc-number">4.2.</span> <span class="toc-text"> 为什么要使用接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口的定义"><span class="toc-number">4.3.</span> <span class="toc-text"> 接口的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现接口的条件"><span class="toc-number">4.4.</span> <span class="toc-text"> 实现接口的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口类型变量"><span class="toc-number">4.5.</span> <span class="toc-text"> 接口类型变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#值接收者和指针接收者实现接口"><span class="toc-number">4.6.</span> <span class="toc-text"> 值接收者和指针接收者实现接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#值接收者实现接口"><span class="toc-number">4.6.1.</span> <span class="toc-text"> 值接收者实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针接收者实现接口"><span class="toc-number">4.6.2.</span> <span class="toc-text"> 指针接收者实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型与接口的关系"><span class="toc-number">4.7.</span> <span class="toc-text"> 类型与接口的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一个类型实现多个接口"><span class="toc-number">4.7.1.</span> <span class="toc-text"> 一个类型实现多个接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个类型实现同一接口"><span class="toc-number">4.7.2.</span> <span class="toc-text"> 多个类型实现同一接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口嵌套"><span class="toc-number">4.7.3.</span> <span class="toc-text"> 接口嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空接口"><span class="toc-number">4.8.</span> <span class="toc-text"> 空接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#空接口的定义"><span class="toc-number">4.8.1.</span> <span class="toc-text"> 空接口的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空接口的应用"><span class="toc-number">4.8.2.</span> <span class="toc-text"> 空接口的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#空接口作为函数的参数"><span class="toc-number">4.8.2.1.</span> <span class="toc-text"> 空接口作为函数的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空接口作为map的值"><span class="toc-number">4.8.2.2.</span> <span class="toc-text"> 空接口作为map的值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型断言"><span class="toc-number">4.8.3.</span> <span class="toc-text"> 类型断言</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Qing's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Golang基础（二）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-04-24 08:47:03"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2022-04-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-10-03 16:16:11"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2023-10-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">17k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 66 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2022/04/24/Golang%E5%9F%BA%E7%A1%8002/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2022/04/24/Golang%E5%9F%BA%E7%A1%8002/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="golang基础二"><a class="markdownIt-Anchor" href="#golang基础二"></a> Golang基础（二）</h1>
<ul>
<li><strong><a href="https://www.topgoer.com/" target="_blank" rel="noopener">Go语言中文文档</a></strong></li>
</ul>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89.html" target="_blank" rel="noopener">函数定义</a></p>
<h3 id="函数特点"><a class="markdownIt-Anchor" href="#函数特点"></a> 函数特点</h3>
<p>支持：</p>
<ul>
<li>无需声明原型</li>
<li>支持不定变参</li>
<li><strong>支持多返回值</strong></li>
<li><strong>支持命名返回参数</strong></li>
<li>支持匿名函数和闭包</li>
<li>函数也是一种类型，一个函数可以赋值给变量</li>
</ul>
<p>不支持：</p>
<ul>
<li>不支持嵌套 (nested)： 一个包不能有两个名字一样的函数</li>
<li>不支持重载 (overload)</li>
<li>不支持默认参数 (default parameter)</li>
</ul>
<h3 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h3>
<p>函数声明包含一个函数名，参数列表， 返回值列表和函数体。如果函数没有返回值，则返回列表可以省略。函数从第一条语句开始执行，直到执行return语句或者执行函数的最后一条语句。</p>
<p>函数可以没有参数或接受多个参数。</p>
<p>注意类型在变量名之后 ，当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。（如：<code>func name(x,y,int,s string)</code> ）</p>
<p>函数可以返回任意数量的返回值。使用关键字 <code>func</code> 定义函数，<strong>左大括号依旧不能另起一行。</strong></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型相同的相邻参数，参数类型可合并。 多返回值必须用括号。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(x, y <span class="keyword">int</span>, s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	sum := x + y</span><br><span class="line">	<span class="keyword">return</span> sum, <span class="string">"我是"</span> + s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数是第一类对象，可作为参数传递</strong>。建议将复杂签名定义为函数类型，以便于阅读。</p>
<p>看个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> formatFunc <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(fn formatFunc, s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fn(s, x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s1 := name(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">// 直接将匿名函数当参数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line">   &#125;)</span><br><span class="line">   s2 := format(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s + strconv.Itoa(x+y)</span><br><span class="line">   &#125;, <span class="string">"相加的和是："</span>, <span class="number">10</span>, <span class="number">11</span>) <span class="comment">// "相加的和是："传给s，10传给x，11传给y</span></span><br><span class="line">   fmt.Println(s1) <span class="comment">// 200</span></span><br><span class="line">   fmt.Println(s2) <span class="comment">// 相加的和是：21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有返回值的函数，必须有明确的终止语句（要有<code>return</code>），否则会引发编译错误。</p>
<blockquote>
<p>可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float</span> //<span class="title">implemented</span> <span class="title">in</span> <span class="title">assembly</span> <span class="title">language</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="函数的参数"><a class="markdownIt-Anchor" href="#函数的参数"></a> 函数的参数</h2>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8F%82%E6%95%B0.html" target="_blank" rel="noopener">参数</a></p>
<p>函数定义时指出，函数定义时有参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量。</p>
<p>但当调用函数，传递过来的变量就是函数的实参，函数可以通过两种方式来传递参数：</p>
<ul>
<li>
<p><strong>值传递</strong>：指在调用函数时将实际参数<strong>复制一份传递到函数中</strong>，这样在函数中如果对参数进行修改，将<strong>不会影响到实际参数</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">       ... ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>引用传递</strong>：是指在调用函数时<strong>将实际参数的地址传递到函数中</strong>，那么在函数中对参数所进行的修改，将<strong>影响到实际参数</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这里提一嘴，go中交换两个数不需要专门写个swap函数，直接这样处理就行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">10</span></span><br><span class="line">	y := <span class="number">20</span></span><br><span class="line">	fmt.Println(x, y) <span class="comment">// 10 20</span></span><br><span class="line">	x, y = y, x</span><br><span class="line">	fmt.Println(x, y) <span class="comment">// 20 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<p>注意：</p>
<ul>
<li>无论是值传递，还是引用传递，传递给函数的<strong>都是变量的副本</strong>，不过，值传递是值的拷贝。引用传递是地址的拷贝，<strong>一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低</strong></li>
<li><code>map</code>、<code>slice</code>、<code>chan</code>、指针、<code>interface</code>默认以引用的方式传递</li>
</ul>
<h3 id="不定参数"><a class="markdownIt-Anchor" href="#不定参数"></a> 不定参数</h3>
<p>不定参数传值就是函数的参数不是固定的，后面的类型是固定的。（可变参数）</p>
<p><strong>Golang 可变参数本质上就是 slice。只能有一个，且必须是最后一个</strong>。</p>
<p>使用不定参数，在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上<code>…</code>即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;    <span class="comment">//0个或多个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, args…<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;    <span class="comment">//1个或多个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, args…<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;    <span class="comment">//2个或多个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：其中args是一个slice，我们可以通过<code>arg[index]</code>依次访问所有参数，通过<code>len(arg)</code>来判断传递参数的个数。</p>
<p><strong><mark>任意类型的不定参数</mark>： 就是函数的参数和每个参数的类型都不是固定的。</strong></p>
<p>用<code>interface{}</code>传递任意类型数据是Go语言的惯例用法，而且<code>interface{}</code>是类型安全的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p>不定参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(add(<span class="string">"结果是："</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// 结果是：15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(s <span class="keyword">string</span>, args ...<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   sum := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> _, item := <span class="keyword">range</span> args &#123;</span><br><span class="line">      sum = sum + item</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s + strconv.Itoa(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 slice 对象做变参时，必须展开！</strong>（<code>slice...</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">   <span class="comment">// slice... 展开slice</span></span><br><span class="line">   fmt.Println(add(<span class="string">"结果是："</span>, s...)) <span class="comment">// 结果是：15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(s <span class="keyword">string</span>, args ...<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   sum := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> _, item := <span class="keyword">range</span> args &#123;</span><br><span class="line">      sum = sum + item</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s + strconv.Itoa(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意类型的不定参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   myfunc(<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">'a'</span>, <span class="string">'中'</span>, <span class="string">"hello world!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, item := <span class="keyword">range</span> args &#123;</span><br><span class="line">      fmt.Println(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的返回值"><a class="markdownIt-Anchor" href="#函数的返回值"></a> 函数的返回值</h2>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E8%BF%94%E5%9B%9E%E5%80%BC.html" target="_blank" rel="noopener">返回值</a></p>
<h3 id="命名返回参数"><a class="markdownIt-Anchor" href="#命名返回参数"></a> 命名返回参数</h3>
<p>**Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。**返回值的名称应当具有一定的意义，可以作为文档使用。</p>
<p>没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<p><strong>命名返回参数可看做与形参类似的局部变量</strong>，最后由 <code>return</code> 隐式返回：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   sum = x + y</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名返回参数可被同名局部变量遮蔽，此时需要显式返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    &#123; <span class="comment">// 不能在一个级别，引发 "z redeclared in this block" 错误。</span></span><br><span class="line">        <span class="keyword">var</span> z = x + y</span><br><span class="line">        <span class="comment">// return   // Error: z is shadowed during return</span></span><br><span class="line">        <span class="keyword">return</span> z <span class="comment">// 必须显式返回。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名返回参数允许 <code>defer</code> 延迟调用通过闭包读取和修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 103</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      sum = sum + <span class="number">100</span></span><br><span class="line">   &#125;()</span><br><span class="line">   sum = x + y</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式 <code>return</code> 返回前，会<strong>先修改命名返回参数</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(sum)</span><br><span class="line">   &#125;()</span><br><span class="line">   sum = x + y</span><br><span class="line">   <span class="keyword">return</span> sum + <span class="number">100</span>   <span class="comment">// 执行顺序: (sum = sum + 100) -&gt; (call defer) -&gt; (return)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">103</span><br><span class="line">103</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure>
<h3 id="多个返回值"><a class="markdownIt-Anchor" href="#多个返回值"></a> 多个返回值</h3>
<p>Golang返回值不能用容器对象接收多返回值。只能用多个变量，或 <code>_</code> 忽略。<code>_</code>标识符，用来忽略函数的某个返回值。</p>
<p>多返回值可直接作为其他函数调用实参。看个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(add(myfunc())) <span class="comment">// 21</span></span><br><span class="line">   fmt.Println(sum(myfunc())) <span class="comment">// 21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   sum = x + y</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, item := <span class="keyword">range</span> args &#123;</span><br><span class="line">      sum = sum + item</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a class="markdownIt-Anchor" href="#匿名函数"></a> 匿名函数</h2>
<p>匿名函数是指<strong>不需要定义函数名</strong>的一种函数实现方式。1958年LISP首先采用匿名函数。</p>
<p>在Go里面，函数可以像普通变量一样被传递或使用，<strong>Go语言支持随时在代码里定义匿名函数</strong>。</p>
<p>匿名函数由一个不带函数名的函数声明和函数体组成。匿名函数的优越性在于可以直接使用函数内的变量，不必声明。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sqrt := <span class="function"><span class="keyword">func</span><span class="params">(num <span class="keyword">float64</span>)</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> math.Sqrt(num)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sqrt(<span class="number">64</span>))	<span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先定义了一个名为sqrt的变量，初始化该变量时和之前的变量初始化有些不同，使用了func，func是定义函数的，可是这个函数和上面说的函数最大不同就是没有函数名，也就是匿名函数。这里将一个函数当做一个变量一样的操作。</p>
<p>Golang匿名函数可赋值给变量，做为结构字段，或者在 <code>channel</code> 里传送。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// --- function variable ---</span></span><br><span class="line">   fn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">"hello world"</span>) &#125; <span class="comment">// hello world</span></span><br><span class="line">   fn()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// --- function collection ---</span></span><br><span class="line">   fns := []<span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">         <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">         <span class="keyword">return</span> x + <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(fns[<span class="number">0</span>](<span class="number">100</span>), fns[<span class="number">1</span>](<span class="number">100</span>)) <span class="comment">// 101 102</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// --- function as field ---</span></span><br><span class="line">   data := <span class="keyword">struct</span> &#123;</span><br><span class="line">      fn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">   &#125;&#123;</span><br><span class="line">      fn: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(data.fn()) <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// --- channel of function ---</span></span><br><span class="line">   fc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span>, 2)</span></span><br><span class="line">   fc &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println((&lt;-fc)()) <span class="comment">// hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h2>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85%E9%80%92%E5%BD%92.html#%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener">闭包详解</a></p>
<h3 id="闭包概念"><a class="markdownIt-Anchor" href="#闭包概念"></a> 闭包概念</h3>
<p>闭包是由函数及其相关引用环境组合而成的实体(即：<strong>闭包=函数+引用环境</strong>)。</p>
<blockquote>
<p>官方的解释是：所谓闭包，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>维基百科讲，闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p>
<p>看着上面的描述，会发现闭包和匿名函数似乎有些像。可是可能还是有些云里雾里的。因为跳过闭包的创建过程直接理解闭包的定义是非常困难的。目前在JavaScript、Go、PHP、Scala、Scheme、Common Lisp、Smalltalk、Groovy、Ruby、 Python、Lua、objective c、Swift 以及Java8以上等语言中都能找到对闭包不同程度的支持。<strong>通过支持闭包的语法可以发现一个特点，他们都有垃圾回收(GC)机制</strong>。 javascript应该是普及度比较高的编程语言了，通过这个来举例应该好理解写。看下面的代码，只要关注script里方法的定义和调用就可以了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> i=<span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(++i);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;"</span>+i+<span class="string">"&lt;/h1&gt;"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> b;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> c=a();</span></span><br><span class="line">    c();</span><br><span class="line">    c();</span><br><span class="line">    c();</span><br><span class="line"><span class="actionscript">    <span class="comment">//a(); //不会有信息输出</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;=============&lt;/h1&gt;"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> c2=a();</span></span><br><span class="line">    c2();</span><br><span class="line">    c2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码有两个特点：</p>
<p>函数b嵌套在函数a内部 函数a返回函数b 这样在执行完var c=a()后，变量c实际上是指向了函数b()，再执行函数c()后就会显示i的值，第一次为1，第二次为2，第三次为3，以此类推。 其实，这段代码就创建了一个闭包。因为函数a()外的变量c引用了函数a()内的函数b()，就是说：</p>
<p>当函数a()的内部函数b()被函数a()外的一个变量引用的时候，就创建了一个闭包。 在上面的例子中，由于闭包的存在使得函数a()返回后，a中的i始终存在，这样每次执行c()，i都是自加1后的值。 从上面可以看出闭包的作用就是在a()执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a()所占用的资源，因为a()的内部函数b()的执行需要依赖a()中的变量i。</p>
<p>在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。变量的作用域仅限于包含它们的函数，因此无法从其它程序代码部分进行访问。不过，变量的生存期是可以很长，在一次函数调用期间所创建所生成的值在下次函数调用时仍然存在。正因为这一特点，闭包可以用来完成信息隐藏，并进而应用于需要状态表达的某些编程范型中。 下面来想象另一种情况，如果a()返回的不是函数b()，情况就完全不同了。因为a()执行完后，b()没有被返回给a()的外界，只是被a()所引用，而此时a()也只会被b()引 用，因此函数a()和b()互相引用但又不被外界打扰（被外界引用），函数a和b就会被GC回收。所以直接调用a();是页面并没有信息输出。</p>
<p>下面来说闭包的另一要素引用环境。c()跟c2()引用的是不同的环境，在调用i++时修改的不是同一个i，因此两次的输出都是1。函数a()每进入一次，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。这和c()和c()的调用顺序都是无关的。</p>
</blockquote>
<h3 id="go的闭包"><a class="markdownIt-Anchor" href="#go的闭包"></a> Go的闭包</h3>
<p>Go语言是支持闭包的，这里简单地讲一下在Go语言中闭包是如何实现的。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c := a()</span><br><span class="line">   c()</span><br><span class="line">   c()</span><br><span class="line">   c()</span><br><span class="line"></span><br><span class="line">   a() <span class="comment">//不会输出i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   b := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i++</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220523153626.png" alt="" /></p>
<blockquote>
<p>闭包复制的是原对象指针，这就很容易解释延迟引用现象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">"x (%p) = %d\n"</span>, &amp;x, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"x (%p) = %d\n"</span>, &amp;x, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := test()</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x (0xc42007c008) &#x3D; 100</span><br><span class="line">x (0xc42007c008) &#x3D; 100</span><br></pre></td></tr></table></figure>
<p>在汇编层 ，test 实际返回的是 FuncVal 对象，其中包含了匿名函数地址、闭包对象指针。当调 匿名函数时，只需以某个寄存器传递该对象即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FuncVal &#123; func_address, closure_var_pointer ... &#125;</span><br></pre></td></tr></table></figure>
<p>外部引用函数参数局部变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用函数参数局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        base += i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tmp1 := add(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(tmp1(<span class="number">1</span>), tmp1(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 此时tmp1和tmp2不是一个实体了</span></span><br><span class="line">    tmp2 := add(<span class="number">100</span>)</span><br><span class="line">    fmt.Println(tmp2(<span class="number">1</span>), tmp2(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回2个闭包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回2个函数类型的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义2个函数，并返回</span></span><br><span class="line">    <span class="comment">// 相加</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        base += i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相减</span></span><br><span class="line">    sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        base -= i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f1, f2 := test01(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// base一直是没有消</span></span><br><span class="line">    fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 此时base是9</span></span><br><span class="line">    fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>递归，就是在运行的过程中调用自己。 一个函数调用自己，就叫做递归函数。</p>
<p>构成递归需具备的条件：</p>
<ul>
<li>子问题须与原始问题为同样的事，且更为简单</li>
<li>不能无限制地调用本身，须有个出口，化简为非递归状况处理</li>
</ul>
<h3 id="阶乘"><a class="markdownIt-Anchor" href="#阶乘"></a> 阶乘</h3>
<p>求一个数的阶乘，直接看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">   fmt.Print(<span class="string">"请输入数字："</span>)</span><br><span class="line">   fmt.Scan(&amp;num)</span><br><span class="line">   fmt.Printf(<span class="string">"%v! = %v"</span>,num,factorial(num))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> num&lt;=<span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> num*factorial(num<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契数列"><a class="markdownIt-Anchor" href="#斐波那契数列"></a> 斐波那契数列</h3>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">   fmt.Print(<span class="string">"请输入数字："</span>)</span><br><span class="line">   fmt.Scan(&amp;num)</span><br><span class="line">   s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= num; i++ &#123;</span><br><span class="line">      s = <span class="built_in">append</span>(s, fibonaci(i))</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonaci</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">0</span> || i == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fibonaci(i<span class="number">-1</span>) + fibonaci(i<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延迟调用defer"><a class="markdownIt-Anchor" href="#延迟调用defer"></a> 延迟调用（defer）</h2>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8defer.html" target="_blank" rel="noopener">延迟调用（defer）</a></p>
<h3 id="golang延迟调用"><a class="markdownIt-Anchor" href="#golang延迟调用"></a> Golang延迟调用</h3>
<p>defer特性：</p>
<ul>
<li>关键字<code>defer</code>用于注册延迟调用</li>
<li>这些调用直到<code>return</code>前才被执。因此可以用来做资源清理</li>
<li>多个<code>defer</code>语句，按<strong>先进后出</strong>的方式执行（最前面的defer语句最后执行）</li>
<li>defer语句中的变量，在defer声明时就决定了</li>
</ul>
<p>defer用途：</p>
<ul>
<li>关闭文件句柄</li>
<li>锁资源释放</li>
<li>数据库连接释放</li>
</ul>
<p>go语言的<code>defer</code>功能强大，对于资源管理非常方便，但是如果没用好，也会有陷阱。</p>
<p><strong>defer是先进后出</strong>。这个很自然,后面的语句会依赖前面的资源，因此如果先前面的资源先释放了，后面的语句就没法执行了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220529200918.png" alt="" /></p>
<h4 id="defer-碰上闭包"><a class="markdownIt-Anchor" href="#defer-碰上闭包"></a> defer 碰上闭包</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> whatever [<span class="number">3</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(i) &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220529201333.png" alt="" /></p>
<p>其实go说的很清楚，我们一起来看看go spec如何说的：</p>
<blockquote>
<p>Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usualand saved anew but the actual function is not invoked.</p>
</blockquote>
<p>也就是说函数正常执行，由于闭包用到的变量<code>i</code>在执行的时候已经变成2，所以输出全都是2。</p>
<blockquote>
<p><code>defer f.Close</code></p>
<p>这个大家用的都很频繁,但是go语言编程举了一个可能一不小心会犯错的例子.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">" closed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">"a"</span>&#125;, &#123;<span class="string">"b"</span>&#125;, &#123;<span class="string">"c"</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        <span class="keyword">defer</span> t.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c  closed</span><br><span class="line">c  closed</span><br><span class="line">c  closed</span><br></pre></td></tr></table></figure>
<p>这个输出并不会像我们预计的输出c b a,而是输出c c c</p>
<p>可是按照前面的go spec中的说明,应该输出c b a才对啊.</p>
<p>那我们换一种方式来调用一下.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">" closed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Close</span><span class="params">(t Test)</span></span> &#123;</span><br><span class="line">    t.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">"a"</span>&#125;, &#123;<span class="string">"b"</span>&#125;, &#123;<span class="string">"c"</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        <span class="keyword">defer</span> Close(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c  closed</span><br><span class="line">b  closed</span><br><span class="line">a  closed</span><br></pre></td></tr></table></figure>
<p>这个时候输出的就是c b a</p>
<p>当然,如果你不想多写一个函数,也很简单,可以像下面这样,同样会输出c b a</p>
<p>看似多此一举的声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">" closed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">"a"</span>&#125;, &#123;<span class="string">"b"</span>&#125;, &#123;<span class="string">"c"</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        t2 := t</span><br><span class="line">        <span class="keyword">defer</span> t2.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c  closed</span><br><span class="line">b  closed</span><br><span class="line">a  closed</span><br></pre></td></tr></table></figure>
<p>通过以上例子，结合 <code>Each time a &quot;defer&quot; statement executes, the function value and parameters to the call are evaluated as usualand saved anew but the actual function is not invoked.</code>这句话。可以得出下面的结论：</p>
<p>defer后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。但是并没有说struct这里的this指针如何处理，通过这个例子可以看出go语言并没有把这个明确写出来的this指针当作参数来看待。</p>
</blockquote>
<p>多个defer注册，按 FILO 次序执行 ( <strong>先进后出</strong> )。<strong>哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"a"</span>)</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="number">100</span> / x) <span class="comment">// div0 异常未被捕获，逐步往外传递，最终终止进程。</span></span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">"c"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220529210644.png" alt="" /></p>
<h3 id="defer陷阱"><a class="markdownIt-Anchor" href="#defer陷阱"></a> defer陷阱</h3>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8defer.html#defer%E9%99%B7%E9%98%B1" target="_blank" rel="noopener">defer陷阱</a></p>
<h2 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h2>
<h3 id="panicrecover"><a class="markdownIt-Anchor" href="#panicrecover"></a> panic&amp;recover</h3>
<p>Golang没有结构化异常，使<code>panic</code>抛出错误；<code>recover</code>捕获错误。</p>
<p>异常的使用场景简单描述：Go中可以抛出一个<code>panic</code>的异常，然后在<code>defer</code>中通过<code>recover</code>捕获这个异常，然后正常处理。</p>
<p><code>panic</code>：</p>
<ul>
<li>内置函数</li>
<li>假如函数<code>F()</code>中书写了<code>panic</code>语句，会终止其后要执行的代码，在<code>panic</code>所在函数<code>F()</code>内如果存在要执行的<code>defer</code>函数列表，按照<code>defer</code>的逆序执行</li>
<li>返回函数<code>F()</code>的调用者<code>G()</code>，在<code>G()</code>中，调用函数<code>F()</code>语句之后的代码不会执行，假如函数<code>G()</code>中存在要执行的<code>defer</code>函数列表，按照<code>defer</code>的逆序执行</li>
<li>直到goroutine整个退出，并报告错误</li>
</ul>
<p><code>recover</code>：</p>
<ul>
<li>内置函数</li>
<li>用来控制一个goroutine的panicking行为，捕获<code>panic</code>，从而影响应用的行为</li>
</ul>
<p>一般的调用建议:</p>
<ul>
<li>在<code>defer</code>函数中，通过<code>recever</code>来终止一个goroutine的panicking过程，从而恢复正常代码的执行</li>
<li>可以获取通过<code>panic</code>传递的<code>error</code></li>
</ul>
<p>注意：</p>
<ul>
<li>利用<code>recover</code>处理<code>panic</code>指令，<code>defer</code>必须放在<code>panic</code>之前定义，另外<code>recover</code>只有在<code>defer</code>调用的函数中才有效。否则当<code>panic</code>时，<code>recover</code>无法捕获到<code>panic</code>，无法防止<code>panic</code>扩散。</li>
<li><code>recover</code>处理异常后，逻辑并不会恢复到<code>panic</code>那个点去，函数跑到<code>defer</code>之后的那个点。</li>
<li>多个<code>defer</code>会形成<code>defer</code>栈，后定义的<code>defer</code>语句会被最先调用。</li>
</ul>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fu()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fu</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err := <span class="built_in">recover</span>()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err.(<span class="keyword">string</span>)) <span class="comment">// // 将interface&#123;&#125;转型为具体类型</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">"panic error!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220530160136.png" alt="" /></p>
<p>由于<code>panic</code>、<code>recover</code>参数类型为<code>interface{}</code>，因此可抛出任何类型对象。</p>
<blockquote>
<p>源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>接下来看几个具体的例子来熟悉一下。</p>
<ol>
<li>
<p>向已关闭的通道发送数据会引发<code>panic</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   ch :&#x3D; make(chan int)</span><br><span class="line">   close(ch)</span><br><span class="line">   ch &lt;- 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220530160926.png" alt="" /></p>
</li>
<li>
<p>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"defer panic"</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">"test panic"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220530161259.png" alt="" /></p>
</li>
<li>
<p>捕获函数<code>recover</code>只有在延迟调用内直接调用才会终止错误，否则总是返回<code>nil</code>。<strong>任何未捕获的错误都会沿调用堆栈向外传递</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="built_in">recover</span>()) <span class="comment">//有效</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">defer</span> <span class="built_in">recover</span>()              <span class="comment">//无效！</span></span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="built_in">recover</span>()) <span class="comment">//无效！</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="built_in">println</span>(<span class="string">"defer inner"</span>)</span><br><span class="line">         <span class="built_in">recover</span>() <span class="comment">//无效！</span></span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">"test panic"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220530163128.png" alt="" /></p>
</li>
<li>
<p>使用延迟匿名函数，或者像下面这样都是有效的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> except()</span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">"test panic"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">except</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220530163415.png" alt="" /></p>
</li>
<li>
<p>如果需要保护代码段，可将代码块重构成匿名函数，如此可确保后续代码被执。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> z <span class="keyword">int</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            z = <span class="number">0</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"test panic"</span>)</span><br><span class="line">      z = x / y</span><br><span class="line">   &#125;()</span><br><span class="line">   fmt.Printf(<span class="string">"%v/%v = %v \n"</span>, x, y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="error"><a class="markdownIt-Anchor" href="#error"></a> error</h3>
<p>除用<code>panic</code>引发中断性错误外，还可<strong>返回<code>error</code>类型错误对象来表示函数调用状态</strong>。</p>
<blockquote>
<p>源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">   Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>标准库<code>errors.New()</code>和<code>fmt.Errorf()</code>函数用于创建实现<code>error</code>接口的错误对象。通过判断错误对象实例来确定具体错误类型。</p>
<p>看个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"errors"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errDivByZero = errors.New(<span class="string">"division by zero"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   n, err := div(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, errDivByZero</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> x / y, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220531143606.png" alt="" /></p>
<h3 id="panic-or-error"><a class="markdownIt-Anchor" href="#panic-or-error"></a> panic or error?</h3>
<p>惯例是：导致关键流程出现不可修复性错误的使用<code>panic</code>，其他使用 <code>error</code>。</p>
<h2 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h2>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html" target="_blank" rel="noopener">单元测试</a></p>
<h3 id="go-test工具"><a class="markdownIt-Anchor" href="#go-test工具"></a> go test工具</h3>
<p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p>
<p><code>go test</code>命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p>
<p>在<code>*_test.go</code>文件中有三种类型的函数，<strong>单元测试函数</strong>、<strong>基准测试函数</strong>和<strong>示例函数</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">测试函数</td>
<td style="text-align:center">函数名前缀为<code>Test</code></td>
<td style="text-align:center">测试程序的一些逻辑行为是否正确</td>
</tr>
<tr>
<td style="text-align:center">基准函数</td>
<td style="text-align:center">函数名前缀为<code>Benchmark</code></td>
<td style="text-align:center">测试函数的性能</td>
</tr>
<tr>
<td style="text-align:center">示例函数</td>
<td style="text-align:center">函数名前缀为<code>Example</code></td>
<td style="text-align:center">为文档提供示例文档</td>
</tr>
</tbody>
</table>
<p><code>go test</code>命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<p>Golang单元测试对文件名和方法名，参数都有很严格的要求：</p>
<ul>
<li>文件名必须以<code>xx_test.go</code>命名</li>
<li>方法必须是<code>Test</code>开头</li>
<li>方法参数必须是<code>t *testing.T</code></li>
<li>使用<code>go test</code>执行单元测试</li>
</ul>
<h4 id="go-test参数解读"><a class="markdownIt-Anchor" href="#go-test参数解读"></a> go test参数解读</h4>
<p><code>go test</code>是go语言自带的测试工具，其中包含的是两类：单元测试和性能测试。</p>
<p>通过<code>go help test</code>可以看到<code>go test</code>的使用说明：</p>
<p>格式形如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> [-c] [-i] [build flags] [packages] [flags <span class="keyword">for</span> <span class="built_in">test</span> binary]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数解读：</p>
<ul>
<li>
<p><code>-c</code> : 编译go test成为可执行的二进制文件，但是不运行测试</p>
</li>
<li>
<p><code>-i</code> : 安装测试包依赖的package，但是不运行测试</p>
</li>
<li>
<p><code>build flags</code>：调用go help build，这些是编译运行过程中需要使用到的参数，一般设置为空</p>
</li>
<li>
<p><code>packages</code>：调用go help packages，这些是关于包的管理，一般设置为空</p>
</li>
<li>
<p><code>flags for test binary</code>，调用go help testflag，这些是<code>go test</code>过程中经常使用到的参数：</p>
<ul>
<li>
<p><code>-test.v</code> : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例</p>
</li>
<li>
<p><code>-test.run pattern</code>: 只跑哪些单元测试用例</p>
</li>
<li>
<p><code>-test.bench patten</code>: 只跑那些性能测试用例</p>
</li>
<li>
<p><code>-test.benchmem</code> : 是否在性能测试的时候输出内存情况</p>
</li>
<li>
<p><code>-test.benchtime t</code> : 性能测试运行的时间，默认是1s</p>
</li>
<li>
<p><code>-test.cpuprofile cpu.out</code> : 是否输出cpu性能分析文件</p>
</li>
<li>
<p><code>-test.memprofile mem.out</code> : 是否输出内存性能分析文件</p>
</li>
<li>
<p><code>-test.blockprofile block.out</code> : 是否输出内部goroutine阻塞的性能分析文件</p>
</li>
<li>
<p><code>-test.memprofilerate n</code> : 内存性能分析的时候有一个分配了多少的时候才打点记录的问题。这个参数就是设置打点的内存分配间隔，也就是profile中一个sample代表的内存大小。默认是设置为512 * 1024的。如果你将它设置为1，则每分配一个内存块就会在profile中有个打点，那么生成的profile的sample就会非常多。如果你设置为0，那就是不做打点了</p>
<p>你可以通过设置memprofilerate=1和GOGC=off来关闭内存回收，并且对每个内存块的分配进行观察</p>
</li>
<li>
<p><code>-test.blockprofilerate n</code>: 基本同上，控制的是goroutine阻塞时候打点的纳秒数。默认不设置就相当于-test.blockprofilerate=1，每一纳秒都打点记录一下</p>
</li>
<li>
<p><code>-test.parallel n</code> : 性能测试的程序并行cpu数，默认等于GOMAXPROCS</p>
</li>
<li>
<p><code>-test.timeout t</code> : 如果测试用例运行时间超过t，则抛出<code>panic</code></p>
</li>
<li>
<p><code>-test.cpu 1,2,4</code> : 程序运行在哪些CPU上面，使用二进制的1所在位代表，和nginx的nginx_worker_cpu_affinity是一个道理</p>
</li>
<li>
<p><code>-test.short</code> : 将那些运行时间较长的测试用例运行时间缩短</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="测试函数"><a class="markdownIt-Anchor" href="#测试函数"></a> 测试函数</h3>
<h4 id="测试函数的格式"><a class="markdownIt-Anchor" href="#测试函数的格式"></a> 测试函数的格式</h4>
<p>每个测试函数必须导入<code>testing</code>包，测试函数的基本格式（签名）如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头，举几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSum</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLog</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>其中参数t用于报告测试失败和附加的日志信息。 <code>testing.T</code>的拥有的方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Error</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">FailNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Failed</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fatalf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Log</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Logf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Parallel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(t *T)</span>) <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skip</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">SkipNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skipf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skipped</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<h4 id="测试函数示例"><a class="markdownIt-Anchor" href="#测试函数示例"></a> 测试函数示例</h4>
<p>就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。</p>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B" target="_blank" rel="noopener">测试函数示例</a></p>
<h3 id="测试组"><a class="markdownIt-Anchor" href="#测试组"></a> 测试组</h3>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E6%B5%8B%E8%AF%95%E7%BB%84" target="_blank" rel="noopener">测试组</a></p>
<h3 id="子测试"><a class="markdownIt-Anchor" href="#子测试"></a> 子测试</h3>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E5%AD%90%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">子测试</a></p>
<p>Go1.7+中新增了子测试，我们可以按照如下方式使用<code>t.Run</code>执行子测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep   <span class="keyword">string</span></span><br><span class="line">        want  []<span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line">        <span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"leading sep"</span>: &#123;input: <span class="string">"枯藤老树昏鸦"</span>, sep: <span class="string">"老"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"枯藤"</span>, <span class="string">"树昏鸦"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 使用t.Run()执行子测试</span></span><br><span class="line">            got := Split(tc.input, tc.sep)</span><br><span class="line">            <span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">                t.Errorf(<span class="string">"excepted:%#v, got:%#v"</span>, tc.want, got)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们再执行<code>go test</code>命令就能够看到更清晰的输出内容了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">split $ go test -v</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit&#x2F;leading_sep</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit&#x2F;simple</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit&#x2F;wrong_sep</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit&#x2F;more_sep</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    --- FAIL: TestSplit&#x2F;leading_sep (0.00s)</span><br><span class="line">        split_test.go:83: excepted:[]string&#123;&quot;枯藤&quot;, &quot;树昏鸦&quot;&#125;, got:[]string&#123;&quot;&quot;, &quot;枯藤&quot;, &quot;树昏鸦&quot;&#125;</span><br><span class="line">    --- PASS: TestSplit&#x2F;simple (0.00s)</span><br><span class="line">    --- PASS: TestSplit&#x2F;wrong_sep (0.00s)</span><br><span class="line">    --- PASS: TestSplit&#x2F;more_sep (0.00s)</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    github.com&#x2F;pprof&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;split       0.006s</span><br></pre></td></tr></table></figure>
<h3 id="测试覆盖率"><a class="markdownIt-Anchor" href="#测试覆盖率"></a> 测试覆盖率</h3>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87" target="_blank" rel="noopener">测试覆盖率</a></p>
<p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。</p>
<p>Go提供内置功能来检查你的代码覆盖率。我们可以使用<code>go test -cover</code>来查看测试覆盖率。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split $ go test -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      github.com&#x2F;pprof&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;split       0.005s</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看到我们的测试用例覆盖了100%的代码。</p>
<p>Go还提供了一个额外的<code>-coverprofile</code>参数，用来将覆盖率相关的记录信息输出到一个文件。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split $ go test -cover -coverprofile&#x3D;c.out</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      github.com&#x2F;pprof&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;split       0.005s</span><br></pre></td></tr></table></figure>
<p>上面的命令会将覆盖率相关的信息输出到当前文件夹下面的c.out文件中，然后我们执行<code>go tool cover -html=c.out</code>，使用cover工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个HTML报告。</p>
<h3 id="基准测试"><a class="markdownIt-Anchor" href="#基准测试"></a> 基准测试</h3>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">基准测试</a></p>
<h4 id="基准测试函数格式"><a class="markdownIt-Anchor" href="#基准测试函数格式"></a> 基准测试函数格式</h4>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">基准测试函数格式</a></p>
<p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基准测试以<code>Benchmark</code>为前缀，需要一个<code>*testing.B</code>类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。</p>
<h4 id="基准测试示例"><a class="markdownIt-Anchor" href="#基准测试示例"></a> 基准测试示例</h4>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B" target="_blank" rel="noopener">基准测试示例</a></p>
<p>我们为split包中的Split函数编写基准测试如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Split(<span class="string">"枯藤老树昏鸦"</span>, <span class="string">"老"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基准测试并不会默认执行，需要增加-bench参数，所以我们通过执行go test -bench=Split命令执行基准测试，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go test -bench&#x3D;Split</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com&#x2F;pprof&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;split</span><br><span class="line">BenchmarkSplit-8        10000000               203 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com&#x2F;pprof&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;split       2.255s</span><br></pre></td></tr></table></figure>
<p>其中BenchmarkSplit-8表示对Split函数进行基准测试，数字8表示GOMAXPROCS的值，这个对于并发基准测试很重要。10000000和203ns/op表示每次调用Split函数耗时203ns，这个结果是10000000次调用的平均值。</p>
<h4 id="性能比较函数"><a class="markdownIt-Anchor" href="#性能比较函数"></a> 性能比较函数</h4>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">性能比较函数</a></p>
<p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p>
<p>性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, size <span class="keyword">int</span>)</span></span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark10</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark100</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">100</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1000</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">1000</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>例如我们编写了一个计算斐波那契数列的函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fib 是一个计算第n个斐波那契数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们编写的性能比较函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkFib</span><span class="params">(b *testing.B, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Fib(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib1</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib2</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">2</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib3</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">3</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib20</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">20</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib40</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">40</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>运行基准测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">split $ go test -bench&#x3D;.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com&#x2F;pprof&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;fib</span><br><span class="line">BenchmarkFib1-8         1000000000               2.03 ns&#x2F;op</span><br><span class="line">BenchmarkFib2-8         300000000                5.39 ns&#x2F;op</span><br><span class="line">BenchmarkFib3-8         200000000                9.71 ns&#x2F;op</span><br><span class="line">BenchmarkFib10-8         5000000               325 ns&#x2F;op</span><br><span class="line">BenchmarkFib20-8           30000             42460 ns&#x2F;op</span><br><span class="line">BenchmarkFib40-8               2         638524980 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com&#x2F;pprof&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;fib 12.944s</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p>
<p>最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用-benchtime标志增加最小基准时间，以产生更准确的结果。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go test -bench&#x3D;Fib40 -benchtime&#x3D;20s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com&#x2F;pprof&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;fib</span><br><span class="line">BenchmarkFib40-8              50         663205114 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com&#x2F;pprof&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;fib 33.849s</span><br></pre></td></tr></table></figure>
<p>这一次BenchmarkFib40函数运行了50次，结果就会更准确一些了。</p>
<p>使用性能比较函数做测试的时候一个容易犯的错误就是把b.N作为输入的大小，例如以下两个例子都是错误的示范：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Fib(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    Fib(b.N)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重置时间"><a class="markdownIt-Anchor" href="#重置时间"></a> 重置时间</h4>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">重置时间</a></p>
<p>b.ResetTimer之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 假设需要做一些耗时的无关操作</span></span><br><span class="line">    b.ResetTimer()              <span class="comment">// 重置计时器</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Split(<span class="string">"枯藤老树昏鸦"</span>, <span class="string">"老"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并行测试"><a class="markdownIt-Anchor" href="#并行测试"></a> 并行测试</h4>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E5%B9%B6%E8%A1%8C%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">并行测试</a></p>
<p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p>
<p>RunParallel会创建出多个goroutine，并将b.N分配给这些goroutine执行， 其中goroutine数量的默认值为GOMAXPROCS。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在RunParallel之前调用SetParallelism 。RunParallel通常会与-cpu标志一同使用。</p>
<h3 id="setup与teardown"><a class="markdownIt-Anchor" href="#setup与teardown"></a> Setup与TearDown</h3>
<p>测试程序有时需要在测试之前进行额外的设置（<code>setup</code>）或在测试之后进行拆卸（<code>teardown</code>）。</p>
<blockquote>
<p>这里就有点像java的<code>@before</code>和<code>@after</code>注解。（<a href="https://www.qingbo1011.top/2021/01/21/Junit/#junit%E4%B8%AD%E7%9A%84before%E5%92%8Cafter%E6%B3%A8%E8%A7%A3">Junit中的@Before和@After注解</a>）</p>
</blockquote>
<h4 id="testmain"><a class="markdownIt-Anchor" href="#testmain"></a> TestMain</h4>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#testmain" target="_blank" rel="noopener">TestMain</a></p>
<p>通过在<code>*_test.go</code>文件中定义<code>TestMain</code>函数来可以在测试之前进行额外的设置（<code>setup</code>）或在测试之后进行拆卸（<code>teardown</code>）操作。</p>
<p>如果测试文件包含函数:<code>func TestMain(m *testing.M)</code>那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。TestMain运行在主goroutine中, 可以在调用 m.Run前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用m.Run的返回值作为参数调用os.Exit。</p>
<p>一个使用TestMain来设置Setup和TearDown的示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"write setup code here..."</span>) <span class="comment">// 测试之前的做一些设置</span></span><br><span class="line">    <span class="comment">// 如果 TestMain 使用了 flags，这里应该加上flag.Parse()</span></span><br><span class="line">    retCode := m.Run()                         <span class="comment">// 执行测试</span></span><br><span class="line">    fmt.Println(<span class="string">"write teardown code here..."</span>) <span class="comment">// 测试之后做一些拆卸工作</span></span><br><span class="line">    os.Exit(retCode)                           <span class="comment">// 退出测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：在调用TestMain时, flag.Parse并没有被调用。所以如果TestMain 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用flag.Parse。</p>
<h4 id="子测试的setup与teardown"><a class="markdownIt-Anchor" href="#子测试的setup与teardown"></a> 子测试的Setup与Teardown</h4>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E5%AD%90%E6%B5%8B%E8%AF%95%E7%9A%84setup%E4%B8%8Eteardown" target="_blank" rel="noopener">子测试的Setup与Teardown</a></p>
<p>有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试集的Setup与Teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupTestCase</span><span class="params">(t *testing.T)</span> <span class="title">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Log(<span class="string">"如有需要在此执行:测试之前的setup"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        t.Log(<span class="string">"如有需要在此执行:测试之后的teardown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子测试的Setup与Teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupSubTest</span><span class="params">(t *testing.T)</span> <span class="title">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Log(<span class="string">"如有需要在此执行:子测试之前的setup"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        t.Log(<span class="string">"如有需要在此执行:子测试之后的teardown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep   <span class="keyword">string</span></span><br><span class="line">        want  []<span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line">        <span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"leading sep"</span>: &#123;input: <span class="string">"枯藤老树昏鸦"</span>, sep: <span class="string">"老"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">""</span>, <span class="string">"枯藤"</span>, <span class="string">"树昏鸦"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    teardownTestCase := setupTestCase(t) <span class="comment">// 测试之前执行setup操作</span></span><br><span class="line">    <span class="keyword">defer</span> teardownTestCase(t)            <span class="comment">// 测试之后执行testdoen操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 使用t.Run()执行子测试</span></span><br><span class="line">            teardownSubTest := setupSubTest(t) <span class="comment">// 子测试之前执行setup操作</span></span><br><span class="line">            <span class="keyword">defer</span> teardownSubTest(t)           <span class="comment">// 测试之后执行testdoen操作</span></span><br><span class="line">            got := Split(tc.input, tc.sep)</span><br><span class="line">            <span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">                t.Errorf(<span class="string">"excepted:%#v, got:%#v"</span>, tc.want, got)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">split $ go test -v</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit&#x2F;simple</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit&#x2F;wrong_sep</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit&#x2F;more_sep</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestSplit&#x2F;leading_sep</span><br><span class="line">--- PASS: TestSplit (0.00s)</span><br><span class="line">    split_test.go:71: 如有需要在此执行:测试之前的setup</span><br><span class="line">    --- PASS: TestSplit&#x2F;simple (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    --- PASS: TestSplit&#x2F;wrong_sep (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    --- PASS: TestSplit&#x2F;more_sep (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    --- PASS: TestSplit&#x2F;leading_sep (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    split_test.go:73: 如有需要在此执行:测试之后的teardown</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN   ExampleSplit</span><br><span class="line">--- PASS: ExampleSplit (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com&#x2F;Q1mi&#x2F;studygo&#x2F;code_demo&#x2F;test_demo&#x2F;split       0.006s</span><br></pre></td></tr></table></figure>
<h3 id="示例函数"><a class="markdownIt-Anchor" href="#示例函数"></a> 示例函数</h3>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">示例函数</a></p>
<h4 id="示例函数的格式"><a class="markdownIt-Anchor" href="#示例函数的格式"></a> 示例函数的格式</h4>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html#%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">示例函数的格式</a></p>
<p>被<code>go test</code>特殊对待的第三种函数就是示例函数，它们的函数名以Example为前缀。它们既没有参数也没有返回值。标准格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例函数示例"><a class="markdownIt-Anchor" href="#示例函数示例"></a> 示例函数示例</h4>
<p>下面的代码是我们为Split函数编写的一个示例函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleSplit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(split.Split(<span class="string">"a:b:c"</span>, <span class="string">":"</span>))</span><br><span class="line">    fmt.Println(split.Split(<span class="string">"枯藤老树昏鸦"</span>, <span class="string">"老"</span>))</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// [a b c]</span></span><br><span class="line">    <span class="comment">// [ 枯藤 树昏鸦]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为代码编写示例代码有如下三个用处：</p>
<ul>
<li>示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联</li>
<li>示例函数只要包含了<code>// Output:</code>也是可以通过<code>go test</code>运行的可执行测试</li>
<li>示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。下图为strings.ToUpper函数在Playground的示例函数效果</li>
</ul>
<h2 id="压力测试"><a class="markdownIt-Anchor" href="#压力测试"></a> 压力测试</h2>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95.html" target="_blank" rel="noopener">压力测试</a></p>
<h3 id="go怎么写测试用例"><a class="markdownIt-Anchor" href="#go怎么写测试用例"></a> Go怎么写测试用例</h3>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95.html#go%E6%80%8E%E4%B9%88%E5%86%99%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B" target="_blank" rel="noopener">Go怎么写测试用例</a></p>
<p>开发程序其中很重要的一点是测试，我们如何保证代码的质量，如何保证每个函数是可运行，运行结果是正确的，又如何保证写出来的代码性能是好的，我们知道单元测试的重点在于发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让线上的程序能够在高并发的情况下还能保持稳定。</p>
<p>Go语言中来实现单元测试和性能测试：Go语言中自带有一个轻量级的测试框架testing和自带的go test命令来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，你可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例，那么接下来让我们一一来看一下怎么写。</p>
<p>另外建议安装gotests插件自动生成测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com&#x2F;cweill&#x2F;gotests&#x2F;...</span><br></pre></td></tr></table></figure>
<h3 id="如何编写测试用例"><a class="markdownIt-Anchor" href="#如何编写测试用例"></a> 如何编写测试用例</h3>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95.html#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B" target="_blank" rel="noopener">如何编写测试用例</a></p>
<h3 id="如何编写压力测试"><a class="markdownIt-Anchor" href="#如何编写压力测试"></a> 如何编写压力测试</h3>
<p><a href="https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95.html#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">如何编写压力测试</a></p>
<p>压力测试用来检测函数(方法）的性能，和编写单元功能测试的方法类似,此处不再赘述，但需要注意：</p>
<p>压力测试用例必须遵循如下格式，其中XXX可以是任意字母数字的组合，但是首字母不能是小写字母</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkXXX</span><span class="params">(b *testing.B)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>go test不会默认执行压力测试的函数，如果要执行压力测试需要带上参数-test.bench，语法:-test.bench=“test_name_regex”,例如<code>go test -test.bench=&quot;.*&quot;</code>表示测试全部的压力测试函数</p>
<p>在压力测试用例中,请记得在循环体内使用testing.B.N,以使测试可以正常的运行 文件名也必须以_test.go结尾</p>
<p>下面我们新建一个压力测试文件webbench_test.go，代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gotest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Division</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123; <span class="comment">//use b.N for looping </span></span><br><span class="line">        Division(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_TimeConsumingFunction</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    b.StopTimer() <span class="comment">//调用该函数停止压力测试的时间计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//做一些初始化的工作,例如读取文件数据,数据库连接之类的,</span></span><br><span class="line">    <span class="comment">//这样这些时间不影响我们测试函数本身的性能</span></span><br><span class="line"></span><br><span class="line">    b.StartTimer() <span class="comment">//重新开始时间</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Division(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们执行命令<code>go test webbench_test.go -test.bench=&quot;.*&quot;</code>，可以看到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark_Division-4                            500000000          7.76 ns&#x2F;op         456 B&#x2F;op          14 allocs&#x2F;op</span><br><span class="line">Benchmark_TimeConsumingFunction-4            500000000          7.80 ns&#x2F;op         224 B&#x2F;op           4 allocs&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      gotest    9.364s</span><br></pre></td></tr></table></figure>
<p>上面的结果显示我们没有执行任何TestXXX的单元测试函数，显示的结果只执行了压力测试函数，第一条显示了Benchmark_Division执行了500000000次，每次的执行平均时间是7.76纳秒，第二条显示了Benchmark_TimeConsumingFunction执行了500000000，每次的平均执行时间是7.80纳秒。最后一条显示总共的执行时间。</p>
<blockquote>
<p>通过上面对单元测试和压力测试的学习，我们可以看到testing包很轻量，编写单元测试和压力测试用例非常简单，配合内置的<code>go test</code>命令就可以非常方便的进行测试，这样在我们每次修改完代码，执行一下<code>go test</code>就可以简单的完成回归测试了。</p>
</blockquote>
<hr />
<h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1>
<p>在之前的<a href="https://www.qingbo1011.top/2022/04/23/Golang%E5%9F%BA%E7%A1%8001/#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85">笔记</a>中已经学习过方法了，这里再详细看一遍。</p>
<h2 id="方法定义"><a class="markdownIt-Anchor" href="#方法定义"></a> 方法定义</h2>
<p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89.html" target="_blank" rel="noopener">方法定义</a></p>
<p>Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。</p>
<ul>
<li>只能为当前包内命名类型定义方法</li>
<li>参数 receiver可任意命名（官方建议只用一个小写字母，如person用p）。如方法中未曾使用 ，可省略参数名</li>
<li>参数 receiver 类型可以是值类型或指针类型</li>
<li>不支持方法重载，receiver 只是参数签名的组成部分</li>
<li>可用实例 value 或 pointer 调用全部方法，<strong>编译器自动转换</strong></li>
</ul>
<p>一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p>
<p>所有给定类型的方法属于该类型的方法集。</p>
<h3 id="方法定义和示例"><a class="markdownIt-Anchor" href="#方法定义和示例"></a> 方法定义和示例</h3>
<p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89.html#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%EF%BC%9A" target="_blank" rel="noopener">方法定义</a></p>
<h3 id="普通函数与方法的区别"><a class="markdownIt-Anchor" href="#普通函数与方法的区别"></a> 普通函数与方法的区别</h3>
<p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89.html#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">普通函数与方法的区别</a></p>
<ul>
<li>对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然</li>
<li>对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以</li>
</ul>
<p>说人话，就是如果方法的receiver类型是指针，也可以直接用本身来调用。反之亦然。（Go的语法糖）</p>
<p>看个例子就行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">   age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">      name: name,</span><br><span class="line">      age:  age,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UpdateAge 专属于Student类的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">UpdateAge</span><span class="params">(newAge <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   s.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := newStudent(<span class="string">"张三"</span>, <span class="number">18</span>) <span class="comment">// 调用构造函数</span></span><br><span class="line">   fmt.Println(s)            <span class="comment">// &amp;&#123;张三 18&#125;</span></span><br><span class="line">   s.UpdateAge(<span class="number">20</span>)</span><br><span class="line">   fmt.Println(s) <span class="comment">// &amp;&#123;张三 20&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名字段"><a class="markdownIt-Anchor" href="#匿名字段"></a> 匿名字段</h2>
<p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5.html" target="_blank" rel="noopener">匿名字段</a></p>
<p>Golang匿名字段 ：可以像字段成员那样访问匿名字段方法，编译器负责查找。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="comment">// receiver = &amp;(Manager.User)</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"User: %p, %v"</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">"Tom"</span>&#125;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Manager: %p\n"</span>, &amp;m)</span><br><span class="line">    fmt.Println(m.ToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manager: 0xc42000a060</span><br><span class="line">User: 0xc42000a060, &amp;&#123;1 Tom&#125;</span><br></pre></td></tr></table></figure>
<p>通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User</span><br><span class="line">    title <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"User: %p, %v"</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Manager)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Manager: %p, %v"</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">"Tom"</span>&#125;, <span class="string">"Administrator"</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.ToString())</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.User.ToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manager: 0xc420074180, &amp;&#123;&#123;1 Tom&#125; Administrator&#125;</span><br><span class="line">User: 0xc420074180, &amp;&#123;1 Tom&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法集"><a class="markdownIt-Anchor" href="#方法集"></a> 方法集</h2>
<p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%E9%9B%86.html" target="_blank" rel="noopener">方法集</a></p>
<p><strong><a href="https://www.bilibili.com/video/BV1NK4y137PJ" target="_blank" rel="noopener">视频</a></strong></p>
<p>Golang方法集 ：每个类型都有与之关联的方法集，这会影响到接口实现规则。</p>
<ul>
<li>类型 T 方法集包含全部 receiver T 方法</li>
<li>类型 *T 方法集包含全部 receiver T + *T 方法</li>
<li>如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法</li>
<li>如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法</li>
<li>不管嵌入 T 或 <code>*T</code>，<code>*S</code> 方法集总是包含 T + *T 方法</li>
</ul>
<p>用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。</p>
<p>Go 语言中内部类型方法集提升的规则：</p>
<ul>
<li>
<p>类型 T 方法集包含全部 receiver T 方法（这个当然是很显然的）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">   a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">study</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"类型 T 方法集包含全部 receiver T 方法"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   t := T&#123;a: <span class="number">1</span>&#125;</span><br><span class="line">   t.study()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220614113718.png" alt="" /></p>
</li>
<li>
<p>类型 <code>*T</code> 方法集包含全部 <code>receiver T + *T</code> 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">study1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"类型 *T 方法集包含全部 receiver T 方法"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">study2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"类型 *T 方法集包含全部 receiver *T 方法"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := &amp;T&#123;a: <span class="number">1</span>&#125;</span><br><span class="line">	t.study1()</span><br><span class="line">	t.study2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220614114814.png" alt="" /></p>
</li>
</ul>
<p>给定一个结构体类型 S 和一个命名为 T 的类型，方法提升像下面规定的这样被包含在结构体方法集中：</p>
<ul>
<li>
<p>如果类型 S 包含匿名字段 T，则 S 和 <code>*S</code> 方法集包含 T 方法</p>
<p>这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为值类型的方法将被提升，可以被外部类型的值和指针调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">   a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">   T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">study1</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s1 := S&#123;T&#123;a: <span class="number">1</span>&#125;&#125;</span><br><span class="line">   s2 := &amp;S&#123;T&#123;a: <span class="number">1</span>&#125;&#125;</span><br><span class="line">   s1.study1()</span><br><span class="line">   s2.study1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果类型 S 包含匿名字段 <code>*T</code>，则 S 和 <code>*S</code> 方法集包含 <code>T + *T</code> 方法。</p>
<p>这条规则说的是当我们嵌入一个类型的指针，嵌入类型的接受者为值类型或指针类型的方法将被提升，可以被外部类型的值或者指针调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">   a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">   *T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">study1</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">study2</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s1 := S&#123;&amp;T&#123;a: <span class="number">1</span>&#125;&#125;</span><br><span class="line">   s2 := &amp;S&#123;&amp;T&#123;a: <span class="number">1</span>&#125;&#125;</span><br><span class="line">   s1.study1()</span><br><span class="line">   s1.study2()</span><br><span class="line">   s2.study1()</span><br><span class="line">   s2.study2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="表达式"><a class="markdownIt-Anchor" href="#表达式"></a> 表达式</h2>
<p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">表达式</a></p>
<p>Golang 表达式 ：根据调用者不同，方法分为两种表现形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   instance.method(args...)</span><br><span class="line">&lt;<span class="keyword">type</span>&gt;<span class="function">.<span class="keyword">func</span><span class="params">(instance, args...)</span></span></span><br></pre></td></tr></table></figure>
<p>前者称为 method value，后者 method expression。</p>
<p>两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">   id   <span class="keyword">int</span></span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">study</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"%p, %v\n"</span>, u, u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   u := user&#123;</span><br><span class="line">      id:   <span class="number">1</span>,</span><br><span class="line">      name: <span class="string">"tom"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   u.study()</span><br><span class="line">   mValue := u.study</span><br><span class="line">   mValue() <span class="comment">// 隐式传递receiver</span></span><br><span class="line">   mExpression := (*user).study</span><br><span class="line">   mExpression(&amp;u) <span class="comment">// 显式传递receiver</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220614122049.png" alt="" /></p>
<p>需要注意，method value 会复制 receiver。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self User)</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">"Tom"</span>&#125;</span><br><span class="line">    mValue := u.Test <span class="comment">// 立即复制 receiver，因为不是指针类型，不受后续修改影响。</span></span><br><span class="line"></span><br><span class="line">    u.id, u.name = <span class="number">2</span>, <span class="string">"Jack"</span></span><br><span class="line">    u.Test()</span><br><span class="line"></span><br><span class="line">    mValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;2 Jack&#125;</span><br><span class="line">&#123;1 Tom&#125;</span><br></pre></td></tr></table></figure>
<p>剩余部分参考<a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">表达式</a></p>
<h2 id="自定义error"><a class="markdownIt-Anchor" href="#自定义error"></a> 自定义error</h2>
<h3 id="panicrecover-2"><a class="markdownIt-Anchor" href="#panicrecover-2"></a> panic&amp;recover</h3>
<p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E8%87%AA%E5%AE%9A%E4%B9%89error.html#%E7%B3%BB%E7%BB%9F%E6%8A%9B" target="_blank" rel="noopener">系统抛</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统抛</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">   a[<span class="number">1</span>] = <span class="number">123</span></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">   <span class="comment">//a[10] = 11</span></span><br><span class="line">   index := <span class="number">10</span></span><br><span class="line">   a[index] = <span class="number">10</span></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCircleArea</span><span class="params">(radius <span class="keyword">float32</span>)</span> <span class="params">(area <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 自己抛</span></span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"半径不能为负"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span> &#123;</span><br><span class="line">   getCircleArea(<span class="number">-5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test03</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 延时执行匿名函数</span></span><br><span class="line">   <span class="comment">// 延时到何时？（1）程序正常结束   （2）发生异常时</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// recover() 复活 恢复</span></span><br><span class="line">      <span class="comment">// 会返回程序为什么挂了</span></span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   getCircleArea(<span class="number">-5</span>)</span><br><span class="line">   fmt.Println(<span class="string">"这里有没有执行"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test04</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   test03()</span><br><span class="line">   fmt.Println(<span class="string">"test04"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   test04()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="return-error"><a class="markdownIt-Anchor" href="#return-error"></a> return error</h3>
<p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E8%87%AA%E5%AE%9A%E4%B9%89error.html#%E8%BF%94%E5%9B%9E%E5%BC%82%E5%B8%B8" target="_blank" rel="noopener">返回异常</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"errors"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCircleArea</span><span class="params">(radius <span class="keyword">float32</span>)</span> <span class="params">(area <span class="keyword">float32</span>, err error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 构建个异常对象</span></span><br><span class="line">      err = errors.New(<span class="string">"半径不能为负"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   area = <span class="number">3.14</span> * radius * radius</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   area, err := getCircleArea(<span class="number">-5</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(area)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义error-2"><a class="markdownIt-Anchor" href="#自定义error-2"></a> 自定义error</h3>
<p><a href="https://www.topgoer.com/%E6%96%B9%E6%B3%95/%E8%87%AA%E5%AE%9A%E4%B9%89error.html#%E8%BF%94%E5%9B%9E%E5%BC%82%E5%B8%B8" target="_blank" rel="noopener">自定义error</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"os"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">   path       <span class="keyword">string</span></span><br><span class="line">   op         <span class="keyword">string</span></span><br><span class="line">   createTime <span class="keyword">string</span></span><br><span class="line">   message    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Sprintf(<span class="string">"path=%s \nop=%s \ncreateTime=%s \nmessage=%s"</span>, p.path,</span><br><span class="line">      p.op, p.createTime, p.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   file, err := os.Open(filename)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;PathError&#123;</span><br><span class="line">         path:       filename,</span><br><span class="line">         op:         <span class="string">"read"</span>,</span><br><span class="line">         message:    err.Error(),</span><br><span class="line">         createTime: fmt.Sprintf(<span class="string">"%v"</span>, time.Now()),</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> file.Close()</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := Open(<span class="string">"/Users/5lmh/Desktop/go/src/test.txt"</span>)</span><br><span class="line">   <span class="keyword">switch</span> v := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">   <span class="keyword">case</span> *PathError:</span><br><span class="line">      fmt.Println(<span class="string">"get path error,"</span>, v)</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get path error, path&#x3D;&#x2F;Users&#x2F;pprof&#x2F;Desktop&#x2F;go&#x2F;src&#x2F;test.txt </span><br><span class="line">op&#x3D;read </span><br><span class="line">createTime&#x3D;2018-04-05 11:25:17.331915 +0800 CST m&#x3D;+0.000441790 </span><br><span class="line">message&#x3D;open &#x2F;Users&#x2F;pprof&#x2F;Desktop&#x2F;go&#x2F;src&#x2F;test.txt: no such file or directory</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h1>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html" target="_blank" rel="noopener">接口</a></p>
<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h2 id="接口类型"><a class="markdownIt-Anchor" href="#接口类型"></a> 接口类型</h2>
<p>在Go语言中<strong>接口（interface）是一种类型，一种抽象的类型</strong>。</p>
<p>interface是一组method的集合，是<a href="https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d" target="_blank" rel="noopener">duck-type programming</a>的一种体现（If it looks like a duck, and it quacks like a duck, then it is a duck.）。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。请牢记接口（interface）是一种类型。</p>
<blockquote>
<p><a href="https://medium.com/@matryer/golang-advent-calendar-day-one-duck-typing-a513aaed544d" target="_blank" rel="noopener">Duck typing in Go</a></p>
</blockquote>
<h2 id="为什么要使用接口"><a class="markdownIt-Anchor" href="#为什么要使用接口"></a> 为什么要使用接口</h2>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">为什么要使用接口</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"喵喵喵"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"汪汪汪"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Cat&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"猫:"</span>, c.Say())</span><br><span class="line">    d := Dog&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"狗:"</span>, d.Say())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？</p>
<blockquote>
<p>像类似的例子在我们编程过程中会经常遇到：</p>
<p>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</p>
<p>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</p>
<p>比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？</p>
</blockquote>
<p>Go语言中为了解决类似上面的问题，就设计了<strong>接口</strong>这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p>
<h2 id="接口的定义"><a class="markdownIt-Anchor" href="#接口的定义"></a> 接口的定义</h2>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">接口的定义</a></p>
<p>Go语言提倡<strong>面向接口编程</strong>。</p>
<ul>
<li>接口是一个或多个方法签名的集合。任何类型的方法集中只要拥有该接口对应的<strong>全部方法</strong>签名，就表示它 “实现” 了该接口，<strong>无须在该类型上显式声明实现了哪个接口</strong>。这称为Structural Typing。所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。当然，该类型还可以有其他方法。</li>
<li>接口只有方法声明，没有实现，没有数据字段。</li>
<li>接口可以匿名嵌入其他接口，或嵌入到结构中。 对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。</li>
<li>只有当接口存储的类型和对象都为nil时，接口才等于nil。</li>
<li>接口调用不会做receiver的自动转换。</li>
<li>接口同样支持匿名字段方法。</li>
<li>接口也可实现类似OOP中的多态。</li>
<li><strong>空接口可以作为任何类型数据的容器。</strong></li>
<li>一个类型可实现多个接口。</li>
<li>接口命名习惯以<code>er</code>结尾。</li>
</ul>
<p>每个接口由数个方法组成，接口的定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>接口名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：<strong>当方法名首字母是大写且这个接口类型名首字母也是大写时</strong>，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span> &#123;</span><br><span class="line">   Writer([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。</p>
<h2 id="实现接口的条件"><a class="markdownIt-Anchor" href="#实现接口的条件"></a> 实现接口的条件</h2>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9D%A1%E4%BB%B6" target="_blank" rel="noopener">实现接口的条件</a></p>
<p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。</p>
<p>我们来定义一个Sayer接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">   say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义dog和cat两个结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"喵"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"汪汪"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。</p>
<h2 id="接口类型变量"><a class="markdownIt-Anchor" href="#接口类型变量"></a> 接口类型变量</h2>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">接口类型变量</a></p>
<p>那实现了接口有什么用呢？</p>
<p><strong>接口类型变量能够存储所有实现了该接口的实例</strong>。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。</p>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">   say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"喵"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"汪汪"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x Sayer <span class="comment">// 声明一个Sayer类型的变量x</span></span><br><span class="line">   c := cat&#123;&#125;  <span class="comment">// 实例化一个cat</span></span><br><span class="line">   d := dog&#123;&#125;  <span class="comment">// 实例化一个dog</span></span><br><span class="line">   x = c       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">   x.say()     <span class="comment">// 喵</span></span><br><span class="line">   x = d       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">   x.say()     <span class="comment">// 汪汪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="值接收者和指针接收者实现接口"><a class="markdownIt-Anchor" href="#值接收者和指针接收者实现接口"></a> 值接收者和指针接收者实现接口</h2>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">值接收者和指针接收者实现接口的区别</a></p>
<p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p>
<p>我们有一个Mover接口和一个dog结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="值接收者实现接口"><a class="markdownIt-Anchor" href="#值接收者实现接口"></a> 值接收者实现接口</h3>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">值接收者实现接口</a></p>
<p>实现接口的是dog类型，例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"狗会跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x Mover</span><br><span class="line">   wangcai := dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">   fugui := &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">   x = wangcai      <span class="comment">// x可以接收dog类型</span></span><br><span class="line">   x.move()</span><br><span class="line">   x = fugui <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">   x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们可以发现，<strong>使用值接收者实现接口之后，不管是dog结构体还是结构体指针<code>*dog</code>类型的变量都可以赋值给该接口变量。</strong></p>
<p>因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值<code>*fugui</code>。</p>
<h3 id="指针接收者实现接口"><a class="markdownIt-Anchor" href="#指针接收者实现接口"></a> 指针接收者实现接口</h3>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">指针接收者实现接口</a></p>
<p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"狗会跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x Mover</span><br><span class="line">   wangcai := dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">   fugui := &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">   x = wangcai      <span class="comment">// 报错：x不可以接收dog类型</span></span><br><span class="line">   x.move()</span><br><span class="line">   x = fugui <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">   x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时实现Mover接口的是<code>*dog</code>类型，所以不能给x传入dog类型的wangcai，此时x只能存储<code>*dog</code>类型的值。</p>
<h2 id="类型与接口的关系"><a class="markdownIt-Anchor" href="#类型与接口的关系"></a> 类型与接口的关系</h2>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank" rel="noopener">类型与接口的关系</a></p>
<h3 id="一个类型实现多个接口"><a class="markdownIt-Anchor" href="#一个类型实现多个接口"></a> 一个类型实现多个接口</h3>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">一个类型实现多个接口</a></p>
<p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">   say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dog既可以实现Sayer接口，也可以实现Mover接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">   say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"汪汪"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"狗会跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x Sayer</span><br><span class="line">   <span class="keyword">var</span> y Mover</span><br><span class="line">   d := dog&#123;&#125;</span><br><span class="line">   x = d</span><br><span class="line">   y = d</span><br><span class="line">   x.say()</span><br><span class="line">   y.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个类型实现同一接口"><a class="markdownIt-Anchor" href="#多个类型实现同一接口"></a> 多个类型实现同一接口</h3>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%90%8C%E4%B8%80%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">多个类型实现同一接口</a></p>
<p>Go语言中不同的类型还可以实现同一接口。</p>
<p>首先我们定义一个Mover接口，它要求必须由一个move方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>狗可以动，汽车也可以动，可以使用如下代码实现这个关系：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> car <span class="keyword">struct</span> &#123;</span><br><span class="line">   brand <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(d.name + <span class="string">"会跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c car)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(c.brand + <span class="string">"速度七十迈"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x Mover</span><br><span class="line">   d := dog&#123;name: <span class="string">"旺财"</span>&#125;</span><br><span class="line">   c := car&#123;brand: <span class="string">"奔驰"</span>&#125;</span><br><span class="line">   x = d</span><br><span class="line">   x.move() <span class="comment">// 旺财会跑</span></span><br><span class="line">   x = c</span><br><span class="line">   x.move() <span class="comment">// 奔驰速度七十迈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的move方法就可以了。</p>
<p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中<strong>嵌入其他类型或者结构体</strong>来实现。例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> washMachine <span class="keyword">interface</span> &#123; <span class="comment">// 洗衣机</span></span><br><span class="line">   wash()</span><br><span class="line">   dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span> &#123; <span class="comment">// 甩干器</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span> <span class="title">dry</span><span class="params">()</span></span> &#123; <span class="comment">// 实现washingMachine接口的dry()方法</span></span><br><span class="line">   fmt.Println(<span class="string">"甩干"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123; <span class="comment">// 海尔洗衣机</span></span><br><span class="line">   dryer <span class="comment">// 嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span> <span class="title">wash</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"洗刷刷"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x washMachine</span><br><span class="line">   h := haier&#123;dryer&#123;&#125;&#125;</span><br><span class="line">   x = h</span><br><span class="line">   x.wash() <span class="comment">// 洗刷刷</span></span><br><span class="line">   x.dry()  <span class="comment">// 甩干</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口嵌套"><a class="markdownIt-Anchor" href="#接口嵌套"></a> 接口嵌套</h3>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97" target="_blank" rel="noopener">接口嵌套</a></p>
<p>接口与接口间可以通过嵌套创造出新的接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">   say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">   sayer</span><br><span class="line">   mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">   say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mover <span class="keyword">interface</span> &#123;</span><br><span class="line">   move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">   sayer</span><br><span class="line">   mover</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"喵"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"猫会跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x animal</span><br><span class="line">   x = cat&#123;name: <span class="string">"翠花"</span>&#125;</span><br><span class="line">   x.say()  <span class="comment">// 喵</span></span><br><span class="line">   x.move() <span class="comment">// 猫会跑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空接口"><a class="markdownIt-Anchor" href="#空接口"></a> 空接口</h2>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E7%A9%BA%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">空接口</a></p>
<blockquote>
<p>在go1.18之后，有关键词<code>any</code>来替代<code>interface{}</code>。源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// any is an alias for interface&#123;&#125; and is equivalent to interface&#123;&#125; in all ways.</span></span><br><span class="line"><span class="keyword">type</span> any = <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="空接口的定义"><a class="markdownIt-Anchor" href="#空接口的定义"></a> 空接口的定义</h3>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">空接口的定义</a></p>
<p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p><strong>空接口类型的变量可以存储任意类型的变量。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 定义一个空接口</span></span><br><span class="line">   x = <span class="string">"hello"</span></span><br><span class="line">   fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x) <span class="comment">// type:string value:hello</span></span><br><span class="line">   x = <span class="number">1</span></span><br><span class="line">   fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x) <span class="comment">// type:int value:1</span></span><br><span class="line">   x = <span class="literal">true</span></span><br><span class="line">   fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x) <span class="comment">// type:bool value:true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空接口的应用"><a class="markdownIt-Anchor" href="#空接口的应用"></a> 空接口的应用</h3>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">空接口的应用</a></p>
<ul>
<li>空接口作为函数的参数</li>
<li>空接口作为map的值</li>
</ul>
<h4 id="空接口作为函数的参数"><a class="markdownIt-Anchor" href="#空接口作为函数的参数"></a> 空接口作为函数的参数</h4>
<p>使用空接口实现可以接收任意类型的函数参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   show(<span class="string">"hello"</span>) <span class="comment">// type:string value:hello</span></span><br><span class="line">   show(<span class="number">1</span>)       <span class="comment">// type:int value:1</span></span><br><span class="line">   show(<span class="literal">true</span>)    <span class="comment">// type:bool value:true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="空接口作为map的值"><a class="markdownIt-Anchor" href="#空接口作为map的值"></a> 空接口作为map的值</h4>
<p>使用空接口实现可以保存任意值的字典。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   studentInfo := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   studentInfo[<span class="string">"name"</span>] = <span class="string">"张三"</span></span><br><span class="line">   studentInfo[<span class="string">"age"</span>] = <span class="string">"18"</span></span><br><span class="line">   studentInfo[<span class="string">"married"</span>] = <span class="literal">false</span></span><br><span class="line">   fmt.Println(studentInfo) <span class="comment">// map[age:18 married:false name:张三]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型断言"><a class="markdownIt-Anchor" href="#类型断言"></a> 类型断言</h3>
<p><a href="https://www.topgoer.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3.html#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80" target="_blank" rel="noopener">类型断言</a></p>
<p>空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？</p>
<p>这里就要引入一下接口值的概念了：一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为<strong>接口的动态类型和动态值</strong>。</p>
<p>我们来看一个具体的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>请看下图分解：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220615124028.png" alt="" /></p>
<p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>x：表示类型为<code>interface{}</code>的变量</li>
<li>T：表示断言x可能是的类型</li>
</ul>
<p>该语法返回两个参数，<strong>第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败</strong>。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   x = <span class="string">"hello"</span></span><br><span class="line">   v, ok := x.(<span class="keyword">string</span>)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      fmt.Println(v) <span class="comment">// hello</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"类型断言失败！"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的示例中如果要断言多次就需要写多个if判断，这个时候我们可以使用switch语句来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"x is a string，value is %v\n"</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"x is a int is %v\n"</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"x is a bool is %v\n"</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"unsupport type！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因为<strong>空接口可以存储任意类型值</strong>的特点，所以空接口在Go语言中的使用十分广泛。</p>
<p>关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。<strong>不要为了接口而写接口</strong>，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:qingbo1011@163.com">qingbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.qingbo1011.top/2022/04/24/Golang%E5%9F%BA%E7%A1%8002/">http://www.qingbo1011.top/2022/04/24/Golang%E5%9F%BA%E7%A1%8002/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.qingbo1011.top" target="_blank">Qing's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20231003161115.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/04/25/Golang%E8%BF%9B%E9%98%B601%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><img class="prev_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Golang进阶——网络编程</div></div></a></div><div class="next-post pull_right"><a href="/2022/04/23/Golang%E5%9F%BA%E7%A1%8001/"><img class="next_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Golang基础（一）</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/06/26/Gin+Gorm v2+Github Action的实践/" title="Gin+Gorm v2+Github Action的实践"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220808182712.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-06-26</div><div class="relatedPosts_title">Gin+Gorm v2+Github Action的实践</div></div></a></div><div class="relatedPosts_item"><a href="/2022/05/02/Gin+Gorm开发在线备忘录（To do list）/" title="Gin+Gorm开发在线备忘录（To do list）"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220525201522.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-05-02</div><div class="relatedPosts_title">Gin+Gorm开发在线备忘录（To do list）</div></div></a></div><div class="relatedPosts_item"><a href="/2022/05/01/Gin+JWT+Air热部署的简单实践/" title="Gin+JWT+Air热部署的简单实践"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220525201522.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-05-01</div><div class="relatedPosts_title">Gin+JWT+Air热部署的简单实践</div></div></a></div><div class="relatedPosts_item"><a href="/2022/05/21/Gin+WebSocket+MongoDB的IM即时聊天Demo/" title="Gin+Websocket+MangoDB实现的IM系统"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220525201522.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-05-21</div><div class="relatedPosts_title">Gin+Websocket+MangoDB实现的IM系统</div></div></a></div><div class="relatedPosts_item"><a href="/2022/06/12/Gin-blog：go1.18在gin上的实践/" title="Gin-blog：go1.18在gin上的实践"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220525201522.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-06-12</div><div class="relatedPosts_title">Gin-blog：go1.18在gin上的实践</div></div></a></div><div class="relatedPosts_item"><a href="/2022/05/10/Gin限流/" title="Gin限流"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220718144444.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-05-10</div><div class="relatedPosts_title">Gin限流</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'oNS5Emx1qUL3wN5yvPLKol0W-gzGzoHsz',
  appKey: 'ytbw0ho3DMX0FeoAOWa37lf9',
  notify: false,
  verify: false,
  placeholder: 'Stay hungry,stay foolish~',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: 'https://',
  emojiMaps: {"欢呼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100836.gif","笑眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100849.gif","花心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100907.gif","吐舌":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100937.gif","疑问":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100951.gif","滑稽":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101004.gif","太开心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101017.gif","酷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101029.gif","怒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101044.gif","阴险":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101100.gif","委屈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101116.gif","乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101129.gif","你懂的":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101204.gif","小乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101215.gif","突然兴奋":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101228.gif","喷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101241.gif","哈哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101255.gif","喝酒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101305.gif","汗":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101323.gif","笑尿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102004.gif","嘿嘿嘿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102018.gif","真棒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102047.gif","托腮":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102108.gif","微笑":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","礼貌":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","笑哭":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","无奈":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","爱你":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","吃瓜":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_thumb.png","doge":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","dog":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","cat":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_thumb.png","星星眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102225.png","酸了":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102240.png","大哭":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102254.png","傲娇":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102314.png","给心心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102328.png","嘿哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102345.png","custom0":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101410.gif","custom1":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101424.webp","狗头":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101710.png","搬砖中":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101744.png","忙到飞起":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102411.png","裂开":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102426.png","叹气":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102439.png","让我看看":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102456.png","panda0":"https://bbs.res.meizu.com/static/image/smiley/panda/_000.png","panda1":"https://bbs.res.meizu.com/static/image/smiley/panda/_001.png","panda2":"https://bbs.res.meizu.com/static/image/smiley/panda/_002.png","panda3":"https://bbs.res.meizu.com/static/image/smiley/panda/_003.png","panda4":"https://bbs.res.meizu.com/static/image/smiley/panda/_004.png","panda5":"https://bbs.res.meizu.com/static/image/smiley/panda/_005.png","panda6":"https://bbs.res.meizu.com/static/image/smiley/panda/_006.png","panda7":"https://bbs.res.meizu.com/static/image/smiley/panda/_007.png","panda8":"https://bbs.res.meizu.com/static/image/smiley/panda/_008.png","panda9":"https://bbs.res.meizu.com/static/image/smiley/panda/_009.png","panda10":"https://bbs.res.meizu.com/static/image/smiley/panda/_010.png","panda11":"https://bbs.res.meizu.com/static/image/smiley/panda/_011.png","panda12":"https://bbs.res.meizu.com/static/image/smiley/panda/_012.png","panda13":"https://bbs.res.meizu.com/static/image/smiley/panda/_013.png","panda14":"https://bbs.res.meizu.com/static/image/smiley/panda/_014.png","panda15":"https://bbs.res.meizu.com/static/image/smiley/panda/_015.png","panda16":"https://bbs.res.meizu.com/static/image/smiley/panda/_016.png","panda17":"https://bbs.res.meizu.com/static/image/smiley/panda/_017.png","panda18":"https://bbs.res.meizu.com/static/image/smiley/panda/_018.png","panda19":"https://bbs.res.meizu.com/static/image/smiley/panda/_019.png","panda20":"https://bbs.res.meizu.com/static/image/smiley/panda/_020.png","panda21":"https://bbs.res.meizu.com/static/image/smiley/panda/_021.png","panda22":"https://bbs.res.meizu.com/static/image/smiley/panda/_022.png","panda23":"https://bbs.res.meizu.com/static/image/smiley/panda/_023.png","panda24":"https://bbs.res.meizu.com/static/image/smiley/panda/_024.png","panda25":"https://bbs.res.meizu.com/static/image/smiley/panda/_025.png","panda26":"https://bbs.res.meizu.com/static/image/smiley/panda/_026.png","panda27":"https://bbs.res.meizu.com/static/image/smiley/panda/_027.png","panda28":"https://bbs.res.meizu.com/static/image/smiley/panda/_028.png","panda29":"https://bbs.res.meizu.com/static/image/smiley/panda/_029.png"},
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By qingbo</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">宇宙很大，生活更大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script></body></html>
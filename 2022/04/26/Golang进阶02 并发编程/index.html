<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Golang进阶——并发编程 | Qing's Blog</title><meta name="description" content="Golang进阶——并发编程 并发编程 如果想对Go并发编程进一步了解的话，推荐去写一个Go的秒杀系统进行实战演练。  并发介绍  进程和线程  进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位 线程是进程的一个执行实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位 一个进程可以创建和撤销多个线程；同一个进程中的多个线程之间可以并发执行   并发和"><meta name="keywords" content="Golang进阶——并发编程"><meta name="author" content="qingbo,qingbo1011@163.com"><meta name="copyright" content="qingbo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Golang进阶——并发编程"><meta name="twitter:description" content="Golang进阶——并发编程 并发编程 如果想对Go并发编程进一步了解的话，推荐去写一个Go的秒杀系统进行实战演练。  并发介绍  进程和线程  进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位 线程是进程的一个执行实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位 一个进程可以创建和撤销多个线程；同一个进程中的多个线程之间可以并发执行   并发和"><meta name="twitter:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png"><meta property="og:type" content="article"><meta property="og:title" content="Golang进阶——并发编程"><meta property="og:url" content="http://www.qingbo1011.top/2022/04/26/Golang%E8%BF%9B%E9%98%B602%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="Qing's Blog"><meta property="og:description" content="Golang进阶——并发编程 并发编程 如果想对Go并发编程进一步了解的话，推荐去写一个Go的秒杀系统进行实战演练。  并发介绍  进程和线程  进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位 线程是进程的一个执行实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位 一个进程可以创建和撤销多个线程；同一个进程中的多个线程之间可以并发执行   并发和"><meta property="og:image" content="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png"><meta property="article:published_time" content="2022-04-26T00:47:03.000Z"><meta property="article:modified_time" content="2023-10-03T08:16:11.761Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://www.qingbo1011.top/2022/04/26/Golang%E8%BF%9B%E9%98%B602%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><link rel="prev" title="Go常用标准库" href="http://www.qingbo1011.top/2022/04/27/Go%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/"><link rel="next" title="Golang进阶——网络编程" href="http://www.qingbo1011.top/2022/04/25/Golang%E8%BF%9B%E9%98%B601%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220501212415.jpg" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230440.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">87</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">81</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#golang进阶并发编程"><span class="toc-number">1.</span> <span class="toc-text"> Golang进阶——并发编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发介绍"><span class="toc-number">2.</span> <span class="toc-text"> 并发介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程和线程"><span class="toc-number">2.1.</span> <span class="toc-text"> 进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发和并行"><span class="toc-number">2.2.</span> <span class="toc-text"> 并发和并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程和协程"><span class="toc-number">2.3.</span> <span class="toc-text"> 线程和协程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#goroutine"><span class="toc-number">3.</span> <span class="toc-text"> Goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用goroutine"><span class="toc-number">3.1.</span> <span class="toc-text"> 使用goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动单个goroutine"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 启动单个goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动多个goroutine"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 启动多个goroutine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#goroutine与线程"><span class="toc-number">3.2.</span> <span class="toc-text"> goroutine与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可增长的栈"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 可增长的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine调度gpm"><span class="toc-number">3.2.2.</span> <span class="toc-text"> goroutine调度（GPM）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#runtime包"><span class="toc-number">4.</span> <span class="toc-text"> runtime包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#runtimegosched"><span class="toc-number">4.1.</span> <span class="toc-text"> runtime.Gosched()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runtimegoexit"><span class="toc-number">4.2.</span> <span class="toc-text"> runtime.Goexit()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runtimegomaxprocs"><span class="toc-number">4.3.</span> <span class="toc-text"> runtime.GOMAXPROCS()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#channel"><span class="toc-number">5.</span> <span class="toc-text"> Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#channel类型"><span class="toc-number">5.1.</span> <span class="toc-text"> channel类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#声明channel"><span class="toc-number">5.2.</span> <span class="toc-text"> 声明channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建channel"><span class="toc-number">5.3.</span> <span class="toc-text"> 创建channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作channel"><span class="toc-number">5.4.</span> <span class="toc-text"> 操作channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送"><span class="toc-number">5.4.1.</span> <span class="toc-text"> 发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收"><span class="toc-number">5.4.2.</span> <span class="toc-text"> 接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭"><span class="toc-number">5.4.3.</span> <span class="toc-text"> 关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无缓冲的channel"><span class="toc-number">5.5.</span> <span class="toc-text"> 无缓冲的channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有缓冲的channel"><span class="toc-number">5.6.</span> <span class="toc-text"> 有缓冲的channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#close"><span class="toc-number">5.7.</span> <span class="toc-text"> close()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何优雅的从channel循环取值如何判断channel是否关闭"><span class="toc-number">5.7.1.</span> <span class="toc-text"> 如何优雅的从channel循环取值（如何判断channel是否关闭）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单向通道"><span class="toc-number">5.8.</span> <span class="toc-text"> 单向通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通道异常"><span class="toc-number">5.9.</span> <span class="toc-text"> 通道异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#goroutine池"><span class="toc-number">6.</span> <span class="toc-text"> Goroutine池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自己写一个goroutine池玩玩"><span class="toc-number">6.0.1.</span> <span class="toc-text"> 自己写一个goroutine池玩玩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定时器"><span class="toc-number">7.</span> <span class="toc-text"> 定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#timer"><span class="toc-number">7.1.</span> <span class="toc-text"> Timer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ticker"><span class="toc-number">7.2.</span> <span class="toc-text"> Ticker</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#select"><span class="toc-number">8.</span> <span class="toc-text"> select</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发安全和锁"><span class="toc-number">9.</span> <span class="toc-text"> 并发安全和锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#互斥锁"><span class="toc-number">9.1.</span> <span class="toc-text"> 互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读写互斥锁"><span class="toc-number">9.2.</span> <span class="toc-text"> 读写互斥锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sync包"><span class="toc-number">10.</span> <span class="toc-text"> Sync包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#syncwaitgroup"><span class="toc-number">10.1.</span> <span class="toc-text"> sync.WaitGroup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synconce"><span class="toc-number">10.2.</span> <span class="toc-text"> sync.Once</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载配置文件示例"><span class="toc-number">10.2.1.</span> <span class="toc-text"> 加载配置文件示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#syncmap"><span class="toc-number">10.3.</span> <span class="toc-text"> sync.Map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#atomic包原子操作"><span class="toc-number">11.</span> <span class="toc-text"> atomic包（原子操作）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原子操作"><span class="toc-number">11.1.</span> <span class="toc-text"> 原子操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic包"><span class="toc-number">11.2.</span> <span class="toc-text"> atomic包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例"><span class="toc-number">11.3.</span> <span class="toc-text"> 示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gmp-原理与调度"><span class="toc-number">12.</span> <span class="toc-text"> GMP 原理与调度</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Qing's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Golang进阶——并发编程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-04-26 08:47:03"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2022-04-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-10-03 16:16:11"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2023-10-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">10k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 38 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2022/04/26/Golang%E8%BF%9B%E9%98%B602%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2022/04/26/Golang%E8%BF%9B%E9%98%B602%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="golang进阶并发编程"><a class="markdownIt-Anchor" href="#golang进阶并发编程"></a> Golang进阶——并发编程</h1>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" target="_blank" rel="noopener">并发编程</a></p>
<p>如果想对Go并发编程进一步了解的话，推荐去写一个Go的秒杀系统进行实战演练。</p>
<h1 id="并发介绍"><a class="markdownIt-Anchor" href="#并发介绍"></a> 并发介绍</h1>
<h2 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h2>
<ul>
<li>进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位</li>
<li>线程是进程的一个执行实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位</li>
<li>一个进程可以创建和撤销多个线程；同一个进程中的多个线程之间可以<strong>并发</strong>执行</li>
</ul>
<h2 id="并发和并行"><a class="markdownIt-Anchor" href="#并发和并行"></a> 并发和并行</h2>
<ul>
<li>并发：<strong>多线程</strong>程序在<strong>一个核的cpu</strong>上运行</li>
<li>并行：<strong>多线程</strong>程序在<strong>多个核的cpu</strong>上运行</li>
</ul>
<center class="half">    <img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220515134428.png" width="300"/>    <img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220515134439.png" width="300"/> </center>
<p>并发不是并行：</p>
<ul>
<li><strong>并发</strong>：主要由<strong>切换时间片</strong>来实现同时运行</li>
<li>并行：直接利用多核实现多线程的运行</li>
</ul>
<p><strong>go可以设置使用核数，以发挥多核计算机的能力。</strong></p>
<h2 id="线程和协程"><a class="markdownIt-Anchor" href="#线程和协程"></a> 线程和协程</h2>
<ul>
<li>线程：<strong>一个线程上可以跑多个协程</strong>，<strong>协程是轻量级的线程</strong></li>
<li>协程：<strong>独立的栈空间，共享堆空间</strong>，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的</li>
</ul>
<h1 id="goroutine"><a class="markdownIt-Anchor" href="#goroutine"></a> Goroutine</h1>
<p><code>goroutine</code>是由官方实现的超级线程池。<strong>每个实例4~5KB的栈内存占用</strong>和<strong>由于实现机制而大幅减少的创建和销毁开销</strong>是<strong>go高并发的根本原因</strong>。</p>
<p>goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</p>
<blockquote>
<p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员<strong>只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行</strong>呢？</p>
</blockquote>
<p>Go语言中的<code>goroutine</code>就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。<strong>Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU</strong>。Go语言之所以被称为现代化的编程语言，就是因为它<strong>在语言层面已经内置了调度和上下文切换的机制</strong>。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能：<code>goroutine</code>，当你<strong>需要让某个任务并发执行</strong>的时候，你<strong>只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数</strong>就可以了，就是这么简单粗暴。</p>
<h2 id="使用goroutine"><a class="markdownIt-Anchor" href="#使用goroutine"></a> 使用goroutine</h2>
<p>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个goroutine。</p>
<p><strong>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</strong></p>
<h3 id="启动单个goroutine"><a class="markdownIt-Anchor" href="#启动单个goroutine"></a> 启动单个goroutine</h3>
<p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p>
<p>示例：先看以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   hello()</span><br><span class="line">   fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220515203432.png" alt="" /></p>
<p>可以看到在这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p>
<p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是<strong>启动一个goroutine去执行hello这个函数</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">   fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220515203835.png" alt="" /></p>
<p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。这是因为：</p>
<p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的goroutine。<strong>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束</strong>。</p>
<blockquote>
<p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220515204337.png" alt="" />、</p>
<p>可以发现是先打印<code>main goroutine done!</code>，这是因为我们<strong>在创建新的goroutine的时候需要花费一些时间</strong>，而此时main函数所在的goroutine是继续执行的。</p>
</blockquote>
<h3 id="启动多个goroutine"><a class="markdownIt-Anchor" href="#启动多个goroutine"></a> 启动多个goroutine</h3>
<p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来<strong>实现goroutine的同步</strong>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">		<span class="keyword">go</span> hello(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello Goroutine!"</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220515210913.png" alt="" /></p>
<p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为<strong>5个goroutine是并发执行的，而goroutine的调度是随机的。</strong></p>
<blockquote>
<p>注意：如果主协程退出了，其他任务还执行吗？看一下如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用匿名函数</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">      fmt.Printf(<span class="string">"new goroutine: i = %v\n"</span>, i)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;()</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">   i++</span><br><span class="line">   fmt.Printf(<span class="string">"new goroutine: i = %v\n"</span>, i)</span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行结果可以看到：如果主协程退出了，其他任务就不会执行了。（因为我们上面已经提到过了，<strong>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束</strong>。）</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220515211632.png" alt="" /></p>
</blockquote>
<h2 id="goroutine与线程"><a class="markdownIt-Anchor" href="#goroutine与线程"></a> goroutine与线程</h2>
<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ul>
<li>一个操作系统线程对应用户态多个goroutine。</li>
<li>go程序可以同时使用多个操作系统线程。</li>
<li>goroutine和OS线程是多对多的关系，即m:n。</li>
</ul>
<h3 id="可增长的栈"><a class="markdownIt-Anchor" href="#可增长的栈"></a> 可增长的栈</h3>
<p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB），<strong>一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB）</strong>，<strong>goroutine的栈不是固定的，它可以按需增大和缩小</strong>，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</p>
<h3 id="goroutine调度gpm"><a class="markdownIt-Anchor" href="#goroutine调度gpm"></a> goroutine调度（GPM）</h3>
<p><strong>GPM</strong>是Go语言运行时（runtime）层面的实现，是<strong>go语言自己实现的一套调度系统</strong>。区别于操作系统调度OS线程。</p>
<ul>
<li>G很好理解，就是个goroutine的，里面除了存放本goroutine信息外还有与所在P的绑定等信息</li>
<li><strong>P管理着一组goroutine队列</strong>，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），<strong>P会对自己管理的goroutine队列做一些调度</strong>（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等），<strong>当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务</strong></li>
<li>M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， <strong>一个groutine最终是要放到M上执行的</strong></li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： <strong>P管理着一组G挂载在M上运行</strong>。<strong>当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</strong></p>
<p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<strong>goroutine则是由Go运行时（runtime）自己的调度器调度的</strong>，这个调度器使用一个称为<code>m:n调度</code>的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的<code>malloc</code>函数（除非内存池需要改变），<strong>成本比调度OS线程低很多</strong>。 另一方面<strong>充分利用了多核的硬件资源</strong>，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
<h1 id="runtime包"><a class="markdownIt-Anchor" href="#runtime包"></a> runtime包</h1>
<p><a href="https://zhuanlan.zhihu.com/p/79122155" target="_blank" rel="noopener">知乎：GO语言基础进阶教程：runtime包</a></p>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/runtime%E5%8C%85.html" target="_blank" rel="noopener">runtime包</a></p>
<p>官网文档对runtime包的介绍：</p>
<blockquote>
<p>Package runtime contains operations that interact with Go’s runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see reflect’s documentation for the programmable interface to the run-time type system.</p>
</blockquote>
<p>尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。</p>
<p>runtime包的常用函数：</p>
<ul>
<li><code>NumCPU()</code>：返回当前系统的 CPU 核数量</li>
<li><code>GOMAXPROCS()</code>：设置最大的可同时使用的 CPU 核数<br />
通过runtime.GOMAXPROCS函数，应用程序何以在运行期间设置运行时系统中得P最大数量。但这会引起“Stop the World”。所以，应在应用程序最早的调用。并且最好是在运行Go程序之前设置好操作程序的环境变量GOMAXPROCS，而不是在程序中调用runtime.GOMAXPROCS函数。<br />
无论我们传递给函数的整数值是什么值，运行时系统的P最大值总会在1~256之间。</li>
</ul>
<blockquote>
<p>go1.8后，默认让程序运行在多个核上,可以不用设置了<br />
go1.8前，还是要设置一下，可以更高效的利益cpu</p>
</blockquote>
<ul>
<li><code>Gosched()</code>：让当前线程让出 cpu 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行。<br />
这个函数的作用是让当前 goroutine 让出 CPU，当一个 goroutine 发生阻塞，Go 会自动地把与该 goroutine 处于同一系统线程的其他 goroutine 转移到另一个系统线程上去，以使这些 goroutine 不阻塞。</li>
<li><code>Goexit()</code>：退出当前 goroutine(但是defer语句会照常执行)</li>
<li><code>NumGoroutine()</code>：返回正在执行和排队的任务总数<br />
runtime.NumGoroutine函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指Grunnable\Gruning\Gsyscall\Gwaition。处于这些状态的Groutine即被看做是活跃的或者说正在被调度。<br />
注意：垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器。</li>
<li><code>GOOS()</code>：目标操作系统</li>
<li><code>GC()</code>：runtime.GC()会让运行时系统进行一次强制性的垃圾收集<br />
1.强制的垃圾回收：不管怎样，都要进行的垃圾回收。2.非强制的垃圾回收：只会在一定条件下进行的垃圾回收（即运行时，系统自上次垃圾回收之后新申请的堆内存的单元（也成为单元增量）达到指定的数值）。</li>
<li><code>GOROOT()</code>：获取goroot目录</li>
<li><code>GOOS()</code> : 查看目标操作系统很多时候，我们会根据平台的不同实现不同的操作，就而已用GOOS了：</li>
</ul>
<h2 id="runtimegosched"><a class="markdownIt-Anchor" href="#runtimegosched"></a> runtime.Gosched()</h2>
<p><code>runtime.Gosched()</code>：让出CPU时间片，重新等待安排任务。</p>
<p>(大概意思就是本来计划的好好的周末出去烧烤，但是你妈让你去相亲，两种情况：第一就是你相亲速度非常快，见面就黄不耽误你继续烧烤；第二种情况就是你相亲速度特别慢，见面就是你侬我侬的，耽误了烧烤，但是相亲结束后还得去烧烤)</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">         fmt.Println(s)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;(<span class="string">"新开的协程"</span>)</span><br><span class="line">   <span class="comment">// 主协程</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">      runtime.Gosched() <span class="comment">// 切一下，再次分配任务</span></span><br><span class="line">      fmt.Println(<span class="string">"主协程"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220519083717.png" alt="" /></p>
<p>如果没有<code>runtime.Gosched()</code>，主协程跑完了就不会再执行我们新开的协程了。输出结果可能会没有“新开的协程”。</p>
<h2 id="runtimegoexit"><a class="markdownIt-Anchor" href="#runtimegoexit"></a> runtime.Goexit()</h2>
<p><code>runtime.Goexit()</code>：退出当前协程。</p>
<p>(一边烧烤一边相亲，突然发现相亲对象太丑影响烧烤，果断让她滚蛋，然后也就没有然后了)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"runtime"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   wg.Add(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      <span class="keyword">defer</span> fmt.Println(<span class="string">"A.defer"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> fmt.Println(<span class="string">"B.defer"</span>)</span><br><span class="line">         runtime.Goexit() <span class="comment">// 结束协程</span></span><br><span class="line">         <span class="keyword">defer</span> fmt.Println(<span class="string">"C.defer"</span>)</span><br><span class="line">         fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">      &#125;()</span><br><span class="line">      fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220519085940.png" alt="" /></p>
<p>可以看到结束协程之后，我们新开启的协程就结束了，后续的defer和Println都不起作用了。</p>
<h2 id="runtimegomaxprocs"><a class="markdownIt-Anchor" href="#runtimegomaxprocs"></a> runtime.GOMAXPROCS()</h2>
<p><code>runtime.GOMAXPROCS()</code>：Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数<strong>设置当前程序并发时占用的CPU逻辑核心数</strong>。</p>
<blockquote>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
</blockquote>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"runtime"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">   wg.Add(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">go</span> a()</span><br><span class="line">   <span class="keyword">go</span> b()</span><br><span class="line">   wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">11</span>; i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">"a"</span>, <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">11</span>; i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">"b"</span>, <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置<code>runtime.GOMAXPROCS(1)</code>，此时两个任务只有一个逻辑核心，结果是<strong>做完一个任务再做另一个任务</strong>。</p>
<p>如果 将逻辑核心数设为2，<code>runtime.GOMAXPROCS(2)</code>。此时两个任务并行执行。</p>
<h1 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h1>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel.html" target="_blank" rel="noopener">Channel</a></p>
<h2 id="channel类型"><a class="markdownIt-Anchor" href="#channel类型"></a> channel类型</h2>
<p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>
<p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>
<p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡<strong>通过通信共享内存</strong>而不是通过共享内存而实现通信。</p>
<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<strong>channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</strong></p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循**先入先出（First In First Out）**的规则，保证收发数据的顺序。<strong>每一个通道都是一个具体类型的导管</strong>，也就是声明channel的时候需要为其指定元素类型。</p>
<h2 id="声明channel"><a class="markdownIt-Anchor" href="#声明channel"></a> 声明channel</h2>
<p>channel是一种类型，一种引用类型。声明通道类型的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure>
<p>举几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="keyword">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="keyword">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure>
<h2 id="创建channel"><a class="markdownIt-Anchor" href="#创建channel"></a> 创建channel</h2>
<p><strong>channel是引用类型</strong>，通道类型的空值是<code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>
<p>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</p>
<p>创建channel的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure>
<ul>
<li>channel的缓冲大小是可选的</li>
</ul>
<p>举几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<h2 id="操作channel"><a class="markdownIt-Anchor" href="#操作channel"></a> 操作channel</h2>
<p>通道<code>channel</code>有发送（send）、接收(receive）和关闭（close）三种操作。发送和接收都使用<code>&lt;-</code>符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<h3 id="发送"><a class="markdownIt-Anchor" href="#发送"></a> 发送</h3>
<p>将一个值发送到通道中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure>
<h3 id="接收"><a class="markdownIt-Anchor" href="#接收"></a> 接收</h3>
<p>从一个通道中接收值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭"><a class="markdownIt-Anchor" href="#关闭"></a> 关闭</h3>
<p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<p>关于关闭通道需要注意的事情是，只有在通知接收方<code>goroutine</code>所有的数据都发送完毕的时候才需要关闭通道。<strong>通道是可以被垃圾回收机制回收的</strong>，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但<strong>关闭通道不是必须的</strong>。</p>
<p>关闭后的通道有以下特点：</p>
<ul>
<li>对一个关闭的通道再发送值就会导致<code>panic</code></li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值</li>
<li>关闭一个已经关闭的通道会导致<code>panic</code></li>
</ul>
<h2 id="无缓冲的channel"><a class="markdownIt-Anchor" href="#无缓冲的channel"></a> 无缓冲的channel</h2>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220519103032.png" alt="" /></p>
<p>无缓冲的通道又称为阻塞的通道。</p>
<p>我们来看一下下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   c &lt;- <span class="number">10</span></span><br><span class="line">   fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220519103212.png" alt="" /></p>
<p>为什么会出现<code>deadlock</code>错误呢？因为我们使用<code>c := make(chan int)</code>创建的是无缓冲的通道，<strong>无缓冲的通道只有在有人接收值的时候才能发送值</strong>。简单来说就是无缓冲的通道必须有接收才能发送。</p>
<p>上面的代码会阻塞在<code>c &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p>
<p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> recv(c) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">	c &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	i := &lt;-c</span><br><span class="line">	fmt.Println(<span class="string">"recv："</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<code>go recv(c)</code>和<code>c &lt;- 10</code>的顺序。如果<code>c &lt;- 10</code>在前面，同样会报<code>deadlock</code>的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- <span class="number">10</span></span><br><span class="line"><span class="keyword">go</span> recv(c) <span class="comment">// 启用goroutine从通道接收值</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220519103212.png" alt="" /></p>
</blockquote>
<p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，<strong>如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值</strong>。</p>
<h2 id="有缓冲的channel"><a class="markdownIt-Anchor" href="#有缓冲的channel"></a> 有缓冲的channel</h2>
<p>解决上面<code>deadlock</code>问题的方法还有一种就是使用有缓冲区的通道。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220519104249.png" alt="" /></p>
<p>我们可以在使用<code>make</code>函数初始化通道的时候为其指定通道的容量，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">1</span>)</span><br><span class="line">   c &lt;- <span class="number">10</span></span><br><span class="line">   fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量</strong>。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<blockquote>
<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p>
</blockquote>
<h2 id="close"><a class="markdownIt-Anchor" href="#close"></a> close()</h2>
<p>可以通过内置的<code>close()</code>函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">			c &lt;- i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		data, ok := &lt;-c <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			fmt.Println(data)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"main结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何优雅的从channel循环取值如何判断channel是否关闭"><a class="markdownIt-Anchor" href="#如何优雅的从channel循环取值如何判断channel是否关闭"></a> 如何优雅的从channel循环取值（如何判断channel是否关闭）</h3>
<p>先说结论。有两种方式在接收值的时候判断通道是否被关闭，一种是<code>data, ok := &lt;-c</code>来判断<code>ok</code>；一种是直接<code>for range</code>。我们通常使用的是<code>for range</code>的方式。</p>
<p>看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 开启goroutine将0~9的数发送到c1中</span></span><br><span class="line">      <span class="keyword">defer</span> <span class="built_in">close</span>(c1)</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">         c1 &lt;- i</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 开启goroutine从c1中接收值，并将该值的平方发送到c2中</span></span><br><span class="line">      <span class="keyword">defer</span> <span class="built_in">close</span>(c2)</span><br><span class="line">      <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">         data, ok := &lt;-c1 <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line">         <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         c2 &lt;- data * data</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">// 在主goroutine中从ch2中接收值打印</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> c2 &#123; <span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单向通道"><a class="markdownIt-Anchor" href="#单向通道"></a> 单向通道</h2>
<p>有的时候我们会<strong>将通道作为参数在多个任务函数间传递</strong>，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如<strong>限制通道在函数中只能发送或只能接收</strong>。</p>
<p>看个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">go</span> counter(c1)</span><br><span class="line">   <span class="keyword">go</span> squarer(c2, c1)</span><br><span class="line">   printer(c2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      out &lt;- i</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">      out &lt;- i * i</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>chan&lt;- int</code>是一个只能发送的通道，可以发送但是不能接收；</li>
<li><code>&lt;-chan int</code>是一个只能接收的通道，可以接收但是不能发送。</li>
</ul>
<p>在函数传参及任何赋值操作中<strong>将双向通道转换为单向通道是可以的</strong>，但反过来是不可以的。</p>
<h2 id="通道异常"><a class="markdownIt-Anchor" href="#通道异常"></a> 通道异常</h2>
<p><code>channel</code>常见的异常总结，如下图：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220519160400.png" alt="" /></p>
<p>注意：关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p>
<h1 id="goroutine池"><a class="markdownIt-Anchor" href="#goroutine池"></a> Goroutine池</h1>
<p>强烈推荐这篇文章，讲了许多操作系统知识：<strong><a href="https://strikefreedom.top/high-performance-implementation-of-goroutine-pool" target="_blank" rel="noopener">GMP 并发调度器深度解析之手撸一个高性能 goroutine pool</a></strong></p>
<h3 id="自己写一个goroutine池玩玩"><a class="markdownIt-Anchor" href="#自己写一个goroutine池玩玩"></a> 自己写一个goroutine池玩玩</h3>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/goroutine%E6%B1%A0.html" target="_blank" rel="noopener">Goroutine池</a></p>
<ul>
<li>本质上是生产者消费者模型</li>
<li>可以有效控制goroutine数量，防止暴涨</li>
<li>需求：
<ul>
<li>计算一个数字的各个位数之和，例如数字123，结果为1+2+3=6</li>
<li>随机生成数字进行计算</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">   Id      <span class="keyword">int</span> <span class="comment">// id</span></span><br><span class="line">   RandNum <span class="keyword">int</span> <span class="comment">// 需要计算的随机数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">   job *Job <span class="comment">// 这里必须传对象实例</span></span><br><span class="line">   sum <span class="keyword">int</span>  <span class="comment">// 求出的和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 需要2个管道</span></span><br><span class="line">   jobChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *Job, <span class="number">128</span>)       <span class="comment">// 1.job管道</span></span><br><span class="line">   resultChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *Result, <span class="number">128</span>) <span class="comment">// 2.结果管道</span></span><br><span class="line">   createPool(<span class="number">64</span>, jobChan, resultChan)   <span class="comment">// 3.创建工作池</span></span><br><span class="line">   <span class="comment">// 4.开个打印的协程</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(resultChan <span class="keyword">chan</span> *Result)</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> result := <span class="keyword">range</span> resultChan &#123;</span><br><span class="line">         fmt.Printf(<span class="string">"job id:%v randnum:%v result:%d\n"</span>, result.job.Id,</span><br><span class="line">            result.job.RandNum, result.sum)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;(resultChan)</span><br><span class="line">   <span class="keyword">var</span> id <span class="keyword">int</span></span><br><span class="line">   <span class="comment">// 循环创建job，输入到jobChan</span></span><br><span class="line">   <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">      id++</span><br><span class="line">      randNum := rand.Int()</span><br><span class="line">      job := &amp;Job&#123;</span><br><span class="line">         Id:      id,</span><br><span class="line">         RandNum: randNum,</span><br><span class="line">      &#125;</span><br><span class="line">      jobChan &lt;- job</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建工作池（num代表开几个协程）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createPool</span><span class="params">(num <span class="keyword">int</span>, jobChan <span class="keyword">chan</span> *Job, resultChan <span class="keyword">chan</span> *Result)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 根据开的协程个数运行</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(jobChan <span class="keyword">chan</span> *Job, resultChan <span class="keyword">chan</span> *Result)</span></span> &#123; <span class="comment">// 执行运算</span></span><br><span class="line">         <span class="comment">// 遍历job管道所有数据，进行相加</span></span><br><span class="line">         <span class="keyword">for</span> job := <span class="keyword">range</span> jobChan &#123;</span><br><span class="line">            randNum := job.RandNum <span class="comment">// 随机数接过来</span></span><br><span class="line">            <span class="comment">// 随机数每一位相加</span></span><br><span class="line">            <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">            <span class="keyword">for</span> randNum != <span class="number">0</span> &#123;</span><br><span class="line">               temp := randNum % <span class="number">10</span></span><br><span class="line">               sum = sum + temp</span><br><span class="line">               randNum = randNum / <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 结果封装到Result中</span></span><br><span class="line">            r := &amp;Result&#123;</span><br><span class="line">               job: job,</span><br><span class="line">               sum: sum,</span><br><span class="line">            &#125;</span><br><span class="line">            resultChan &lt;- r <span class="comment">// 运算结果扔到管道</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;(jobChan, resultChan)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h1>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%AE%9A%E6%97%B6%E5%99%A8.html" target="_blank" rel="noopener">定时器</a></p>
<ul>
<li>Timer：时间到了，执行只执行1次</li>
<li>Ticker：时间到了，多次执行</li>
</ul>
<h2 id="timer"><a class="markdownIt-Anchor" href="#timer"></a> Timer</h2>
<p>Timer：时间到了，执行且只执行1次。</p>
<ol>
<li>
<p>timer基本使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   timer := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">   t1 := time.Now()</span><br><span class="line">   fmt.Printf(<span class="string">"t1:%v\n"</span>, t1) <span class="comment">// t1:2022-06-16 11:53:28.4475827 +0800 CST m=+0.004452101</span></span><br><span class="line">   t2 := &lt;-timer.C</span><br><span class="line">   fmt.Printf(<span class="string">"t2:%v\n"</span>, t2) <span class="comment">// t2:2022-06-16 11:53:30.4493612 +0800 CST m=+2.006230601</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>验证timer只能响应一次</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   timer := time.NewTimer(time.Second * <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">      &lt;-timer.C</span><br><span class="line">      fmt.Println(<span class="string">"时间到"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220616120323.png" alt="" /></p>
</li>
<li>
<p>timer实现延时功能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 方法1</span></span><br><span class="line">   time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">   fmt.Println(<span class="string">"1秒过去了"</span>)</span><br><span class="line">   <span class="comment">// 方法2</span></span><br><span class="line">   timer := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">   &lt;-timer.C</span><br><span class="line">   fmt.Println(<span class="string">"2秒过去了"</span>)</span><br><span class="line">   <span class="comment">// 方法3</span></span><br><span class="line">   &lt;-time.After(time.Second * <span class="number">2</span>)</span><br><span class="line">   fmt.Println(<span class="string">"2秒过去了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>停止定时器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   timer := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      &lt;-timer.C</span><br><span class="line">      fmt.Println(<span class="string">"定时器执行了"</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   stop := timer.Stop()</span><br><span class="line">   <span class="keyword">if</span> stop &#123;</span><br><span class="line">      fmt.Println(<span class="string">"timer已经关闭了"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重置定时器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   timer := time.NewTimer(time.Second * <span class="number">3</span>)</span><br><span class="line">   timer.Reset(time.Second * <span class="number">1</span>)</span><br><span class="line">   fmt.Println(time.Now()) <span class="comment">// 2022-06-16 12:18:38.9311858 +0800 CST m=+0.004419601</span></span><br><span class="line">   fmt.Println(&lt;-timer.C)  <span class="comment">// 2022-06-16 12:18:39.942039 +0800 CST m=+1.015272801</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ticker"><a class="markdownIt-Anchor" href="#ticker"></a> Ticker</h2>
<p>Ticker：时间到了，多次执行。</p>
<p>看个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">         i++</span><br><span class="line">         fmt.Println(&lt;-ticker.C)</span><br><span class="line">         <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">            ticker.Stop() <span class="comment">// 停止</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">for</span> <span class="literal">true</span> &#123; <span class="comment">// 这里写个死循环是为了等待子协程能够执行完毕</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220616122315.png" alt="" /></p>
<p>可以发现输出5次之后就停止输出了。</p>
<h1 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h1>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/select.html" target="_blank" rel="noopener">select</a></p>
<p><strong><a href="https://juejin.cn/post/6882984260672847879" target="_blank" rel="noopener">彻底理解 IO 多路复用实现机制</a></strong></p>
<p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。</p>
<p>你也许会写出如下代码使用遍历的方式来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从ch1接收值</span></span><br><span class="line">    data, ok := &lt;-ch1</span><br><span class="line">    <span class="comment">// 尝试从ch2接收值</span></span><br><span class="line">    data, ok := &lt;-ch2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。（<a href="https://www.qingbo1011.top/2022/04/23/Golang%E5%9F%BA%E7%A1%8001/#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5select">条件语句select</a>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">   <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line"><span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">   <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">   <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>select可以同时监听一个或多个channel，直到其中一个channel ready</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 2个管道</span></span><br><span class="line">   ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">   ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">   <span class="comment">// 跑2个子协程，写数据</span></span><br><span class="line">   <span class="keyword">go</span> test1(ch1)</span><br><span class="line">   <span class="keyword">go</span> test2(ch2)</span><br><span class="line">   <span class="comment">// 用select监控</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> str1 := &lt;-ch1:</span><br><span class="line">      fmt.Println(str1)</span><br><span class="line">   <span class="keyword">case</span> str2 := &lt;-ch2:</span><br><span class="line">      fmt.Println(str2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">   ch &lt;- <span class="string">"test1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">   ch &lt;- <span class="string">"test2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果多个channel同时ready，则随机选择一个执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建2个管道</span></span><br><span class="line">   int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">   string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//time.Sleep(2 * time.Second)</span></span><br><span class="line">      int_chan &lt;- <span class="number">1</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      string_chan &lt;- <span class="string">"hello"</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">      fmt.Println(<span class="string">"int:"</span>, value)</span><br><span class="line">   <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">      fmt.Println(<span class="string">"string:"</span>, value)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">"main结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以用于判断管道是否存满</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断管道有没有存满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建管道</span></span><br><span class="line">   output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="comment">// 子协程写数据</span></span><br><span class="line">   <span class="keyword">go</span> write(output1)</span><br><span class="line">   <span class="comment">// 取数据</span></span><br><span class="line">   <span class="keyword">for</span> s := <span class="keyword">range</span> output1 &#123;</span><br><span class="line">      fmt.Println(<span class="string">"res:"</span>, s)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      <span class="keyword">case</span> ch &lt;- <span class="string">"hello"</span>:</span><br><span class="line">         fmt.Println(<span class="string">"write hello"</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">"channel full"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="并发安全和锁"><a class="markdownIt-Anchor" href="#并发安全和锁"></a> 并发安全和锁</h1>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81.html" target="_blank" rel="noopener">并发安全和锁</a></p>
<p>有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	<span class="keyword">go</span> add()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		x++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多次运行可以发现输出的结果是不一样的！因为上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>
<h2 id="互斥锁"><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h2>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81.html#%E4%BA%92%E6%96%A5%E9%94%81" target="_blank" rel="noopener">互斥锁</a></p>
<p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的<code>Mutex</code>类型来实现互斥锁。</p>
<p>使用互斥锁来修复上面代码的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   wg.Add(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">go</span> add()</span><br><span class="line">   <span class="keyword">go</span> add()</span><br><span class="line">   wg.Wait()</span><br><span class="line">   fmt.Println(x) <span class="comment">// 10000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">      lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">      x++</span><br><span class="line">      lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。</strong></p>
<h2 id="读写互斥锁"><a class="markdownIt-Anchor" href="#读写互斥锁"></a> 读写互斥锁</h2>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81.html#%E8%AF%BB%E5%86%99%E4%BA%92%E6%96%A5%E9%94%81" target="_blank" rel="noopener">读写互斥锁</a></p>
<p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：<strong>读锁</strong>和<strong>写锁</strong>。</p>
<ul>
<li>当一个goroutine获取<strong>读锁</strong>之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；</li>
<li>当一个goroutine获取<strong>写锁</strong>之后，其他的goroutine无论是获取读锁还是写锁都会等待。</li>
</ul>
<p>读写锁示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> rwLock sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   start := time.Now()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> write()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> read()</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   end := time.Now()</span><br><span class="line">   fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line">   rwLock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">   x++</span><br><span class="line">   time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// 假设写操作消耗10ms</span></span><br><span class="line">   rwLock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line">   rwLock.RLock()                   <span class="comment">// 加读锁</span></span><br><span class="line">   time.Sleep(time.Millisecond * <span class="number">1</span>) <span class="comment">// 假设读操作消耗1ms</span></span><br><span class="line">   rwLock.RUnlock()                 <span class="comment">// 解读锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是读写锁非常适合<strong>读多写少</strong>的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>
<h1 id="sync包"><a class="markdownIt-Anchor" href="#sync包"></a> Sync包</h1>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.html" target="_blank" rel="noopener">Sync</a></p>
<h2 id="syncwaitgroup"><a class="markdownIt-Anchor" href="#syncwaitgroup"></a> sync.WaitGroup</h2>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.html#syncwaitgroup" target="_blank" rel="noopener">sync.WaitGroup</a></p>
<p>这个在之前就已经用过很多次了，其实用起来很简单。</p>
<p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>(wg * WaitGroup) Add(delta int)</td>
<td>计数器+delta</td>
</tr>
<tr>
<td>(wg *WaitGroup) Done()</td>
<td>计数器-1</td>
</tr>
<tr>
<td>(wg *WaitGroup) Wait()</td>
<td>阻塞直到计数器变为0</td>
</tr>
</tbody>
</table>
<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就调用<code>wg.Add(N)</code>，将计数器值增加N。每个任务完成时通过调用<code>wg.Done()</code>方法将计数器减1。通过调用<code>wg.Wait()</code>来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>我们利用sync.WaitGroup将上面的代码优化一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。</p>
<h2 id="synconce"><a class="markdownIt-Anchor" href="#synconce"></a> sync.Once</h2>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.html#synconce" target="_blank" rel="noopener">sync.Once</a></p>
<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的sync包中提供了一个针对只执行一次场景的解决方案：<code>sync.Once</code>。</p>
<p>sync.Once只有一个Do方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果要执行的函数f需要传递参数就需要搭配闭包来使用。</p>
<h3 id="加载配置文件示例"><a class="markdownIt-Anchor" href="#加载配置文件示例"></a> 加载配置文件示例</h3>
<p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">        <span class="string">"left"</span>:  loadIcon(<span class="string">"left.png"</span>),</span><br><span class="line">        <span class="string">"up"</span>:    loadIcon(<span class="string">"up.png"</span>),</span><br><span class="line">        <span class="string">"right"</span>: loadIcon(<span class="string">"right.png"</span>),</span><br><span class="line">        <span class="string">"down"</span>:  loadIcon(<span class="string">"down.png"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        loadIcons()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line">    icons[<span class="string">"left"</span>] = loadIcon(<span class="string">"left.png"</span>)</span><br><span class="line">    icons[<span class="string">"up"</span>] = loadIcon(<span class="string">"up.png"</span>)</span><br><span class="line">    icons[<span class="string">"right"</span>] = loadIcon(<span class="string">"right.png"</span>)</span><br><span class="line">    icons[<span class="string">"down"</span>] = loadIcon(<span class="string">"down.png"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>
<p>使用<code>sync.Once</code>改造的示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">        <span class="string">"left"</span>:  loadIcon(<span class="string">"left.png"</span>),</span><br><span class="line">        <span class="string">"up"</span>:    loadIcon(<span class="string">"up.png"</span>),</span><br><span class="line">        <span class="string">"right"</span>: loadIcon(<span class="string">"right.png"</span>),</span><br><span class="line">        <span class="string">"down"</span>:  loadIcon(<span class="string">"down.png"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sync.Once</code>其实内部包含一个<strong>互斥锁</strong>和一个<strong>布尔值</strong>，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h2 id="syncmap"><a class="markdownIt-Anchor" href="#syncmap"></a> sync.Map</h2>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.html#syncmap" target="_blank" rel="noopener">sync.Map</a></p>
<p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"strconv"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         key := strconv.Itoa(n) <span class="comment">// 将整型转换为字符串</span></span><br><span class="line">         set(key, n)</span><br><span class="line">         fmt.Printf(<span class="string">"k=:%v,v:=%v\n"</span>, key, get(key))</span><br><span class="line">      &#125;(i)</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   m[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>
<p><img src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220616174157.png" alt="" /></p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个<strong>开箱即用的并发安全版map</strong>：<code>sync.Map</code>。<strong>开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用</strong>。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"strconv"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         key := strconv.Itoa(n)</span><br><span class="line">         m.Store(key, n)</span><br><span class="line">         value, ok := m.Load(key)</span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"k=:%v,v:=%v\n"</span>, key, value)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;(i)</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="atomic包原子操作"><a class="markdownIt-Anchor" href="#atomic包原子操作"></a> atomic包（原子操作）</h1>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8Catomic%E5%8C%85.html" target="_blank" rel="noopener">原子操作(atomic包)</a></p>
<h2 id="原子操作"><a class="markdownIt-Anchor" href="#原子操作"></a> 原子操作</h2>
<p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>
<h2 id="atomic包"><a class="markdownIt-Anchor" href="#atomic包"></a> atomic包</h2>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr <code>*int64</code>) (val int64)<br>func LoadUint32(addr<code>*uint32</code>) (val uint32)<br>func LoadUint64(addr<code>*uint64</code>) (val uint64)<br>func LoadUintptr(addr<code>*uintptr</code>) (val uintptr)<br>func LoadPointer(addr<code>*unsafe.Pointer</code>) (val unsafe.Pointer)</td>
<td>读取操作</td>
</tr>
<tr>
<td style="text-align:center">func StoreInt32(addr <code>*int32</code>, val int32) func StoreInt64(addr <code>*int64</code>, val int64) func StoreUint32(addr <code>*uint32</code>, val uint32) func StoreUint64(addr <code>*uint64</code>, val uint64) func StoreUintptr(addr <code>*uintptr</code>, val uintptr) func StorePointer(addr <code>*unsafe.Pointer</code>, val unsafe.Pointer)</td>
<td>写入操作</td>
</tr>
<tr>
<td style="text-align:center">func AddInt32(addr <code>*int32</code>, delta int32) (new int32) func AddInt64(addr <code>*int64</code>, delta int64) (new int64) func AddUint32(addr <code>*uint32</code>, delta uint32) (new uint32) func AddUint64(addr <code>*uint64</code>, delta uint64) (new uint64) func AddUintptr(addr <code>*uintptr</code>, delta uintptr) (new uintptr)</td>
<td>修改操作</td>
</tr>
<tr>
<td style="text-align:center">func SwapInt32(addr <code>*int32</code>, new int32) (old int32) func SwapInt64(addr <code>*int64</code>, new int64) (old int64) func SwapUint32(addr <code>*uint32</code>, new uint32) (old uint32) func SwapUint64(addr <code>*uint64</code>, new uint64) (old uint64) func SwapUintptr(addr <code>*uintptr</code>, new uintptr) (old uintptr) func SwapPointer(addr <code>*unsafe.Pointer</code>, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td>交换操作</td>
</tr>
<tr>
<td style="text-align:center">func CompareAndSwapInt32(addr <code>*int32</code>, old, new int32) (swapped bool) func CompareAndSwapInt64(addr <code>*int64</code>, old, new int64) (swapped bool) func CompareAndSwapUint32(addr <code>*uint32</code>, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr <code>*uint64</code>, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr <code>*uintptr</code>, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr <code>*unsafe.Pointer</code>, old, new unsafe.Pointer) (swapped bool)</td>
<td>比较并交换操作</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>func LoadInt32(addr *int32) (val int32)</code><br/><code>func LoadInt64(addr *int64) (val int64)</code><br/><code>func LoadUint32(addr*uint32) (val uint32)</code><br/><code>func LoadUint64(addr*uint64) (val uint64)</code><br/><code>func LoadUintptr(addr*uintptr) (val uintptr)</code><br/><code>func LoadPointer(addr*unsafe.Pointer) (val unsafe.Pointer)</code></td>
<td style="text-align:center">读取操作</td>
</tr>
<tr>
<td style="text-align:center"><code>func StoreInt32(addr *int32, val int32)</code><br/><code>func StoreInt64(addr *int64, val int64)</code><br/><code>func StoreUint32(addr *uint32, val uint32)</code><br/><code>func StoreUint64(addr *uint64, val uint64)</code><br/><code>func StoreUintptr(addr *uintptr, val uintptr)</code><br/><code>func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</code></td>
<td style="text-align:center">写入操作</td>
</tr>
<tr>
<td style="text-align:center"><code>func AddInt32(addr *int32, delta int32) (new int32)</code><br/><code>func AddInt64(addr *int64, delta int64) (new int64)</code><br/><code>func AddUint32(addr *uint32, delta uint32) (new uint32)</code><br/><code>func AddUint64(addr *uint64, delta uint64) (new uint64)</code><br/><code>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</code></td>
<td style="text-align:center">修改操作</td>
</tr>
<tr>
<td style="text-align:center"><code>func SwapInt32(addr *int32, new int32) (old int32)</code><br/><code>func SwapInt64(addr *int64, new int64) (old int64)</code><br/><code>func SwapUint32(addr *uint32, new uint32) (old uint32)</code><br/><code>func SwapUint64(addr *uint64, new uint64) (old uint64)</code><br/><code>func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</code><br/><code>func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</code></td>
<td style="text-align:center">交换操作</td>
</tr>
<tr>
<td style="text-align:center"><code>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)&lt;br/&gt;func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)&lt;br/&gt;func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)&lt;br/&gt;func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)&lt;br/&gt;func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</code><br/><code>func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</code></td>
<td style="text-align:center">比较并交换操作</td>
</tr>
</tbody>
</table>
<h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2>
<p>看个例子，来比较一下互斥锁和原子操作的性能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">   <span class="string">"sync/atomic"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// x = x + 1</span></span><br><span class="line">   x++ <span class="comment">// 等价于上面的操作</span></span><br><span class="line">   wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutexAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">   lock.Lock()</span><br><span class="line">   x++</span><br><span class="line">   lock.Unlock()</span><br><span class="line">   wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomicAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">   atomic.AddInt64(&amp;x, <span class="number">1</span>)</span><br><span class="line">   wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   start := time.Now()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">//go add()       // 普通版add函数 不是并发安全的（9552  4.1647ms）</span></span><br><span class="line">      <span class="comment">//go mutexAdd()  // 加锁版add函数 是并发安全的，但是加锁性能开销大（10000 3.6763ms）</span></span><br><span class="line">      <span class="keyword">go</span> atomicAdd() <span class="comment">// 原子操作版add函数 是并发安全，性能优于加锁版（10000 3.0914ms）</span></span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   end := time.Now()</span><br><span class="line">   fmt.Println(x)</span><br><span class="line">   fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。<strong>这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好</strong>。</p>
<h1 id="gmp-原理与调度"><a class="markdownIt-Anchor" href="#gmp-原理与调度"></a> GMP 原理与调度</h1>
<p><strong><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html" target="_blank" rel="noopener">GMP 原理与调度</a></strong></p>
<p>（面试常问）</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:qingbo1011@163.com">qingbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.qingbo1011.top/2022/04/26/Golang%E8%BF%9B%E9%98%B602%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">http://www.qingbo1011.top/2022/04/26/Golang%E8%BF%9B%E9%98%B602%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.qingbo1011.top" target="_blank">Qing's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post_share"><div class="social-share" data-image="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20231003161115.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/04/27/Go%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/"><img class="prev_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220711144924.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go常用标准库</div></div></a></div><div class="next-post pull_right"><a href="/2022/04/25/Golang%E8%BF%9B%E9%98%B601%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><img class="next_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png" onerror="onerror=null;src='https://gitee.com/qingyu1011/blog_img/raw/master/img/20201006230435.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Golang进阶——网络编程</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/06/26/Gin+Gorm v2+Github Action的实践/" title="Gin+Gorm v2+Github Action的实践"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220808182712.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-06-26</div><div class="relatedPosts_title">Gin+Gorm v2+Github Action的实践</div></div></a></div><div class="relatedPosts_item"><a href="/2022/05/02/Gin+Gorm开发在线备忘录（To do list）/" title="Gin+Gorm开发在线备忘录（To do list）"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220525201522.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-05-02</div><div class="relatedPosts_title">Gin+Gorm开发在线备忘录（To do list）</div></div></a></div><div class="relatedPosts_item"><a href="/2022/05/01/Gin+JWT+Air热部署的简单实践/" title="Gin+JWT+Air热部署的简单实践"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220525201522.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-05-01</div><div class="relatedPosts_title">Gin+JWT+Air热部署的简单实践</div></div></a></div><div class="relatedPosts_item"><a href="/2022/05/21/Gin+WebSocket+MongoDB的IM即时聊天Demo/" title="Gin+Websocket+MangoDB实现的IM系统"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220525201522.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-05-21</div><div class="relatedPosts_title">Gin+Websocket+MangoDB实现的IM系统</div></div></a></div><div class="relatedPosts_item"><a href="/2022/06/12/Gin-blog：go1.18在gin上的实践/" title="Gin-blog：go1.18在gin上的实践"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220525201522.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-06-12</div><div class="relatedPosts_title">Gin-blog：go1.18在gin上的实践</div></div></a></div><div class="relatedPosts_item"><a href="/2022/05/10/Gin限流/" title="Gin限流"><img class="relatedPosts_cover" src="https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220718144444.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-05-10</div><div class="relatedPosts_title">Gin限流</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'oNS5Emx1qUL3wN5yvPLKol0W-gzGzoHsz',
  appKey: 'ytbw0ho3DMX0FeoAOWa37lf9',
  notify: false,
  verify: false,
  placeholder: 'Stay hungry,stay foolish~',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: 'https://',
  emojiMaps: {"欢呼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100836.gif","笑眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100849.gif","花心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100907.gif","吐舌":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100937.gif","疑问":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502100951.gif","滑稽":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101004.gif","太开心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101017.gif","酷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101029.gif","怒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101044.gif","阴险":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101100.gif","委屈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101116.gif","乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101129.gif","你懂的":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101204.gif","小乖":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101215.gif","突然兴奋":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101228.gif","喷":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101241.gif","哈哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101255.gif","喝酒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101305.gif","汗":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101323.gif","笑尿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102004.gif","嘿嘿嘿":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102018.gif","真棒":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102047.gif","托腮":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102108.gif","微笑":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/e3/2018new_weixioa02_org.png","礼貌":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/09/2018new_keai_org.png","笑哭":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/4a/2018new_xiaoku_thumb.png","无奈":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/83/2018new_kuxiao_org.png","爱你":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/f6/2018new_aini_org.png","吃瓜":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/01/2018new_chigua_thumb.png","doge":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/a1/2018new_doge02_org.png","dog":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/22/2018new_erha_org.png","cat":"https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/7b/2018new_miaomiao_thumb.png","星星眼":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102225.png","酸了":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102240.png","大哭":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102254.png","傲娇":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102314.png","给心心":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102328.png","嘿哈":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102345.png","custom0":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101410.gif","custom1":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101424.webp","狗头":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101710.png","搬砖中":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502101744.png","忙到飞起":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102411.png","裂开":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102426.png","叹气":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102439.png","让我看看":"https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220502102456.png","panda0":"https://bbs.res.meizu.com/static/image/smiley/panda/_000.png","panda1":"https://bbs.res.meizu.com/static/image/smiley/panda/_001.png","panda2":"https://bbs.res.meizu.com/static/image/smiley/panda/_002.png","panda3":"https://bbs.res.meizu.com/static/image/smiley/panda/_003.png","panda4":"https://bbs.res.meizu.com/static/image/smiley/panda/_004.png","panda5":"https://bbs.res.meizu.com/static/image/smiley/panda/_005.png","panda6":"https://bbs.res.meizu.com/static/image/smiley/panda/_006.png","panda7":"https://bbs.res.meizu.com/static/image/smiley/panda/_007.png","panda8":"https://bbs.res.meizu.com/static/image/smiley/panda/_008.png","panda9":"https://bbs.res.meizu.com/static/image/smiley/panda/_009.png","panda10":"https://bbs.res.meizu.com/static/image/smiley/panda/_010.png","panda11":"https://bbs.res.meizu.com/static/image/smiley/panda/_011.png","panda12":"https://bbs.res.meizu.com/static/image/smiley/panda/_012.png","panda13":"https://bbs.res.meizu.com/static/image/smiley/panda/_013.png","panda14":"https://bbs.res.meizu.com/static/image/smiley/panda/_014.png","panda15":"https://bbs.res.meizu.com/static/image/smiley/panda/_015.png","panda16":"https://bbs.res.meizu.com/static/image/smiley/panda/_016.png","panda17":"https://bbs.res.meizu.com/static/image/smiley/panda/_017.png","panda18":"https://bbs.res.meizu.com/static/image/smiley/panda/_018.png","panda19":"https://bbs.res.meizu.com/static/image/smiley/panda/_019.png","panda20":"https://bbs.res.meizu.com/static/image/smiley/panda/_020.png","panda21":"https://bbs.res.meizu.com/static/image/smiley/panda/_021.png","panda22":"https://bbs.res.meizu.com/static/image/smiley/panda/_022.png","panda23":"https://bbs.res.meizu.com/static/image/smiley/panda/_023.png","panda24":"https://bbs.res.meizu.com/static/image/smiley/panda/_024.png","panda25":"https://bbs.res.meizu.com/static/image/smiley/panda/_025.png","panda26":"https://bbs.res.meizu.com/static/image/smiley/panda/_026.png","panda27":"https://bbs.res.meizu.com/static/image/smiley/panda/_027.png","panda28":"https://bbs.res.meizu.com/static/image/smiley/panda/_028.png","panda29":"https://bbs.res.meizu.com/static/image/smiley/panda/_029.png"},
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://img-qingbo.oss-cn-beijing.aliyuncs.com/img/20220509153103.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By qingbo</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">宇宙很大，生活更大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script></body></html>